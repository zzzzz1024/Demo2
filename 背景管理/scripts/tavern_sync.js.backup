import { createRequire as __WEBPACK_EXTERNAL_createRequire } from 'node:module';
import { fileURLToPath as __webpack_fileURLToPath__ } from 'node:url';
/******/ const __webpack_modules__ = {
  /***/ 9: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    /*!
     * accepts
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module dependencies.
     * @private
     */

    const Negotiator = __webpack_require__(1882);
    const mime = __webpack_require__(1976);

    /**
     * Module exports.
     * @public
     */

    module.exports = Accepts;

    /**
     * Create a new Accepts object for the given req.
     *
     * @param {object} req
     * @public
     */

    function Accepts(req) {
      if (!(this instanceof Accepts)) {
        return new Accepts(req);
      }

      this.headers = req.headers;
      this.negotiator = new Negotiator(req);
    }

    /**
     * Check if the given `type(s)` is acceptable, returning
     * the best match when true, otherwise `undefined`, in which
     * case you should respond with 406 "Not Acceptable".
     *
     * The `type` value may be a single mime type string
     * such as "application/json", the extension name
     * such as "json" or an array `["json", "html", "text/plain"]`. When a list
     * or array is given the _best_ match, if any is returned.
     *
     * Examples:
     *
     *     // Accept: text/html
     *     this.types('html');
     *     // => "html"
     *
     *     // Accept: text/*, application/json
     *     this.types('html');
     *     // => "html"
     *     this.types('text/html');
     *     // => "text/html"
     *     this.types('json', 'text');
     *     // => "json"
     *     this.types('application/json');
     *     // => "application/json"
     *
     *     // Accept: text/*, application/json
     *     this.types('image/png');
     *     this.types('png');
     *     // => undefined
     *
     *     // Accept: text/*;q=.5, application/json
     *     this.types(['html', 'json']);
     *     this.types('html', 'json');
     *     // => "json"
     *
     * @param {String|Array} types...
     * @return {String|Array|Boolean}
     * @public
     */

    Accepts.prototype.type = Accepts.prototype.types = function (types_) {
      let types = types_;

      // support flattened arguments
      if (types && !Array.isArray(types)) {
        types = new Array(arguments.length);
        for (let i = 0; i < types.length; i++) {
          types[i] = arguments[i];
        }
      }

      // no types, return all requested types
      if (!types || types.length === 0) {
        return this.negotiator.mediaTypes();
      }

      // no accept header, return first given type
      if (!this.headers.accept) {
        return types[0];
      }

      const mimes = types.map(extToMime);
      const accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
      const first = accepts[0];

      return first ? types[mimes.indexOf(first)] : false;
    };

    /**
     * Return accepted encodings or best fit based on `encodings`.
     *
     * Given `Accept-Encoding: gzip, deflate`
     * an array sorted by quality is returned:
     *
     *     ['gzip', 'deflate']
     *
     * @param {String|Array} encodings...
     * @return {String|Array}
     * @public
     */

    Accepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {
      let encodings = encodings_;

      // support flattened arguments
      if (encodings && !Array.isArray(encodings)) {
        encodings = new Array(arguments.length);
        for (let i = 0; i < encodings.length; i++) {
          encodings[i] = arguments[i];
        }
      }

      // no encodings, return all requested encodings
      if (!encodings || encodings.length === 0) {
        return this.negotiator.encodings();
      }

      return this.negotiator.encodings(encodings)[0] || false;
    };

    /**
     * Return accepted charsets or best fit based on `charsets`.
     *
     * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
     * an array sorted by quality is returned:
     *
     *     ['utf-8', 'utf-7', 'iso-8859-1']
     *
     * @param {String|Array} charsets...
     * @return {String|Array}
     * @public
     */

    Accepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {
      let charsets = charsets_;

      // support flattened arguments
      if (charsets && !Array.isArray(charsets)) {
        charsets = new Array(arguments.length);
        for (let i = 0; i < charsets.length; i++) {
          charsets[i] = arguments[i];
        }
      }

      // no charsets, return all requested charsets
      if (!charsets || charsets.length === 0) {
        return this.negotiator.charsets();
      }

      return this.negotiator.charsets(charsets)[0] || false;
    };

    /**
     * Return accepted languages or best fit based on `langs`.
     *
     * Given `Accept-Language: en;q=0.8, es, pt`
     * an array sorted by quality is returned:
     *
     *     ['es', 'pt', 'en']
     *
     * @param {String|Array} langs...
     * @return {Array|String}
     * @public
     */

    Accepts.prototype.lang =
      Accepts.prototype.langs =
      Accepts.prototype.language =
      Accepts.prototype.languages =
        function (languages_) {
          let languages = languages_;

          // support flattened arguments
          if (languages && !Array.isArray(languages)) {
            languages = new Array(arguments.length);
            for (let i = 0; i < languages.length; i++) {
              languages[i] = arguments[i];
            }
          }

          // no languages, return all requested languages
          if (!languages || languages.length === 0) {
            return this.negotiator.languages();
          }

          return this.negotiator.languages(languages)[0] || false;
        };

    /**
     * Convert extnames to mime.
     *
     * @param {String} type
     * @return {String}
     * @private
     */

    function extToMime(type) {
      return type.indexOf('/') === -1 ? mime.lookup(type) : type;
    }

    /**
     * Check if mime is valid.
     *
     * @param {String} type
     * @return {String}
     * @private
     */

    function validMime(type) {
      return typeof type === 'string';
    }

    /***/
  },

  /***/ 21: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.StrictEventEmitter = void 0;
    const events_1 = __webpack_require__(4434);
    /**
     * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
     * parameters for mappings of event names to event data types, and strictly
     * types method calls to the `EventEmitter` according to these event maps.
     *
     * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
     * listened to with `on` or `once`
     * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
     * emitted with `emit`
     * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
     * emitted by socket.io with `emitReserved`, and can be listened to with
     * `listen`.
     */
    class StrictEventEmitter extends events_1.EventEmitter {
      /**
       * Adds the `listener` function as an event listener for `ev`.
       *
       * @param ev Name of the event
       * @param listener Callback function
       */
      on(ev, listener) {
        return super.on(ev, listener);
      }
      /**
       * Adds a one-time `listener` function as an event listener for `ev`.
       *
       * @param ev Name of the event
       * @param listener Callback function
       */
      once(ev, listener) {
        return super.once(ev, listener);
      }
      /**
       * Emits an event.
       *
       * @param ev Name of the event
       * @param args Values to send to listeners of this event
       */
      emit(ev, ...args) {
        return super.emit(ev, ...args);
      }
      /**
       * Emits a reserved event.
       *
       * This method is `protected`, so that only a class extending
       * `StrictEventEmitter` can emit its own reserved events.
       *
       * @param ev Reserved event name
       * @param args Arguments to emit along with the event
       */
      emitReserved(ev, ...args) {
        return super.emit(ev, ...args);
      }
      /**
       * Emits an event.
       *
       * This method is `protected`, so that only a class extending
       * `StrictEventEmitter` can get around the strict typing. This is useful for
       * calling `emit.apply`, which can be called as `emitUntyped.apply`.
       *
       * @param ev Event name
       * @param args Arguments to emit along with the event
       */
      emitUntyped(ev, ...args) {
        return super.emit(ev, ...args);
      }
      /**
       * Returns the listeners listening to an event.
       *
       * @param event Event name
       * @returns Array of listeners subscribed to `event`
       */
      listeners(event) {
        return super.listeners(event);
      }
    }
    exports.StrictEventEmitter = StrictEventEmitter;

    /***/
  },

  /***/ 45: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const map = __webpack_require__(4304);
    const _null = __webpack_require__(4985);
    const seq = __webpack_require__(581);
    const string = __webpack_require__(4401);
    const bool = __webpack_require__(3754);
    const float = __webpack_require__(3554);
    const int = __webpack_require__(9605);

    const schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.boolTag,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
    ];

    exports.schema = schema;

    /***/
  },

  /***/ 90: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const identity = __webpack_require__(7182);
    const toJS = __webpack_require__(9126);
    const YAMLMap = __webpack_require__(8741);
    const YAMLSeq = __webpack_require__(2016);
    const pairs = __webpack_require__(4710);

    class YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx) return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, '', ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, '', ctx);
          }
          if (map.has(key)) throw new Error('Ordered maps must not include duplicate keys');
          map.set(key, value);
        }
        return map;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs$1.items;
        return omap;
      }
    }
    YAMLOMap.tag = 'tag:yaml.org,2002:omap';
    const omap = {
      collection: 'seq',
      identify: value => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: 'tag:yaml.org,2002:omap',
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx),
    };

    exports.YAMLOMap = YAMLOMap;
    exports.omap = omap;

    /***/
  },

  /***/ 140: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Scalar = __webpack_require__(6364);

    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header) return { value: '', type: null, comment: '', range: [start, start, start] };
      const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      // determine the end of content & start of chomping
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r') chompStart = i;
        else break;
      }
      // shortcut for empty contents
      if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0 ? '\n'.repeat(Math.max(1, lines.length - 1)) : '';
        let end = start + header.length;
        if (scalar.source) end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
      }
      // find the indentation level to trim from start
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
          if (header.indent === 0 && indent.length > trimIndent) trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message =
              'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
            onError(offset + indent.length, 'MISSING_CHAR', message);
          }
          if (header.indent === 0) trimIndent = indent.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = 'Block scalar values in collections must be indented';
            onError(offset, 'BAD_INDENT', message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      // include trailing more-indented empty lines in content
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent) chompStart = i + 1;
      }
      let value = '';
      let sep = '';
      let prevMoreIndented = false;
      // leading whitespace is kept intact
      for (let i = 0; i < contentStart; ++i) value += lines[i][0].slice(trimIndent) + '\n';
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf) content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
          const src = header.indent ? 'explicit indentation indicator' : 'first line';
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
          indent = '';
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent.slice(trimIndent) + content;
          sep = '\n';
        } else if (indent.length > trimIndent || content[0] === '\t') {
          // more-indented content within a folded block
          if (sep === ' ') sep = '\n';
          else if (!prevMoreIndented && sep === '\n') sep = '\n\n';
          value += sep + indent.slice(trimIndent) + content;
          sep = '\n';
          prevMoreIndented = true;
        } else if (content === '') {
          // empty line
          if (sep === '\n') value += '\n';
          else sep = '\n';
        } else {
          value += sep + content;
          sep = ' ';
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case '-':
          break;
        case '+':
          for (let i = chompStart; i < lines.length; ++i) value += '\n' + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== '\n') value += '\n';
          break;
        default:
          value += '\n';
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      /* istanbul ignore if should not happen */
      if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = '';
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+')) chomp = ch;
        else {
          const n = Number(ch);
          if (!indent && n) indent = n;
          else if (error === -1) error = offset + i;
        }
      }
      if (error !== -1) onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = '';
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case 'space':
            hasSpace = true;
          // fallthrough
          case 'newline':
            length += token.source.length;
            break;
          case 'comment':
            if (strict && !hasSpace) {
              const message = 'Comments must be separated from other tokens by white space characters';
              onError(token, 'MISSING_CHAR', message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case 'error':
            onError(token, 'UNEXPECTED_TOKEN', token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            const ts = token.source;
            if (ts && typeof ts === 'string') length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    /** @returns Array of lines split up as `[indent, content]` */
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ['', first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2) lines.push([split[i], split[i + 1]]);
      return lines;
    }

    exports.resolveBlockScalar = resolveBlockScalar;

    /***/
  },

  /***/ 146: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const EventEmitter = __webpack_require__(8474).EventEmitter;
    const childProcess = __webpack_require__(1421);
    const path = __webpack_require__(6760);
    const fs = __webpack_require__(3024);
    const process = __webpack_require__(1708);

    const { Argument, humanReadableArgName } = __webpack_require__(1292);
    const { CommanderError } = __webpack_require__(6729);
    const { Help, stripColor } = __webpack_require__(9736);
    const { Option, DualOptions } = __webpack_require__(1490);
    const { suggestSimilar } = __webpack_require__(7732);

    class Command extends EventEmitter {
      /**
       * Initialize a new `Command`.
       *
       * @param {string} [name]
       */

      constructor(name) {
        super();
        /** @type {Command[]} */
        this.commands = [];
        /** @type {Option[]} */
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = false;
        /** @type {Argument[]} */
        this.registeredArguments = [];
        this._args = this.registeredArguments; // deprecated old name
        /** @type {string[]} */
        this.args = []; // cli args with options removed
        this.rawArgs = [];
        this.processedArgs = []; // like .args but after custom processing and collecting variadic
        this._scriptPath = null;
        this._name = name || '';
        this._optionValues = {};
        this._optionValueSources = {}; // default, env, cli etc
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null; // custom name for executable
        this._executableDir = null; // custom search directory for subcommands
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = '';
        this._summary = '';
        this._argsDescription = undefined; // legacy
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {}; // a hash of arrays
        /** @type {(boolean | string)} */
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = true;
        this._savedState = null; // used in save/restoreStateBeforeParse

        // see configureOutput() for docs
        this._outputConfiguration = {
          writeOut: str => process.stdout.write(str),
          writeErr: str => process.stderr.write(str),
          outputError: (str, write) => write(str),
          getOutHelpWidth: () => (process.stdout.isTTY ? process.stdout.columns : undefined),
          getErrHelpWidth: () => (process.stderr.isTTY ? process.stderr.columns : undefined),
          getOutHasColors: () => useColor() ?? (process.stdout.isTTY && process.stdout.hasColors?.()),
          getErrHasColors: () => useColor() ?? (process.stderr.isTTY && process.stderr.hasColors?.()),
          stripColor: str => stripColor(str),
        };

        this._hidden = false;
        /** @type {(Option | null | undefined)} */
        this._helpOption = undefined; // Lazy created on demand. May be null if help option is disabled.
        this._addImplicitHelpCommand = undefined; // undecided whether true or false yet, not inherited
        /** @type {Command} */
        this._helpCommand = undefined; // lazy initialised, inherited
        this._helpConfiguration = {};
      }

      /**
       * Copy settings that are useful to have in common across root command and subcommands.
       *
       * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
       *
       * @param {Command} sourceCommand
       * @return {Command} `this` command for chaining
       */
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._helpOption = sourceCommand._helpOption;
        this._helpCommand = sourceCommand._helpCommand;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

        return this;
      }

      /**
       * @returns {Command[]}
       * @private
       */

      _getCommandAndAncestors() {
        const result = [];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        for (let command = this; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }

      /**
       * Define a command.
       *
       * There are two styles of command: pay attention to where to put the description.
       *
       * @example
       * // Command implemented using action handler (description is supplied separately to `.command`)
       * program
       *   .command('clone <source> [destination]')
       *   .description('clone a repository into a newly created directory')
       *   .action((source, destination) => {
       *     console.log('clone command called');
       *   });
       *
       * // Command implemented using separate executable file (description is second parameter to `.command`)
       * program
       *   .command('start <service>', 'start named service')
       *   .command('stop [service]', 'stop named service, or all if no name supplied');
       *
       * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
       * @param {(object | string)} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
       * @param {object} [execOpts] - configuration options (for executable)
       * @return {Command} returns new command for action handler, or `this` for executable command
       */

      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === 'object' && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
        cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
        if (args) cmd.arguments(args);
        this._registerCommand(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);

        if (desc) return this;
        return cmd;
      }

      /**
       * Factory routine to create a new unattached command.
       *
       * See .command() for creating an attached subcommand, which uses this routine to
       * create the command. You can override createCommand to customise subcommands.
       *
       * @param {string} [name]
       * @return {Command} new command
       */

      createCommand(name) {
        return new Command(name);
      }

      /**
       * You can customise the help with a subclass of Help by overriding createHelp,
       * or by overriding Help properties using configureHelp().
       *
       * @return {Help}
       */

      createHelp() {
        return Object.assign(new Help(), this.configureHelp());
      }

      /**
       * You can customise the help by overriding Help properties using configureHelp(),
       * or with a subclass of Help by overriding createHelp().
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */

      configureHelp(configuration) {
        if (configuration === undefined) return this._helpConfiguration;

        this._helpConfiguration = configuration;
        return this;
      }

      /**
       * The default output goes to stdout and stderr. You can customise this for special
       * applications. You can also customise the display of errors by overriding outputError.
       *
       * The configuration properties are all functions:
       *
       *     // change how output being written, defaults to stdout and stderr
       *     writeOut(str)
       *     writeErr(str)
       *     // change how output being written for errors, defaults to writeErr
       *     outputError(str, write) // used for displaying errors and not used for displaying help
       *     // specify width for wrapping help
       *     getOutHelpWidth()
       *     getErrHelpWidth()
       *     // color support, currently only used with Help
       *     getOutHasColors()
       *     getErrHasColors()
       *     stripColor() // used to remove ANSI escape codes if output does not have colors
       *
       * @param {object} [configuration] - configuration options
       * @return {(Command | object)} `this` command for chaining, or stored configuration
       */

      configureOutput(configuration) {
        if (configuration === undefined) return this._outputConfiguration;

        Object.assign(this._outputConfiguration, configuration);
        return this;
      }

      /**
       * Display the help or a custom message after an error occurs.
       *
       * @param {(boolean|string)} [displayHelp]
       * @return {Command} `this` command for chaining
       */
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }

      /**
       * Display suggestion of similar commands for unknown commands, or options for unknown options.
       *
       * @param {boolean} [displaySuggestion]
       * @return {Command} `this` command for chaining
       */
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }

      /**
       * Add a prepared subcommand.
       *
       * See .command() for creating an attached subcommand which inherits settings from its parent.
       *
       * @param {Command} cmd - new subcommand
       * @param {object} [opts] - configuration options
       * @return {Command} `this` command for chaining
       */

      addCommand(cmd, opts) {
        if (!cmd._name) {
          throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
        }

        opts = opts || {};
        if (opts.isDefault) this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

        this._registerCommand(cmd);
        cmd.parent = this;
        cmd._checkForBrokenPassThrough();

        return this;
      }

      /**
       * Factory routine to create a new unattached argument.
       *
       * See .argument() for creating an attached argument, which uses this routine to
       * create the argument. You can override createArgument to return a custom argument.
       *
       * @param {string} name
       * @param {string} [description]
       * @return {Argument} new argument
       */

      createArgument(name, description) {
        return new Argument(name, description);
      }

      /**
       * Define argument syntax for command.
       *
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @example
       * program.argument('<input-file>');
       * program.argument('[output-file]');
       *
       * @param {string} name
       * @param {string} [description]
       * @param {(Function|*)} [fn] - custom argument processing function
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === 'function') {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }

      /**
       * Define argument syntax for command, adding multiple at once (without descriptions).
       *
       * See also .argument().
       *
       * @example
       * program.arguments('<cmd> [env]');
       *
       * @param {string} names
       * @return {Command} `this` command for chaining
       */

      arguments(names) {
        names
          .trim()
          .split(/ +/)
          .forEach(detail => {
            this.argument(detail);
          });
        return this;
      }

      /**
       * Define argument syntax for command, adding a prepared argument.
       *
       * @param {Argument} argument
       * @return {Command} `this` command for chaining
       */
      addArgument(argument) {
        const previousArgument = this.registeredArguments.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this.registeredArguments.push(argument);
        return this;
      }

      /**
       * Customise or override default help command. By default a help command is automatically added if your command has subcommands.
       *
       * @example
       *    program.helpCommand('help [cmd]');
       *    program.helpCommand('help [cmd]', 'show help');
       *    program.helpCommand(false); // suppress default help command
       *    program.helpCommand(true); // add help command even if no subcommands
       *
       * @param {string|boolean} enableOrNameAndArgs - enable with custom name and/or arguments, or boolean to override whether added
       * @param {string} [description] - custom description
       * @return {Command} `this` command for chaining
       */

      helpCommand(enableOrNameAndArgs, description) {
        if (typeof enableOrNameAndArgs === 'boolean') {
          this._addImplicitHelpCommand = enableOrNameAndArgs;
          return this;
        }

        enableOrNameAndArgs = enableOrNameAndArgs ?? 'help [command]';
        const [, helpName, helpArgs] = enableOrNameAndArgs.match(/([^ ]+) *(.*)/);
        const helpDescription = description ?? 'display help for command';

        const helpCommand = this.createCommand(helpName);
        helpCommand.helpOption(false);
        if (helpArgs) helpCommand.arguments(helpArgs);
        if (helpDescription) helpCommand.description(helpDescription);

        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;

        return this;
      }

      /**
       * Add prepared custom help command.
       *
       * @param {(Command|string|boolean)} helpCommand - custom help command, or deprecated enableOrNameAndArgs as for `.helpCommand()`
       * @param {string} [deprecatedDescription] - deprecated custom description used with custom name only
       * @return {Command} `this` command for chaining
       */
      addHelpCommand(helpCommand, deprecatedDescription) {
        // If not passed an object, call through to helpCommand for backwards compatibility,
        // as addHelpCommand was originally used like helpCommand is now.
        if (typeof helpCommand !== 'object') {
          this.helpCommand(helpCommand, deprecatedDescription);
          return this;
        }

        this._addImplicitHelpCommand = true;
        this._helpCommand = helpCommand;
        return this;
      }

      /**
       * Lazy create help command.
       *
       * @return {(Command|null)}
       * @package
       */
      _getHelpCommand() {
        const hasImplicitHelpCommand =
          this._addImplicitHelpCommand ?? (this.commands.length && !this._actionHandler && !this._findCommand('help'));

        if (hasImplicitHelpCommand) {
          if (this._helpCommand === undefined) {
            this.helpCommand(undefined, undefined); // use default name and description
          }
          return this._helpCommand;
        }
        return null;
      }

      /**
       * Add hook for life cycle event.
       *
       * @param {string} event
       * @param {Function} listener
       * @return {Command} `this` command for chaining
       */

      hook(event, listener) {
        const allowedValues = ['preSubcommand', 'preAction', 'postAction'];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }

      /**
       * Register callback to use as replacement for calling process.exit.
       *
       * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
       * @return {Command} `this` command for chaining
       */

      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = err => {
            if (err.code !== 'commander.executeSubCommandAsync') {
              throw err;
            } else {
              // Async callback from spawn events, not useful to throw.
            }
          };
        }
        return this;
      }

      /**
       * Call process.exit, and _exitCallback if defined.
       *
       * @param {number} exitCode exit code for using with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       * @return never
       * @private
       */

      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError(exitCode, code, message));
          // Expecting this line is not reached.
        }
        process.exit(exitCode);
      }

      /**
       * Register callback `fn` for the command.
       *
       * @example
       * program
       *   .command('serve')
       *   .description('start service')
       *   .action(function() {
       *      // do work here
       *   });
       *
       * @param {Function} fn
       * @return {Command} `this` command for chaining
       */

      action(fn) {
        const listener = args => {
          // The .action callback takes an extra parameter which is the command or options.
          const expectedArgsCount = this.registeredArguments.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this; // backwards compatible "options"
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);

          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }

      /**
       * Factory routine to create a new unattached option.
       *
       * See .option() for creating an attached option, which uses this routine to
       * create the option. You can override createOption to return a custom option.
       *
       * @param {string} flags
       * @param {string} [description]
       * @return {Option} new option
       */

      createOption(flags, description) {
        return new Option(flags, description);
      }

      /**
       * Wrap parseArgs to catch 'commander.invalidArgument'.
       *
       * @param {(Option | Argument)} target
       * @param {string} value
       * @param {*} previous
       * @param {string} invalidArgumentMessage
       * @private
       */

      _callParseArg(target, value, previous, invalidArgumentMessage) {
        try {
          return target.parseArg(value, previous);
        } catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `${invalidArgumentMessage} ${err.message}`;
            this.error(message, { exitCode: err.exitCode, code: err.code });
          }
          throw err;
        }
      }

      /**
       * Check for option flag conflicts.
       * Register option if no conflicts found, or throw on conflict.
       *
       * @param {Option} option
       * @private
       */

      _registerOption(option) {
        const matchingOption =
          (option.short && this._findOption(option.short)) || (option.long && this._findOption(option.long));
        if (matchingOption) {
          const matchingFlag = option.long && this._findOption(option.long) ? option.long : option.short;
          throw new Error(`Cannot add option '${option.flags}'${this._name && ` to command '${this._name}'`} due to conflicting flag '${matchingFlag}'
-  already used by option '${matchingOption.flags}'`);
        }

        this.options.push(option);
      }

      /**
       * Check for command name and alias conflicts with existing commands.
       * Register command if no conflicts found, or throw on conflict.
       *
       * @param {Command} command
       * @private
       */

      _registerCommand(command) {
        const knownBy = cmd => {
          return [cmd.name()].concat(cmd.aliases());
        };

        const alreadyUsed = knownBy(command).find(name => this._findCommand(name));
        if (alreadyUsed) {
          const existingCmd = knownBy(this._findCommand(alreadyUsed)).join('|');
          const newCmd = knownBy(command).join('|');
          throw new Error(`cannot add command '${newCmd}' as already have command '${existingCmd}'`);
        }

        this.commands.push(command);
      }

      /**
       * Add an option.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addOption(option) {
        this._registerOption(option);

        const oname = option.name();
        const name = option.attributeName();

        // store default value
        if (option.negate) {
          // --no-foo is special and defaults foo to true, unless a --foo option is already defined
          const positiveLongFlag = option.long.replace(/^--no-/, '--');
          if (!this._findOption(positiveLongFlag)) {
            this.setOptionValueWithSource(
              name,
              option.defaultValue === undefined ? true : option.defaultValue,
              'default',
            );
          }
        } else if (option.defaultValue !== undefined) {
          this.setOptionValueWithSource(name, option.defaultValue, 'default');
        }

        // handler for cli and env supplied values
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          // val is null for optional option used without an optional-argument.
          // val is undefined for boolean and negated option.
          if (val == null && option.presetArg !== undefined) {
            val = option.presetArg;
          }

          // custom processing
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            val = this._callParseArg(option, val, oldValue, invalidValueMessage);
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }

          // Fill-in appropriate missing values. Long winded but easy to follow.
          if (val == null) {
            if (option.negate) {
              val = false;
            } else if (option.isBoolean() || option.optional) {
              val = true;
            } else {
              val = ''; // not normal, parseArg might have failed or be a mock function for testing
            }
          }
          this.setOptionValueWithSource(name, val, valueSource);
        };

        this.on('option:' + oname, val => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, 'cli');
        });

        if (option.envVar) {
          this.on('optionEnv:' + oname, val => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, 'env');
          });
        }

        return this;
      }

      /**
       * Internal implementation shared by .option() and .requiredOption()
       *
       * @return {Command} `this` command for chaining
       * @private
       */
      _optionEx(config, flags, description, fn, defaultValue) {
        if (typeof flags === 'object' && flags instanceof Option) {
          throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');
        }
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === 'function') {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          // deprecated
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }

        return this.addOption(option);
      }

      /**
       * Define option with `flags`, `description`, and optional argument parsing function or `defaultValue` or both.
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space. A required
       * option-argument is indicated by `<>` and an optional option-argument by `[]`.
       *
       * See the README for more details, and see also addOption() and requiredOption().
       *
       * @example
       * program
       *     .option('-p, --pepper', 'add pepper')
       *     .option('--pt, --pizza-type <TYPE>', 'type of pizza') // required option-argument
       *     .option('-c, --cheese [CHEESE]', 'add extra cheese', 'mozzarella') // optional option-argument with default
       *     .option('-t, --tip <VALUE>', 'add tip to purchase cost', parseFloat) // custom parse function
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */

      option(flags, description, parseArg, defaultValue) {
        return this._optionEx({}, flags, description, parseArg, defaultValue);
      }

      /**
       * Add a required option which must have a value after parsing. This usually means
       * the option must be specified on the command line. (Otherwise the same as .option().)
       *
       * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
       *
       * @param {string} flags
       * @param {string} [description]
       * @param {(Function|*)} [parseArg] - custom option processing function or default value
       * @param {*} [defaultValue]
       * @return {Command} `this` command for chaining
       */

      requiredOption(flags, description, parseArg, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, parseArg, defaultValue);
      }

      /**
       * Alter parsing of short flags with optional values.
       *
       * @example
       * // for `.option('-f,--flag [value]'):
       * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
       * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
       *
       * @param {boolean} [combine] - if `true` or omitted, an optional value can be specified directly after the flag.
       * @return {Command} `this` command for chaining
       */
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }

      /**
       * Allow unknown options on the command line.
       *
       * @param {boolean} [allowUnknown] - if `true` or omitted, no error will be thrown for unknown options.
       * @return {Command} `this` command for chaining
       */
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }

      /**
       * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
       *
       * @param {boolean} [allowExcess] - if `true` or omitted, no error will be thrown for excess arguments.
       * @return {Command} `this` command for chaining
       */
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }

      /**
       * Enable positional options. Positional means global options are specified before subcommands which lets
       * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
       * The default behaviour is non-positional and global options may appear anywhere on the command line.
       *
       * @param {boolean} [positional]
       * @return {Command} `this` command for chaining
       */
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }

      /**
       * Pass through options that come after command-arguments rather than treat them as command-options,
       * so actual command-options come before command-arguments. Turning this on for a subcommand requires
       * positional options to have been enabled on the program (parent commands).
       * The default behaviour is non-positional and options may appear before or after command-arguments.
       *
       * @param {boolean} [passThrough] for unknown options.
       * @return {Command} `this` command for chaining
       */
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        this._checkForBrokenPassThrough();
        return this;
      }

      /**
       * @private
       */

      _checkForBrokenPassThrough() {
        if (this.parent && this._passThroughOptions && !this.parent._enablePositionalOptions) {
          throw new Error(
            `passThroughOptions cannot be used for '${this._name}' without turning on enablePositionalOptions for parent command(s)`,
          );
        }
      }

      /**
       * Whether to store option values as properties on command object,
       * or store separately (specify false). In both cases the option values can be accessed using .opts().
       *
       * @param {boolean} [storeAsProperties=true]
       * @return {Command} `this` command for chaining
       */

      storeOptionsAsProperties(storeAsProperties = true) {
        if (this.options.length) {
          throw new Error('call .storeOptionsAsProperties() before adding options');
        }
        if (Object.keys(this._optionValues).length) {
          throw new Error('call .storeOptionsAsProperties() before setting option values');
        }
        this._storeOptionsAsProperties = !!storeAsProperties;
        return this;
      }

      /**
       * Retrieve option value.
       *
       * @param {string} key
       * @return {object} value
       */

      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }

      /**
       * Store option value.
       *
       * @param {string} key
       * @param {object} value
       * @return {Command} `this` command for chaining
       */

      setOptionValue(key, value) {
        return this.setOptionValueWithSource(key, value, undefined);
      }

      /**
       * Store option value and where the value came from.
       *
       * @param {string} key
       * @param {object} value
       * @param {string} source - expected values are default/config/env/cli/implied
       * @return {Command} `this` command for chaining
       */

      setOptionValueWithSource(key, value, source) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        this._optionValueSources[key] = source;
        return this;
      }

      /**
       * Get source of option value.
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */

      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }

      /**
       * Get source of option value. See also .optsWithGlobals().
       * Expected values are default | config | env | cli | implied
       *
       * @param {string} key
       * @return {string}
       */

      getOptionValueSourceWithGlobals(key) {
        // global overwrites local, like optsWithGlobals
        let source;
        this._getCommandAndAncestors().forEach(cmd => {
          if (cmd.getOptionValueSource(key) !== undefined) {
            source = cmd.getOptionValueSource(key);
          }
        });
        return source;
      }

      /**
       * Get user arguments from implied or explicit arguments.
       * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
       *
       * @private
       */

      _prepareUserArgs(argv, parseOptions) {
        if (argv !== undefined && !Array.isArray(argv)) {
          throw new Error('first parameter to parse must be array or undefined');
        }
        parseOptions = parseOptions || {};

        // auto-detect argument conventions if nothing supplied
        if (argv === undefined && parseOptions.from === undefined) {
          if (process.versions?.electron) {
            parseOptions.from = 'electron';
          }
          // check node specific options for scenarios where user CLI args follow executable without scriptname
          const execArgv = process.execArgv ?? [];
          if (
            execArgv.includes('-e') ||
            execArgv.includes('--eval') ||
            execArgv.includes('-p') ||
            execArgv.includes('--print')
          ) {
            parseOptions.from = 'eval'; // internal usage, not documented
          }
        }

        // default to using process.argv
        if (argv === undefined) {
          argv = process.argv;
        }
        this.rawArgs = argv.slice();

        // extract the user args and scriptPath
        let userArgs;
        switch (parseOptions.from) {
          case undefined:
          case 'node':
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case 'electron':
            // @ts-ignore: because defaultApp is an unknown property
            if (process.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case 'user':
            userArgs = argv.slice(0);
            break;
          case 'eval':
            userArgs = argv.slice(1);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }

        // Find default name for program from arguments.
        if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);
        this._name = this._name || 'program';

        return userArgs;
      }

      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Use parseAsync instead of parse if any of your action handlers are async.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * program.parse(); // parse process.argv and auto-detect electron and special node flags
       * program.parse(process.argv); // assume argv[0] is app and argv[1] is script
       * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv] - optional, defaults to process.argv
       * @param {object} [parseOptions] - optionally specify style of options with from: node/user/electron
       * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
       * @return {Command} `this` command for chaining
       */

      parse(argv, parseOptions) {
        this._prepareForParse();
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);

        return this;
      }

      /**
       * Parse `argv`, setting options and invoking commands when defined.
       *
       * Call with no parameters to parse `process.argv`. Detects Electron and special node options like `node --eval`. Easy mode!
       *
       * Or call with an array of strings to parse, and optionally where the user arguments start by specifying where the arguments are `from`:
       * - `'node'`: default, `argv[0]` is the application and `argv[1]` is the script being run, with user arguments after that
       * - `'electron'`: `argv[0]` is the application and `argv[1]` varies depending on whether the electron application is packaged
       * - `'user'`: just user arguments
       *
       * @example
       * await program.parseAsync(); // parse process.argv and auto-detect electron and special node flags
       * await program.parseAsync(process.argv); // assume argv[0] is app and argv[1] is script
       * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
       *
       * @param {string[]} [argv]
       * @param {object} [parseOptions]
       * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
       * @return {Promise}
       */

      async parseAsync(argv, parseOptions) {
        this._prepareForParse();
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        await this._parseCommand([], userArgs);

        return this;
      }

      _prepareForParse() {
        if (this._savedState === null) {
          this.saveStateBeforeParse();
        } else {
          this.restoreStateBeforeParse();
        }
      }

      /**
       * Called the first time parse is called to save state and allow a restore before subsequent calls to parse.
       * Not usually called directly, but available for subclasses to save their custom state.
       *
       * This is called in a lazy way. Only commands used in parsing chain will have state saved.
       */
      saveStateBeforeParse() {
        this._savedState = {
          // name is stable if supplied by author, but may be unspecified for root command and deduced during parsing
          _name: this._name,
          // option values before parse have default values (including false for negated options)
          // shallow clones
          _optionValues: { ...this._optionValues },
          _optionValueSources: { ...this._optionValueSources },
        };
      }

      /**
       * Restore state before parse for calls after the first.
       * Not usually called directly, but available for subclasses to save their custom state.
       *
       * This is called in a lazy way. Only commands used in parsing chain will have state restored.
       */
      restoreStateBeforeParse() {
        if (this._storeOptionsAsProperties)
          throw new Error(`Can not call parse again when storeOptionsAsProperties is true.
- either make a new Command for each call to parse, or stop storing options as properties`);

        // clear state from _prepareUserArgs
        this._name = this._savedState._name;
        this._scriptPath = null;
        this.rawArgs = [];
        // clear state from setOptionValueWithSource
        this._optionValues = { ...this._savedState._optionValues };
        this._optionValueSources = { ...this._savedState._optionValueSources };
        // clear state from _parseCommand
        this.args = [];
        // clear state from _processArguments
        this.processedArgs = [];
      }

      /**
       * Throw if expected executable is missing. Add lots of help for author.
       *
       * @param {string} executableFile
       * @param {string} executableDir
       * @param {string} subcommandName
       */
      _checkForMissingExecutable(executableFile, executableDir, subcommandName) {
        if (fs.existsSync(executableFile)) return;

        const executableDirMessage = executableDir
          ? `searched for local subcommand relative to directory '${executableDir}'`
          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';
        const executableMissing = `'${executableFile}' does not exist
 - if '${subcommandName}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
        throw new Error(executableMissing);
      }

      /**
       * Execute a sub-command executable.
       *
       * @private
       */

      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
        const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

        function findFile(baseDir, baseName) {
          // Look for specified file
          const localBin = path.resolve(baseDir, baseName);
          if (fs.existsSync(localBin)) return localBin;

          // Stop looking if candidate already has an expected extension.
          if (sourceExt.includes(path.extname(baseName))) return undefined;

          // Try all the extensions.
          const foundExt = sourceExt.find(ext => fs.existsSync(`${localBin}${ext}`));
          if (foundExt) return `${localBin}${foundExt}`;

          return undefined;
        }

        // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();

        // executableFile and executableDir might be full path, or just a name
        let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
        let executableDir = this._executableDir || '';
        if (this._scriptPath) {
          let resolvedScriptPath; // resolve possible symlink for installed npm binary
          try {
            resolvedScriptPath = fs.realpathSync(this._scriptPath);
          } catch {
            resolvedScriptPath = this._scriptPath;
          }
          executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);
        }

        // Look for a local file in preference to a command in PATH.
        if (executableDir) {
          let localFile = findFile(executableDir, executableFile);

          // Legacy search using prefix of script name instead of command name
          if (!localFile && !subcommand._executableFile && this._scriptPath) {
            const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));
            if (legacyName !== this._name) {
              localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
            }
          }
          executableFile = localFile || executableFile;
        }

        launchWithNode = sourceExt.includes(path.extname(executableFile));

        let proc;
        if (process.platform !== 'win32') {
          if (launchWithNode) {
            args.unshift(executableFile);
            // add executable arguments to spawn
            args = incrementNodeInspectorPort(process.execArgv).concat(args);

            proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });
          } else {
            proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });
          }
        } else {
          this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
          args.unshift(executableFile);
          // add executable arguments to spawn
          args = incrementNodeInspectorPort(process.execArgv).concat(args);
          proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });
        }

        if (!proc.killed) {
          // testing mainly to avoid leak warnings during unit tests with mocked spawn
          const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
          signals.forEach(signal => {
            process.on(signal, () => {
              if (proc.killed === false && proc.exitCode === null) {
                // @ts-ignore because signals not typed to known strings
                proc.kill(signal);
              }
            });
          });
        }

        // By default terminate process when spawned process terminates.
        const exitCallback = this._exitCallback;
        proc.on('close', code => {
          code = code ?? 1; // code is null if spawned process terminated due to a signal
          if (!exitCallback) {
            process.exit(code);
          } else {
            exitCallback(new CommanderError(code, 'commander.executeSubCommandAsync', '(close)'));
          }
        });
        proc.on('error', err => {
          // @ts-ignore: because err.code is an unknown property
          if (err.code === 'ENOENT') {
            this._checkForMissingExecutable(executableFile, executableDir, subcommand._name);
            // @ts-ignore: because err.code is an unknown property
          } else if (err.code === 'EACCES') {
            throw new Error(`'${executableFile}' not executable`);
          }
          if (!exitCallback) {
            process.exit(1);
          } else {
            const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });

        // Store the reference to the child process
        this.runningCommand = proc;
      }

      /**
       * @private
       */

      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand) this.help({ error: true });

        subCommand._prepareForParse();
        let promiseChain;
        promiseChain = this._chainOrCallSubCommandHook(promiseChain, subCommand, 'preSubcommand');
        promiseChain = this._chainOrCall(promiseChain, () => {
          if (subCommand._executableHandler) {
            this._executeSubCommand(subCommand, operands.concat(unknown));
          } else {
            return subCommand._parseCommand(operands, unknown);
          }
        });
        return promiseChain;
      }

      /**
       * Invoke help directly if possible, or dispatch if necessary.
       * e.g. help foo
       *
       * @private
       */

      _dispatchHelpCommand(subcommandName) {
        if (!subcommandName) {
          this.help();
        }
        const subCommand = this._findCommand(subcommandName);
        if (subCommand && !subCommand._executableHandler) {
          subCommand.help();
        }

        // Fallback to parsing the help flag to invoke the help.
        return this._dispatchSubcommand(
          subcommandName,
          [],
          [this._getHelpOption()?.long ?? this._getHelpOption()?.short ?? '--help'],
        );
      }

      /**
       * Check this.args against expected this.registeredArguments.
       *
       * @private
       */

      _checkNumberOfArguments() {
        // too few
        this.registeredArguments.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        // too many
        if (
          this.registeredArguments.length > 0 &&
          this.registeredArguments[this.registeredArguments.length - 1].variadic
        ) {
          return;
        }
        if (this.args.length > this.registeredArguments.length) {
          this._excessArguments(this.args);
        }
      }

      /**
       * Process this.args using this.registeredArguments and save as this.processedArgs!
       *
       * @private
       */

      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          // Extra processing for nice error message on parsing failure.
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            const invalidValueMessage = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'.`;
            parsedValue = this._callParseArg(argument, value, previous, invalidValueMessage);
          }
          return parsedValue;
        };

        this._checkNumberOfArguments();

        const processedArgs = [];
        this.registeredArguments.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            // Collect together remaining arguments for passing together as an array.
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === undefined) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }

      /**
       * Once we have a promise we chain, but call synchronously until then.
       *
       * @param {(Promise|undefined)} promise
       * @param {Function} fn
       * @return {(Promise|undefined)}
       * @private
       */

      _chainOrCall(promise, fn) {
        // thenable
        if (promise && promise.then && typeof promise.then === 'function') {
          // already have a promise, chain callback
          return promise.then(() => fn());
        }
        // callback might return a promise
        return fn();
      }

      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */

      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        this._getCommandAndAncestors()
          .reverse()
          .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)
          .forEach(hookedCommand => {
            hookedCommand._lifeCycleHooks[event].forEach(callback => {
              hooks.push({ hookedCommand, callback });
            });
          });
        if (event === 'postAction') {
          hooks.reverse();
        }

        hooks.forEach(hookDetail => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }

      /**
       *
       * @param {(Promise|undefined)} promise
       * @param {Command} subCommand
       * @param {string} event
       * @return {(Promise|undefined)}
       * @private
       */

      _chainOrCallSubCommandHook(promise, subCommand, event) {
        let result = promise;
        if (this._lifeCycleHooks[event] !== undefined) {
          this._lifeCycleHooks[event].forEach(hook => {
            result = this._chainOrCall(result, () => {
              return hook(this, subCommand);
            });
          });
        }
        return result;
      }

      /**
       * Process arguments in context of this command.
       * Returns action result, in case it is a promise.
       *
       * @private
       */

      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
        this._parseOptionsImplied();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);

        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._getHelpCommand() && operands[0] === this._getHelpCommand().name()) {
          return this._dispatchHelpCommand(operands[1]);
        }
        if (this._defaultCommandName) {
          this._outputHelpIfRequested(unknown); // Run the help for default command from parent rather than passing to default command
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          // probably missing subcommand and no handler, user needs help (and exit)
          this.help({ error: true });
        }

        this._outputHelpIfRequested(parsed.unknown);
        this._checkForMissingMandatoryOptions();
        this._checkForConflictingOptions();

        // We do not always call this check to avoid masking a "better" error, like unknown command.
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };

        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();

          let promiseChain;
          promiseChain = this._chainOrCallHooks(promiseChain, 'preAction');
          promiseChain = this._chainOrCall(promiseChain, () => this._actionHandler(this.processedArgs));
          if (this.parent) {
            promiseChain = this._chainOrCall(promiseChain, () => {
              this.parent.emit(commandEvent, operands, unknown); // legacy
            });
          }
          promiseChain = this._chainOrCallHooks(promiseChain, 'postAction');
          return promiseChain;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown); // legacy
        } else if (operands.length) {
          if (this._findCommand('*')) {
            // legacy default command
            return this._dispatchSubcommand('*', operands, unknown);
          }
          if (this.listenerCount('command:*')) {
            // skip option check, emit event for possible misspelling suggestion
            this.emit('command:*', operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          // This command has subcommands and nothing hooked up at this level, so display help (and exit).
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
          // fall through for caller to handle after calling .parse()
        }
      }

      /**
       * Find matching command.
       *
       * @private
       * @return {Command | undefined}
       */
      _findCommand(name) {
        if (!name) return undefined;
        return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
      }

      /**
       * Return an option matching `arg` if any.
       *
       * @param {string} arg
       * @return {Option}
       * @package
       */

      _findOption(arg) {
        return this.options.find(option => option.is(arg));
      }

      /**
       * Display an error message if a mandatory option does not have a value.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */

      _checkForMissingMandatoryOptions() {
        // Walk up hierarchy so can call in subcommand after checking for displaying help.
        this._getCommandAndAncestors().forEach(cmd => {
          cmd.options.forEach(anOption => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === undefined) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        });
      }

      /**
       * Display an error message if conflicting options are used together in this.
       *
       * @private
       */
      _checkForConflictingLocalOptions() {
        const definedNonDefaultOptions = this.options.filter(option => {
          const optionKey = option.attributeName();
          if (this.getOptionValue(optionKey) === undefined) {
            return false;
          }
          return this.getOptionValueSource(optionKey) !== 'default';
        });

        const optionsWithConflicting = definedNonDefaultOptions.filter(option => option.conflictsWith.length > 0);

        optionsWithConflicting.forEach(option => {
          const conflictingAndDefined = definedNonDefaultOptions.find(defined =>
            option.conflictsWith.includes(defined.attributeName()),
          );
          if (conflictingAndDefined) {
            this._conflictingOption(option, conflictingAndDefined);
          }
        });
      }

      /**
       * Display an error message if conflicting options are used together.
       * Called after checking for help flags in leaf subcommand.
       *
       * @private
       */
      _checkForConflictingOptions() {
        // Walk up hierarchy so can call in subcommand after checking for displaying help.
        this._getCommandAndAncestors().forEach(cmd => {
          cmd._checkForConflictingLocalOptions();
        });
      }

      /**
       * Parse options from `argv` removing known options,
       * and return argv split into operands and unknown arguments.
       *
       * Side effects: modifies command by storing options. Does not reset state if called again.
       *
       * Examples:
       *
       *     argv => operands, unknown
       *     --known kkk op => [op], []
       *     op --known kkk => [op], []
       *     sub --unknown uuu op => [sub], [--unknown uuu op]
       *     sub -- --unknown uuu op => [sub --unknown uuu op], []
       *
       * @param {string[]} argv
       * @return {{operands: string[], unknown: string[]}}
       */

      parseOptions(argv) {
        const operands = []; // operands, not options or values
        const unknown = []; // first unknown option and remaining unknown args
        let dest = operands;
        const args = argv.slice();

        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === '-';
        }

        // parse options
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();

          // literal
          if (arg === '--') {
            if (dest === unknown) dest.push(arg);
            dest.push(...args);
            break;
          }

          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;

          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            // recognised option, call listener to assign value with possible custom processing
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === undefined) this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                // historical behaviour is optional value is following arg unless an option
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                // boolean flag
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }

          // Look for combo options following single dash, eat first one if known.
          if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {
                // option with value following in same argument
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                // boolean option, emit and put back remainder of arg for further processing
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }

          // Look for known long flag with value, like --foo=bar
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf('=');
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }

          // Not a recognised option by this command.
          // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

          // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
          if (maybeOption(arg)) {
            dest = unknown;
          }

          // If using positionalOptions, stop processing our options at subcommand.
          if (
            (this._enablePositionalOptions || this._passThroughOptions) &&
            operands.length === 0 &&
            unknown.length === 0
          ) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            } else if (this._getHelpCommand() && arg === this._getHelpCommand().name()) {
              operands.push(arg);
              if (args.length > 0) operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0) unknown.push(...args);
              break;
            }
          }

          // If using passThroughOptions, stop processing options at first command-argument.
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0) dest.push(...args);
            break;
          }

          // add arg
          dest.push(arg);
        }

        return { operands, unknown };
      }

      /**
       * Return an object containing local option values as key-value pairs.
       *
       * @return {object}
       */
      opts() {
        if (this._storeOptionsAsProperties) {
          // Preserve original behaviour so backwards compatible when still using properties
          const result = {};
          const len = this.options.length;

          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }

        return this._optionValues;
      }

      /**
       * Return an object containing merged local and global option values as key-value pairs.
       *
       * @return {object}
       */
      optsWithGlobals() {
        // globals overwrite locals
        return this._getCommandAndAncestors().reduce(
          (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
          {},
        );
      }

      /**
       * Display error message and exit (or call exitOverride).
       *
       * @param {string} message
       * @param {object} [errorOptions]
       * @param {string} [errorOptions.code] - an id string representing the error
       * @param {number} [errorOptions.exitCode] - used with process.exit
       */
      error(message, errorOptions) {
        // output handling
        this._outputConfiguration.outputError(`${message}\n`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === 'string') {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}\n`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr('\n');
          this.outputHelp({ error: true });
        }

        // exit handling
        const config = errorOptions || {};
        const exitCode = config.exitCode || 1;
        const code = config.code || 'commander.error';
        this._exit(exitCode, code, message);
      }

      /**
       * Apply any option related environment variables, if option does
       * not have a value from cli or client code.
       *
       * @private
       */
      _parseOptionsEnv() {
        this.options.forEach(option => {
          if (option.envVar && option.envVar in process.env) {
            const optionKey = option.attributeName();
            // Priority check. Do not overwrite cli or options from unknown source (client-code).
            if (
              this.getOptionValue(optionKey) === undefined ||
              ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))
            ) {
              if (option.required || option.optional) {
                // option can take a value
                // keep very simple, optional always takes value
                this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
              } else {
                // boolean
                // keep very simple, only care that envVar defined and not the value
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }

      /**
       * Apply any implied option values, if option is undefined or default value.
       *
       * @private
       */
      _parseOptionsImplied() {
        const dualHelper = new DualOptions(this.options);
        const hasCustomOptionValue = optionKey => {
          return (
            this.getOptionValue(optionKey) !== undefined &&
            !['default', 'implied'].includes(this.getOptionValueSource(optionKey))
          );
        };
        this.options
          .filter(
            option =>
              option.implied !== undefined &&
              hasCustomOptionValue(option.attributeName()) &&
              dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option),
          )
          .forEach(option => {
            Object.keys(option.implied)
              .filter(impliedKey => !hasCustomOptionValue(impliedKey))
              .forEach(impliedKey => {
                this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');
              });
          });
      }

      /**
       * Argument `name` is missing.
       *
       * @param {string} name
       * @private
       */

      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this.error(message, { code: 'commander.missingArgument' });
      }

      /**
       * `Option` is missing an argument.
       *
       * @param {Option} option
       * @private
       */

      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this.error(message, { code: 'commander.optionMissingArgument' });
      }

      /**
       * `Option` does not have a value, and is a mandatory option.
       *
       * @param {Option} option
       * @private
       */

      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this.error(message, { code: 'commander.missingMandatoryOptionValue' });
      }

      /**
       * `Option` conflicts with another option.
       *
       * @param {Option} option
       * @param {Option} conflictingOption
       * @private
       */
      _conflictingOption(option, conflictingOption) {
        // The calling code does not know whether a negated option is the source of the
        // value, so do some work to take an educated guess.
        const findBestOptionFromValue = option => {
          const optionKey = option.attributeName();
          const optionValue = this.getOptionValue(optionKey);
          const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());
          const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());
          if (
            negativeOption &&
            ((negativeOption.presetArg === undefined && optionValue === false) ||
              (negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg))
          ) {
            return negativeOption;
          }
          return positiveOption || option;
        };

        const getErrorMessage = option => {
          const bestOption = findBestOptionFromValue(option);
          const optionKey = bestOption.attributeName();
          const source = this.getOptionValueSource(optionKey);
          if (source === 'env') {
            return `environment variable '${bestOption.envVar}'`;
          }
          return `option '${bestOption.flags}'`;
        };

        const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
        this.error(message, { code: 'commander.conflictingOption' });
      }

      /**
       * Unknown option `flag`.
       *
       * @param {string} flag
       * @private
       */

      unknownOption(flag) {
        if (this._allowUnknownOption) return;
        let suggestion = '';

        if (flag.startsWith('--') && this._showSuggestionAfterError) {
          // Looping to pick up the global options too
          let candidateFlags = [];
          // eslint-disable-next-line @typescript-eslint/no-this-alias
          let command = this;
          do {
            const moreFlags = command
              .createHelp()
              .visibleOptions(command)
              .filter(option => option.long)
              .map(option => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }

        const message = `error: unknown option '${flag}'${suggestion}`;
        this.error(message, { code: 'commander.unknownOption' });
      }

      /**
       * Excess arguments, more than expected.
       *
       * @param {string[]} receivedArgs
       * @private
       */

      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments) return;

        const expected = this.registeredArguments.length;
        const s = expected === 1 ? '' : 's';
        const forSubcommand = this.parent ? ` for '${this.name()}'` : '';
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this.error(message, { code: 'commander.excessArguments' });
      }

      /**
       * Unknown command.
       *
       * @private
       */

      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = '';

        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp()
            .visibleCommands(this)
            .forEach(command => {
              candidateNames.push(command.name());
              // just visible alias
              if (command.alias()) candidateNames.push(command.alias());
            });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }

        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this.error(message, { code: 'commander.unknownCommand' });
      }

      /**
       * Get or set the program version.
       *
       * This method auto-registers the "-V, --version" option which will print the version number.
       *
       * You can optionally supply the flags and description to override the defaults.
       *
       * @param {string} [str]
       * @param {string} [flags]
       * @param {string} [description]
       * @return {(this | string | undefined)} `this` command for chaining, or version string if no arguments
       */

      version(str, flags, description) {
        if (str === undefined) return this._version;
        this._version = str;
        flags = flags || '-V, --version';
        description = description || 'output the version number';
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this._registerOption(versionOption);

        this.on('option:' + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}\n`);
          this._exit(0, 'commander.version', str);
        });
        return this;
      }

      /**
       * Set the description.
       *
       * @param {string} [str]
       * @param {object} [argsDescription]
       * @return {(string|Command)}
       */
      description(str, argsDescription) {
        if (str === undefined && argsDescription === undefined) return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }

      /**
       * Set the summary. Used when listed as subcommand of parent.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */
      summary(str) {
        if (str === undefined) return this._summary;
        this._summary = str;
        return this;
      }

      /**
       * Set an alias for the command.
       *
       * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
       *
       * @param {string} [alias]
       * @return {(string|Command)}
       */

      alias(alias) {
        if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

        /** @type {Command} */
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          // assume adding alias for last added executable subcommand, rather than this
          command = this.commands[this.commands.length - 1];
        }

        if (alias === command._name) throw new Error("Command alias can't be the same as its name");
        const matchingCommand = this.parent?._findCommand(alias);
        if (matchingCommand) {
          // c.f. _registerCommand
          const existingCmd = [matchingCommand.name()].concat(matchingCommand.aliases()).join('|');
          throw new Error(
            `cannot add alias '${alias}' to command '${this.name()}' as already have command '${existingCmd}'`,
          );
        }

        command._aliases.push(alias);
        return this;
      }

      /**
       * Set aliases for the command.
       *
       * Only the first alias is shown in the auto-generated help.
       *
       * @param {string[]} [aliases]
       * @return {(string[]|Command)}
       */

      aliases(aliases) {
        // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
        if (aliases === undefined) return this._aliases;

        aliases.forEach(alias => this.alias(alias));
        return this;
      }

      /**
       * Set / get the command usage `str`.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */

      usage(str) {
        if (str === undefined) {
          if (this._usage) return this._usage;

          const args = this.registeredArguments.map(arg => {
            return humanReadableArgName(arg);
          });
          return []
            .concat(
              this.options.length || this._helpOption !== null ? '[options]' : [],
              this.commands.length ? '[command]' : [],
              this.registeredArguments.length ? args : [],
            )
            .join(' ');
        }

        this._usage = str;
        return this;
      }

      /**
       * Get or set the name of the command.
       *
       * @param {string} [str]
       * @return {(string|Command)}
       */

      name(str) {
        if (str === undefined) return this._name;
        this._name = str;
        return this;
      }

      /**
       * Set the name of the command from script filename, such as process.argv[1],
       * or require.main.filename, or __filename.
       *
       * (Used internally and public although not documented in README.)
       *
       * @example
       * program.nameFromFilename(require.main.filename);
       *
       * @param {string} filename
       * @return {Command}
       */

      nameFromFilename(filename) {
        this._name = path.basename(filename, path.extname(filename));

        return this;
      }

      /**
       * Get or set the directory for searching for executable subcommands of this command.
       *
       * @example
       * program.executableDir(__dirname);
       * // or
       * program.executableDir('subcommands');
       *
       * @param {string} [path]
       * @return {(string|null|Command)}
       */

      executableDir(path) {
        if (path === undefined) return this._executableDir;
        this._executableDir = path;
        return this;
      }

      /**
       * Return program help documentation.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
       * @return {string}
       */

      helpInformation(contextOptions) {
        const helper = this.createHelp();
        const context = this._getOutputContext(contextOptions);
        helper.prepareContext({
          error: context.error,
          helpWidth: context.helpWidth,
          outputHasColors: context.hasColors,
        });
        const text = helper.formatHelp(this, helper);
        if (context.hasColors) return text;
        return this._outputConfiguration.stripColor(text);
      }

      /**
       * @typedef HelpContext
       * @type {object}
       * @property {boolean} error
       * @property {number} helpWidth
       * @property {boolean} hasColors
       * @property {function} write - includes stripColor if needed
       *
       * @returns {HelpContext}
       * @private
       */

      _getOutputContext(contextOptions) {
        contextOptions = contextOptions || {};
        const error = !!contextOptions.error;
        let baseWrite;
        let hasColors;
        let helpWidth;
        if (error) {
          baseWrite = str => this._outputConfiguration.writeErr(str);
          hasColors = this._outputConfiguration.getErrHasColors();
          helpWidth = this._outputConfiguration.getErrHelpWidth();
        } else {
          baseWrite = str => this._outputConfiguration.writeOut(str);
          hasColors = this._outputConfiguration.getOutHasColors();
          helpWidth = this._outputConfiguration.getOutHelpWidth();
        }
        const write = str => {
          if (!hasColors) str = this._outputConfiguration.stripColor(str);
          return baseWrite(str);
        };
        return { error, write, hasColors, helpWidth };
      }

      /**
       * Output help information for this command.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */

      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === 'function') {
          deprecatedCallback = contextOptions;
          contextOptions = undefined;
        }

        const outputContext = this._getOutputContext(contextOptions);
        /** @type {HelpTextEventContext} */
        const eventContext = {
          error: outputContext.error,
          write: outputContext.write,
          command: this,
        };

        this._getCommandAndAncestors()
          .reverse()
          .forEach(command => command.emit('beforeAllHelp', eventContext));
        this.emit('beforeHelp', eventContext);

        let helpInformation = this.helpInformation({ error: outputContext.error });
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
            throw new Error('outputHelp callback must return a string or a Buffer');
          }
        }
        outputContext.write(helpInformation);

        if (this._getHelpOption()?.long) {
          this.emit(this._getHelpOption().long); // deprecated
        }
        this.emit('afterHelp', eventContext);
        this._getCommandAndAncestors().forEach(command => command.emit('afterAllHelp', eventContext));
      }

      /**
       * You can pass in flags and a description to customise the built-in help option.
       * Pass in false to disable the built-in help option.
       *
       * @example
       * program.helpOption('-?, --help' 'show help'); // customise
       * program.helpOption(false); // disable
       *
       * @param {(string | boolean)} flags
       * @param {string} [description]
       * @return {Command} `this` command for chaining
       */

      helpOption(flags, description) {
        // Support disabling built-in help option.
        if (typeof flags === 'boolean') {
          // true is not an expected value. Do something sensible but no unit-test.
          // istanbul ignore if
          if (flags) {
            this._helpOption = this._helpOption ?? undefined; // preserve existing option
          } else {
            this._helpOption = null; // disable
          }
          return this;
        }

        // Customise flags and description.
        flags = flags ?? '-h, --help';
        description = description ?? 'display help for command';
        this._helpOption = this.createOption(flags, description);

        return this;
      }

      /**
       * Lazy create help option.
       * Returns null if has been disabled with .helpOption(false).
       *
       * @returns {(Option | null)} the help option
       * @package
       */
      _getHelpOption() {
        // Lazy create help option on demand.
        if (this._helpOption === undefined) {
          this.helpOption(undefined, undefined);
        }
        return this._helpOption;
      }

      /**
       * Supply your own option to use for the built-in help option.
       * This is an alternative to using helpOption() to customise the flags and description etc.
       *
       * @param {Option} option
       * @return {Command} `this` command for chaining
       */
      addHelpOption(option) {
        this._helpOption = option;
        return this;
      }

      /**
       * Output help information and exit.
       *
       * Outputs built-in help, and custom text added using `.addHelpText()`.
       *
       * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
       */

      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = Number(process.exitCode ?? 0); // process.exitCode does allow a string or an integer, but we prefer just a number
        if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
          exitCode = 1;
        }
        // message: do not have all displayed text available so only passing placeholder.
        this._exit(exitCode, 'commander.help', '(outputHelp)');
      }

      /**
       * // Do a little typing to coordinate emit and listener for the help text events.
       * @typedef HelpTextEventContext
       * @type {object}
       * @property {boolean} error
       * @property {Command} command
       * @property {function} write
       */

      /**
       * Add additional text to be displayed with the built-in help.
       *
       * Position is 'before' or 'after' to affect just this command,
       * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
       *
       * @param {string} position - before or after built-in help
       * @param {(string | Function)} text - string to add, or a function returning a string
       * @return {Command} `this` command for chaining
       */

      addHelpText(position, text) {
        const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }

        const helpEvent = `${position}Help`;
        this.on(helpEvent, (/** @type {HelpTextEventContext} */ context) => {
          let helpStr;
          if (typeof text === 'function') {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          // Ignore falsy value when nothing to output.
          if (helpStr) {
            context.write(`${helpStr}\n`);
          }
        });
        return this;
      }

      /**
       * Output help information if help flags specified
       *
       * @param {Array} args - array of options to search for help flags
       * @private
       */

      _outputHelpIfRequested(args) {
        const helpOption = this._getHelpOption();
        const helpRequested = helpOption && args.find(arg => helpOption.is(arg));
        if (helpRequested) {
          this.outputHelp();
          // (Do not have all displayed text available so only passing placeholder.)
          this._exit(0, 'commander.helpDisplayed', '(outputHelp)');
        }
      }
    }

    /**
     * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
     *
     * @param {string[]} args - array of arguments from node.execArgv
     * @returns {string[]}
     * @private
     */

    function incrementNodeInspectorPort(args) {
      // Testing for these options:
      //  --inspect[=[host:]port]
      //  --inspect-brk[=[host:]port]
      //  --inspect-port=[host:]port
      return args.map(arg => {
        if (!arg.startsWith('--inspect')) {
          return arg;
        }
        let debugOption;
        let debugHost = '127.0.0.1';
        let debugPort = '9229';
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          // e.g. --inspect
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            // e.g. --inspect=1234
            debugPort = match[3];
          } else {
            // e.g. --inspect=localhost
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          // e.g. --inspect=localhost:1234
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }

        if (debugOption && debugPort !== '0') {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }

    /**
     * @returns {boolean | undefined}
     * @package
     */
    function useColor() {
      // Test for common conventions.
      // NB: the observed behaviour is in combination with how author adds color! For example:
      //   - we do not test NODE_DISABLE_COLORS, but util:styletext does
      //   - we do test NO_COLOR, but Chalk does not
      //
      // References:
      // https://no-color.org
      // https://bixense.com/clicolors/
      // https://github.com/nodejs/node/blob/0a00217a5f67ef4a22384cfc80eb6dd9a917fdc1/lib/internal/tty.js#L109
      // https://github.com/chalk/supports-color/blob/c214314a14bcb174b12b3014b2b0a8de375029ae/index.js#L33
      // (https://force-color.org recent web page from 2023, does not match major javascript implementations)

      if (process.env.NO_COLOR || process.env.FORCE_COLOR === '0' || process.env.FORCE_COLOR === 'false') return false;
      if (process.env.FORCE_COLOR || process.env.CLICOLOR_FORCE !== undefined) return true;
      return undefined;
    }

    exports.Command = Command;
    exports.useColor = useColor; // exporting for tests

    /***/
  },

  /***/ 180: /***/ (__unused_webpack_module, exports) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.hasBinary = exports.isBinary = void 0;
    const withNativeArrayBuffer = typeof ArrayBuffer === 'function';
    const isView = obj => {
      return typeof ArrayBuffer.isView === 'function' ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    };
    const toString = Object.prototype.toString;
    const withNativeBlob =
      typeof Blob === 'function' || (typeof Blob !== 'undefined' && toString.call(Blob) === '[object BlobConstructor]');
    const withNativeFile =
      typeof File === 'function' || (typeof File !== 'undefined' && toString.call(File) === '[object FileConstructor]');
    /**
     * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
     *
     * @private
     */
    function isBinary(obj) {
      return (
        (withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||
        (withNativeBlob && obj instanceof Blob) ||
        (withNativeFile && obj instanceof File)
      );
    }
    exports.isBinary = isBinary;
    function hasBinary(obj, toJSON) {
      if (!obj || typeof obj !== 'object') {
        return false;
      }
      if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
          if (hasBinary(obj[i])) {
            return true;
          }
        }
        return false;
      }
      if (isBinary(obj)) {
        return true;
      }
      if (obj.toJSON && typeof obj.toJSON === 'function' && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }
      return false;
    }
    exports.hasBinary = hasBinary;

    /***/
  },

  /***/ 181: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('buffer');

    /***/
  },

  /***/ 184: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Client = void 0;
    const socket_io_parser_1 = __webpack_require__(9834);
    const debugModule = __webpack_require__(1106);
    const url = __webpack_require__(7016);
    const debug = debugModule('socket.io:client');
    class Client {
      /**
       * Client constructor.
       *
       * @param server instance
       * @param conn
       * @package
       */
      constructor(server, conn) {
        this.sockets = new Map();
        this.nsps = new Map();
        this.server = server;
        this.conn = conn;
        this.encoder = server.encoder;
        this.decoder = new server._parser.Decoder();
        this.id = conn.id;
        this.setup();
      }
      /**
       * @return the reference to the request that originated the Engine.IO connection
       *
       * @public
       */
      get request() {
        return this.conn.request;
      }
      /**
       * Sets up event listeners.
       *
       * @private
       */
      setup() {
        this.onclose = this.onclose.bind(this);
        this.ondata = this.ondata.bind(this);
        this.onerror = this.onerror.bind(this);
        this.ondecoded = this.ondecoded.bind(this);
        // @ts-ignore
        this.decoder.on('decoded', this.ondecoded);
        this.conn.on('data', this.ondata);
        this.conn.on('error', this.onerror);
        this.conn.on('close', this.onclose);
        this.connectTimeout = setTimeout(() => {
          if (this.nsps.size === 0) {
            debug('no namespace joined yet, close the client');
            this.close();
          } else {
            debug('the client has already joined a namespace, nothing to do');
          }
        }, this.server._connectTimeout);
      }
      /**
       * Connects a client to a namespace.
       *
       * @param {String} name - the namespace
       * @param {Object} auth - the auth parameters
       * @private
       */
      connect(name, auth = {}) {
        if (this.server._nsps.has(name)) {
          debug('connecting to namespace %s', name);
          return this.doConnect(name, auth);
        }
        this.server._checkNamespace(name, auth, dynamicNspName => {
          if (dynamicNspName) {
            this.doConnect(name, auth);
          } else {
            debug('creation of namespace %s was denied', name);
            this._packet({
              type: socket_io_parser_1.PacketType.CONNECT_ERROR,
              nsp: name,
              data: {
                message: 'Invalid namespace',
              },
            });
          }
        });
      }
      /**
       * Connects a client to a namespace.
       *
       * @param name - the namespace
       * @param {Object} auth - the auth parameters
       *
       * @private
       */
      doConnect(name, auth) {
        const nsp = this.server.of(name);
        nsp._add(this, auth, socket => {
          this.sockets.set(socket.id, socket);
          this.nsps.set(nsp.name, socket);
          if (this.connectTimeout) {
            clearTimeout(this.connectTimeout);
            this.connectTimeout = undefined;
          }
        });
      }
      /**
       * Disconnects from all namespaces and closes transport.
       *
       * @private
       */
      _disconnect() {
        for (const socket of this.sockets.values()) {
          socket.disconnect();
        }
        this.sockets.clear();
        this.close();
      }
      /**
       * Removes a socket. Called by each `Socket`.
       *
       * @private
       */
      _remove(socket) {
        if (this.sockets.has(socket.id)) {
          const nsp = this.sockets.get(socket.id).nsp.name;
          this.sockets.delete(socket.id);
          this.nsps.delete(nsp);
        } else {
          debug('ignoring remove for %s', socket.id);
        }
      }
      /**
       * Closes the underlying connection.
       *
       * @private
       */
      close() {
        if (this.conn.readyState === 'open') {
          debug('forcing transport close');
          this.conn.close();
          this.onclose('forced server close');
        }
      }
      /**
       * Writes a packet to the transport.
       *
       * @param {Object} packet object
       * @param {Object} opts
       * @private
       */
      _packet(packet, opts = {}) {
        if (this.conn.readyState !== 'open') {
          debug('ignoring packet write %j', packet);
          return;
        }
        const encodedPackets = opts.preEncoded
          ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()
          : this.encoder.encode(packet);
        this.writeToEngine(encodedPackets, opts);
      }
      writeToEngine(encodedPackets, opts) {
        if (opts.volatile && !this.conn.transport.writable) {
          debug('volatile packet is discarded since the transport is not currently writable');
          return;
        }
        const packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];
        for (const encodedPacket of packets) {
          this.conn.write(encodedPacket, opts);
        }
      }
      /**
       * Called with incoming transport data.
       *
       * @private
       */
      ondata(data) {
        // try/catch is needed for protocol violations (GH-1880)
        try {
          this.decoder.add(data);
        } catch (e) {
          debug('invalid packet format');
          this.onerror(e);
        }
      }
      /**
       * Called when parser fully decodes a packet.
       *
       * @private
       */
      ondecoded(packet) {
        let namespace;
        let authPayload;
        if (this.conn.protocol === 3) {
          const parsed = url.parse(packet.nsp, true);
          namespace = parsed.pathname;
          authPayload = parsed.query;
        } else {
          namespace = packet.nsp;
          authPayload = packet.data;
        }
        const socket = this.nsps.get(namespace);
        if (!socket && packet.type === socket_io_parser_1.PacketType.CONNECT) {
          this.connect(namespace, authPayload);
        } else if (
          socket &&
          packet.type !== socket_io_parser_1.PacketType.CONNECT &&
          packet.type !== socket_io_parser_1.PacketType.CONNECT_ERROR
        ) {
          process.nextTick(function () {
            socket._onpacket(packet);
          });
        } else {
          debug('invalid state (packet type: %s)', packet.type);
          this.close();
        }
      }
      /**
       * Handles an error.
       *
       * @param {Object} err object
       * @private
       */
      onerror(err) {
        for (const socket of this.sockets.values()) {
          socket._onerror(err);
        }
        this.conn.close();
      }
      /**
       * Called upon transport close.
       *
       * @param reason
       * @param description
       * @private
       */
      onclose(reason, description) {
        debug('client close with reason %s', reason);
        // ignore a potential subsequent `close` event
        this.destroy();
        // `nsps` and `sockets` are cleaned up seamlessly
        for (const socket of this.sockets.values()) {
          socket._onclose(reason, description);
        }
        this.sockets.clear();
        this.decoder.destroy(); // clean up decoder
      }
      /**
       * Cleans up event listeners.
       * @private
       */
      destroy() {
        this.conn.removeListener('data', this.ondata);
        this.conn.removeListener('error', this.onerror);
        this.conn.removeListener('close', this.onclose);
        // @ts-ignore
        this.decoder.removeListener('decoded', this.ondecoded);
        if (this.connectTimeout) {
          clearTimeout(this.connectTimeout);
          this.connectTimeout = undefined;
        }
      }
    }
    exports.Client = Client;

    /***/
  },

  /***/ 191: /***/ (__unused_webpack_module, exports) => {
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = '';
      if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case 'space':
              hasSpace = true;
              break;
            case 'comment': {
              if (reqSpace && !hasSpace)
                onError(
                  token,
                  'MISSING_CHAR',
                  'Comments must be separated from other tokens by white space characters',
                );
              const cb = source.substring(1) || ' ';
              if (!comment) comment = cb;
              else comment += sep + cb;
              sep = '';
              break;
            }
            case 'newline':
              if (comment) sep += source;
              hasSpace = true;
              break;
            default:
              onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }

    exports.resolveEnd = resolveEnd;

    /***/
  },

  /***/ 245: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const YAMLSeq = __webpack_require__(2016);
    const resolveProps = __webpack_require__(5300);
    const utilFlowIndentCheck = __webpack_require__(2382);

    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot) ctx.atRoot = false;
      if (ctx.atKey) ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: 'seq-item-ind',
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true,
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value && value.type === 'block-seq')
              onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
            else onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
          } else {
            commentEnd = props.end;
            if (props.comment) seq.comment = props.comment;
            continue;
          }
        }
        const node = value
          ? composeNode(ctx, value, props, onError)
          : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }

    exports.resolveBlockSeq = resolveBlockSeq;

    /***/
  },

  /***/ 397: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Scalar = __webpack_require__(6364);
    const stringifyNumber = __webpack_require__(2490);

    const floatNaN = {
      identify: value => typeof value === 'number',
      default: true,
      tag: 'tag:yaml.org,2002:float',
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: str =>
        str.slice(-3).toLowerCase() === 'nan'
          ? NaN
          : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber,
    };
    const floatExp = {
      identify: value => typeof value === 'number',
      default: true,
      tag: 'tag:yaml.org,2002:float',
      format: 'EXP',
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: str => parseFloat(str.replace(/_/g, '')),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      },
    };
    const float = {
      identify: value => typeof value === 'number',
      default: true,
      tag: 'tag:yaml.org,2002:float',
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, '');
          if (f[f.length - 1] === '0') node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber,
    };

    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;

    /***/
  },

  /***/ 407: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const identity = __webpack_require__(7182);
    const map = __webpack_require__(4304);
    const seq = __webpack_require__(581);
    const string = __webpack_require__(4401);
    const tags = __webpack_require__(7821);

    const sortMapEntriesByKey = (a, b) => (a.key < b.key ? -1 : a.key > b.key ? 1 : 0);
    class Schema {
      constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
          ? tags.getTags(compat, 'compat')
          : compat
            ? tags.getTags(null, compat)
            : null;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
          typeof sortMapEntries === 'function' ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    }

    exports.Schema = Schema;

    /***/
  },

  /***/ 414: /***/ function (__unused_webpack_module, exports, __webpack_require__) {
    const __importDefault =
      (this && this.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Socket = void 0;
    const socket_io_parser_1 = __webpack_require__(9834);
    const debug_1 = __importDefault(__webpack_require__(1106));
    const typed_events_1 = __webpack_require__(21);
    const base64id_1 = __importDefault(__webpack_require__(6821));
    const broadcast_operator_1 = __webpack_require__(3761);
    const socket_types_1 = __webpack_require__(8578);
    const debug = (0, debug_1.default)('socket.io:socket');
    const RECOVERABLE_DISCONNECT_REASONS = new Set([
      'transport error',
      'transport close',
      'forced close',
      'ping timeout',
      'server shutting down',
      'forced server close',
    ]);
    function noop() {}
    /**
     * This is the main object for interacting with a client.
     *
     * A Socket belongs to a given {@link Namespace} and uses an underlying {@link Client} to communicate.
     *
     * Within each {@link Namespace}, you can also define arbitrary channels (called "rooms") that the {@link Socket} can
     * join and leave. That provides a convenient way to broadcast to a group of socket instances.
     *
     * @example
     * io.on("connection", (socket) => {
     *   console.log(`socket ${socket.id} connected`);
     *
     *   // send an event to the client
     *   socket.emit("foo", "bar");
     *
     *   socket.on("foobar", () => {
     *     // an event was received from the client
     *   });
     *
     *   // join the room named "room1"
     *   socket.join("room1");
     *
     *   // broadcast to everyone in the room named "room1"
     *   io.to("room1").emit("hello");
     *
     *   // upon disconnection
     *   socket.on("disconnect", (reason) => {
     *     console.log(`socket ${socket.id} disconnected due to ${reason}`);
     *   });
     * });
     */
    class Socket extends typed_events_1.StrictEventEmitter {
      /**
       * Interface to a `Client` for a given `Namespace`.
       *
       * @param {Namespace} nsp
       * @param {Client} client
       * @param {Object} auth
       * @package
       */
      constructor(nsp, client, auth, previousSession) {
        super();
        this.nsp = nsp;
        this.client = client;
        /**
         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will
         * be transmitted to the client, the data attribute and the rooms will be restored.
         */
        this.recovered = false;
        /**
         * Additional information that can be attached to the Socket instance and which will be used in the
         * {@link Server.fetchSockets()} method.
         */
        this.data = {};
        /**
         * Whether the socket is currently connected or not.
         *
         * @example
         * io.use((socket, next) => {
         *   console.log(socket.connected); // false
         *   next();
         * });
         *
         * io.on("connection", (socket) => {
         *   console.log(socket.connected); // true
         * });
         */
        this.connected = false;
        this.acks = new Map();
        this.fns = [];
        this.flags = {};
        this.server = nsp.server;
        this.adapter = this.nsp.adapter;
        if (previousSession) {
          this.id = previousSession.sid;
          this.pid = previousSession.pid;
          previousSession.rooms.forEach(room => this.join(room));
          this.data = previousSession.data;
          previousSession.missedPackets.forEach(packet => {
            this.packet({
              type: socket_io_parser_1.PacketType.EVENT,
              data: packet,
            });
          });
          this.recovered = true;
        } else {
          if (client.conn.protocol === 3) {
            // @ts-ignore
            this.id = nsp.name !== '/' ? nsp.name + '#' + client.id : client.id;
          } else {
            this.id = base64id_1.default.generateId(); // don't reuse the Engine.IO id because it's sensitive information
          }
          if (this.server._opts.connectionStateRecovery) {
            this.pid = base64id_1.default.generateId();
          }
        }
        this.handshake = this.buildHandshake(auth);
        // prevents crash when the socket receives an "error" event without listener
        this.on('error', noop);
      }
      /**
       * Builds the `handshake` BC object
       *
       * @private
       */
      buildHandshake(auth) {
        let _a, _b, _c, _d;
        return {
          headers: ((_a = this.request) === null || _a === void 0 ? void 0 : _a.headers) || {},
          time: new Date() + '',
          address: this.conn.remoteAddress,
          xdomain: !!((_b = this.request) === null || _b === void 0 ? void 0 : _b.headers.origin),
          // @ts-ignore
          secure: !this.request || !!this.request.connection.encrypted,
          issued: +new Date(),
          url: (_c = this.request) === null || _c === void 0 ? void 0 : _c.url,
          // @ts-ignore
          query: ((_d = this.request) === null || _d === void 0 ? void 0 : _d._query) || {},
          auth,
        };
      }
      /**
       * Emits to this client.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.emit("hello", "world");
       *
       *   // all serializable datastructures are supported (no need to call JSON.stringify)
       *   socket.emit("hello", 1, "2", { 3: ["4"], 5: Buffer.from([6]) });
       *
       *   // with an acknowledgement from the client
       *   socket.emit("hello", "world", (val) => {
       *     // ...
       *   });
       * });
       *
       * @return Always returns `true`.
       */
      emit(ev, ...args) {
        if (socket_types_1.RESERVED_EVENTS.has(ev)) {
          throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        const data = [ev, ...args];
        const packet = {
          type: socket_io_parser_1.PacketType.EVENT,
          data: data,
        };
        // access last argument to see if it's an ACK callback
        if (typeof data[data.length - 1] === 'function') {
          const id = this.nsp._ids++;
          debug('emitting packet with ack id %d', id);
          this.registerAckCallback(id, data.pop());
          packet.id = id;
        }
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        // @ts-ignore
        if (this.nsp.server.opts.connectionStateRecovery) {
          // this ensures the packet is stored and can be transmitted upon reconnection
          this.adapter.broadcast(packet, {
            rooms: new Set([this.id]),
            except: new Set(),
            flags,
          });
        } else {
          this.notifyOutgoingListeners(packet);
          this.packet(packet, flags);
        }
        return true;
      }
      /**
       * Emits an event and waits for an acknowledgement
       *
       * @example
       * io.on("connection", async (socket) => {
       *   // without timeout
       *   const response = await socket.emitWithAck("hello", "world");
       *
       *   // with a specific timeout
       *   try {
       *     const response = await socket.timeout(1000).emitWithAck("hello", "world");
       *   } catch (err) {
       *     // the client did not acknowledge the event in the given delay
       *   }
       * });
       *
       * @return a Promise that will be fulfilled when the client acknowledges the event
       */
      emitWithAck(ev, ...args) {
        // the timeout flag is optional
        const withErr = this.flags.timeout !== undefined;
        return new Promise((resolve, reject) => {
          args.push((arg1, arg2) => {
            if (withErr) {
              return arg1 ? reject(arg1) : resolve(arg2);
            } else {
              return resolve(arg1);
            }
          });
          this.emit(ev, ...args);
        });
      }
      /**
       * @private
       */
      registerAckCallback(id, ack) {
        const timeout = this.flags.timeout;
        if (timeout === undefined) {
          this.acks.set(id, ack);
          return;
        }
        const timer = setTimeout(() => {
          debug('event with ack id %d has timed out after %d ms', id, timeout);
          this.acks.delete(id);
          ack.call(this, new Error('operation has timed out'));
        }, timeout);
        this.acks.set(id, (...args) => {
          clearTimeout(timer);
          ack.apply(this, [null, ...args]);
        });
      }
      /**
       * Targets a room when broadcasting.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // the “foo” event will be broadcast to all connected clients in the “room-101” room, except this socket
       *   socket.to("room-101").emit("foo", "bar");
       *
       *   // the code above is equivalent to:
       *   io.to("room-101").except(socket.id).emit("foo", "bar");
       *
       *   // with an array of rooms (a client will be notified at most once)
       *   socket.to(["room-101", "room-102"]).emit("foo", "bar");
       *
       *   // with multiple chained calls
       *   socket.to("room-101").to("room-102").emit("foo", "bar");
       * });
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      to(room) {
        return this.newBroadcastOperator().to(room);
      }
      /**
       * Targets a room when broadcasting. Similar to `to()`, but might feel clearer in some cases:
       *
       * @example
       * io.on("connection", (socket) => {
       *   // disconnect all clients in the "room-101" room, except this socket
       *   socket.in("room-101").disconnectSockets();
       * });
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      in(room) {
        return this.newBroadcastOperator().in(room);
      }
      /**
       * Excludes a room when broadcasting.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
       *   // and this socket
       *   socket.except("room-101").emit("foo", "bar");
       *
       *   // with an array of rooms
       *   socket.except(["room-101", "room-102"]).emit("foo", "bar");
       *
       *   // with multiple chained calls
       *   socket.except("room-101").except("room-102").emit("foo", "bar");
       * });
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      except(room) {
        return this.newBroadcastOperator().except(room);
      }
      /**
       * Sends a `message` event.
       *
       * This method mimics the WebSocket.send() method.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.send("hello");
       *
       *   // this is equivalent to
       *   socket.emit("message", "hello");
       * });
       *
       * @return self
       */
      send(...args) {
        this.emit('message', ...args);
        return this;
      }
      /**
       * Sends a `message` event. Alias of {@link send}.
       *
       * @return self
       */
      write(...args) {
        this.emit('message', ...args);
        return this;
      }
      /**
       * Writes a packet.
       *
       * @param {Object} packet - packet object
       * @param {Object} opts - options
       * @private
       */
      packet(packet, opts = {}) {
        packet.nsp = this.nsp.name;
        opts.compress = opts.compress !== false;
        this.client._packet(packet, opts);
      }
      /**
       * Joins a room.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // join a single room
       *   socket.join("room1");
       *
       *   // join multiple rooms
       *   socket.join(["room1", "room2"]);
       * });
       *
       * @param {String|Array} rooms - room or array of rooms
       * @return a Promise or nothing, depending on the adapter
       */
      join(rooms) {
        debug('join room %s', rooms);
        return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
      }
      /**
       * Leaves a room.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // leave a single room
       *   socket.leave("room1");
       *
       *   // leave multiple rooms
       *   socket.leave("room1").leave("room2");
       * });
       *
       * @param {String} room
       * @return a Promise or nothing, depending on the adapter
       */
      leave(room) {
        debug('leave room %s', room);
        return this.adapter.del(this.id, room);
      }
      /**
       * Leave all rooms.
       *
       * @private
       */
      leaveAll() {
        this.adapter.delAll(this.id);
      }
      /**
       * Called by `Namespace` upon successful
       * middleware execution (ie: authorization).
       * Socket is added to namespace array before
       * call to join, so adapters can access it.
       *
       * @private
       */
      _onconnect() {
        debug('socket connected - writing packet');
        this.connected = true;
        this.join(this.id);
        if (this.conn.protocol === 3) {
          this.packet({ type: socket_io_parser_1.PacketType.CONNECT });
        } else {
          this.packet({
            type: socket_io_parser_1.PacketType.CONNECT,
            data: { sid: this.id, pid: this.pid },
          });
        }
      }
      /**
       * Called with each packet. Called by `Client`.
       *
       * @param {Object} packet
       * @private
       */
      _onpacket(packet) {
        debug('got packet %j', packet);
        switch (packet.type) {
          case socket_io_parser_1.PacketType.EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_1.PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_1.PacketType.ACK:
            this.onack(packet);
            break;
          case socket_io_parser_1.PacketType.BINARY_ACK:
            this.onack(packet);
            break;
          case socket_io_parser_1.PacketType.DISCONNECT:
            this.ondisconnect();
            break;
        }
      }
      /**
       * Called upon event packet.
       *
       * @param {Packet} packet - packet object
       * @private
       */
      onevent(packet) {
        const args = packet.data || [];
        debug('emitting event %j', args);
        if (packet.id != null) {
          debug('attaching ack callback to event');
          args.push(this.ack(packet.id));
        }
        if (this._anyListeners && this._anyListeners.length) {
          const listeners = this._anyListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, args);
          }
        }
        this.dispatch(args);
      }
      /**
       * Produces an ack callback to emit with an event.
       *
       * @param {Number} id - packet id
       * @private
       */
      ack(id) {
        const self = this;
        let sent = false;
        return function () {
          // prevent double callbacks
          if (sent) return;
          const args = Array.prototype.slice.call(arguments);
          debug('sending ack %j', args);
          self.packet({
            id: id,
            type: socket_io_parser_1.PacketType.ACK,
            data: args,
          });
          sent = true;
        };
      }
      /**
       * Called upon ack packet.
       *
       * @private
       */
      onack(packet) {
        const ack = this.acks.get(packet.id);
        if (typeof ack == 'function') {
          debug('calling ack %s with %j', packet.id, packet.data);
          ack.apply(this, packet.data);
          this.acks.delete(packet.id);
        } else {
          debug('bad ack %s', packet.id);
        }
      }
      /**
       * Called upon client disconnect packet.
       *
       * @private
       */
      ondisconnect() {
        debug('got disconnect packet');
        this._onclose('client namespace disconnect');
      }
      /**
       * Handles a client error.
       *
       * @private
       */
      _onerror(err) {
        // FIXME the meaning of the "error" event is overloaded:
        //  - it can be sent by the client (`socket.emit("error")`)
        //  - it can be emitted when the connection encounters an error (an invalid packet for example)
        //  - it can be emitted when a packet is rejected in a middleware (`socket.use()`)
        this.emitReserved('error', err);
      }
      /**
       * Called upon closing. Called by `Client`.
       *
       * @param {String} reason
       * @param description
       * @throw {Error} optional error object
       *
       * @private
       */
      _onclose(reason, description) {
        if (!this.connected) return this;
        debug('closing socket - reason %s', reason);
        this.emitReserved('disconnecting', reason, description);
        if (this.server._opts.connectionStateRecovery && RECOVERABLE_DISCONNECT_REASONS.has(reason)) {
          debug('connection state recovery is enabled for sid %s', this.id);
          this.adapter.persistSession({
            sid: this.id,
            pid: this.pid,
            rooms: [...this.rooms],
            data: this.data,
          });
        }
        this._cleanup();
        this.client._remove(this);
        this.connected = false;
        this.emitReserved('disconnect', reason, description);
        return;
      }
      /**
       * Makes the socket leave all the rooms it was part of and prevents it from joining any other room
       *
       * @private
       */
      _cleanup() {
        this.leaveAll();
        this.nsp._remove(this);
        this.join = noop;
      }
      /**
       * Produces an `error` packet.
       *
       * @param {Object} err - error object
       *
       * @private
       */
      _error(err) {
        this.packet({ type: socket_io_parser_1.PacketType.CONNECT_ERROR, data: err });
      }
      /**
       * Disconnects this client.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // disconnect this socket (the connection might be kept alive for other namespaces)
       *   socket.disconnect();
       *
       *   // disconnect this socket and close the underlying connection
       *   socket.disconnect(true);
       * })
       *
       * @param {Boolean} close - if `true`, closes the underlying connection
       * @return self
       */
      disconnect(close = false) {
        if (!this.connected) return this;
        if (close) {
          this.client._disconnect();
        } else {
          this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
          this._onclose('server namespace disconnect');
        }
        return this;
      }
      /**
       * Sets the compress flag.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.compress(false).emit("hello");
       * });
       *
       * @param {Boolean} compress - if `true`, compresses the sending data
       * @return {Socket} self
       */
      compress(compress) {
        this.flags.compress = compress;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
       * receive messages (because of network slowness or other issues, or because they’re connected through long polling
       * and is in the middle of a request-response cycle).
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.volatile.emit("hello"); // the client may or may not receive it
       * });
       *
       * @return {Socket} self
       */
      get volatile() {
        this.flags.volatile = true;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the
       * sender.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // the “foo” event will be broadcast to all connected clients, except this socket
       *   socket.broadcast.emit("foo", "bar");
       * });
       *
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      get broadcast() {
        return this.newBroadcastOperator();
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
       *
       * @example
       * io.on("connection", (socket) => {
       *   // the “foo” event will be broadcast to all connected clients on this node, except this socket
       *   socket.local.emit("foo", "bar");
       * });
       *
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      get local() {
        return this.newBroadcastOperator().local;
      }
      /**
       * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
       * given number of milliseconds have elapsed without an acknowledgement from the client:
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.timeout(5000).emit("my-event", (err) => {
       *     if (err) {
       *       // the client did not acknowledge the event in the given delay
       *     }
       *   });
       * });
       *
       * @returns self
       */
      timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
      }
      /**
       * Dispatch incoming event to socket listeners.
       *
       * @param {Array} event - event that will get emitted
       * @private
       */
      dispatch(event) {
        debug('dispatching an event %j', event);
        this.run(event, err => {
          process.nextTick(() => {
            if (err) {
              return this._onerror(err);
            }
            if (this.connected) {
              super.emitUntyped.apply(this, event);
            } else {
              debug('ignore packet received after disconnection');
            }
          });
        });
      }
      /**
       * Sets up socket middleware.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.use(([event, ...args], next) => {
       *     if (isUnauthorized(event)) {
       *       return next(new Error("unauthorized event"));
       *     }
       *     // do not forget to call next
       *     next();
       *   });
       *
       *   socket.on("error", (err) => {
       *     if (err && err.message === "unauthorized event") {
       *       socket.disconnect();
       *     }
       *   });
       * });
       *
       * @param {Function} fn - middleware function (event, next)
       * @return {Socket} self
       */
      use(fn) {
        this.fns.push(fn);
        return this;
      }
      /**
       * Executes the middleware for an incoming event.
       *
       * @param {Array} event - event that will get emitted
       * @param {Function} fn - last fn call in the middleware
       * @private
       */
      run(event, fn) {
        if (!this.fns.length) return fn();
        const fns = this.fns.slice(0);
        function run(i) {
          fns[i](event, err => {
            // upon error, short-circuit
            if (err) return fn(err);
            // if no middleware left, summon callback
            if (!fns[i + 1]) return fn();
            // go on to next
            run(i + 1);
          });
        }
        run(0);
      }
      /**
       * Whether the socket is currently disconnected
       */
      get disconnected() {
        return !this.connected;
      }
      /**
       * A reference to the request that originated the underlying Engine.IO Socket.
       */
      get request() {
        return this.client.request;
      }
      /**
       * A reference to the underlying Client transport connection (Engine.IO Socket object).
       *
       * @example
       * io.on("connection", (socket) => {
       *   console.log(socket.conn.transport.name); // prints "polling" or "websocket"
       *
       *   socket.conn.once("upgrade", () => {
       *     console.log(socket.conn.transport.name); // prints "websocket"
       *   });
       * });
       */
      get conn() {
        return this.client.conn;
      }
      /**
       * Returns the rooms the socket is currently in.
       *
       * @example
       * io.on("connection", (socket) => {
       *   console.log(socket.rooms); // Set { <socket.id> }
       *
       *   socket.join("room1");
       *
       *   console.log(socket.rooms); // Set { <socket.id>, "room1" }
       * });
       */
      get rooms() {
        return this.adapter.socketRooms(this.id) || new Set();
      }
      /**
       * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to
       * the callback.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.onAny((event, ...args) => {
       *     console.log(`got event ${event}`);
       *   });
       * });
       *
       * @param listener
       */
      onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is received. The event name is passed as the first argument to
       * the callback. The listener is added to the beginning of the listeners array.
       *
       * @param listener
       */
      prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is received.
       *
       * @example
       * io.on("connection", (socket) => {
       *   const catchAllListener = (event, ...args) => {
       *     console.log(`got event ${event}`);
       *   }
       *
       *   socket.onAny(catchAllListener);
       *
       *   // remove a specific listener
       *   socket.offAny(catchAllListener);
       *
       *   // or remove all listeners
       *   socket.offAny();
       * });
       *
       * @param listener
       */
      offAny(listener) {
        if (!this._anyListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAny() {
        return this._anyListeners || [];
      }
      /**
       * Adds a listener that will be fired when any event is sent. The event name is passed as the first argument to
       * the callback.
       *
       * Note: acknowledgements sent to the client are not included.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.onAnyOutgoing((event, ...args) => {
       *     console.log(`sent event ${event}`);
       *   });
       * });
       *
       * @param listener
       */
      onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * @example
       * io.on("connection", (socket) => {
       *   socket.prependAnyOutgoing((event, ...args) => {
       *     console.log(`sent event ${event}`);
       *   });
       * });
       *
       * @param listener
       */
      prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is sent.
       *
       * @example
       * io.on("connection", (socket) => {
       *   const catchAllListener = (event, ...args) => {
       *     console.log(`sent event ${event}`);
       *   }
       *
       *   socket.onAnyOutgoing(catchAllListener);
       *
       *   // remove a specific listener
       *   socket.offAnyOutgoing(catchAllListener);
       *
       *   // or remove all listeners
       *   socket.offAnyOutgoing();
       * });
       *
       * @param listener - the catch-all listener
       */
      offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyOutgoingListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyOutgoingListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      /**
       * Notify the listeners for each packet sent (emit or broadcast)
       *
       * @param packet
       *
       * @private
       */
      notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          const listeners = this._anyOutgoingListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, packet.data);
          }
        }
      }
      newBroadcastOperator() {
        const flags = Object.assign({}, this.flags);
        this.flags = {};
        return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);
      }
    }
    exports.Socket = Socket;

    /***/
  },

  /***/ 578: /***/ (module, exports, __webpack_require__) => {
    /* eslint-env browser */

    /**
     * This is the web browser implementation of `debug()`.
     */

    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;

      return () => {
        if (!warned) {
          warned = true;
          console.warn(
            'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
          );
        }
      };
    })();

    /**
     * Colors.
     */

    exports.colors = [
      '#0000CC',
      '#0000FF',
      '#0033CC',
      '#0033FF',
      '#0066CC',
      '#0066FF',
      '#0099CC',
      '#0099FF',
      '#00CC00',
      '#00CC33',
      '#00CC66',
      '#00CC99',
      '#00CCCC',
      '#00CCFF',
      '#3300CC',
      '#3300FF',
      '#3333CC',
      '#3333FF',
      '#3366CC',
      '#3366FF',
      '#3399CC',
      '#3399FF',
      '#33CC00',
      '#33CC33',
      '#33CC66',
      '#33CC99',
      '#33CCCC',
      '#33CCFF',
      '#6600CC',
      '#6600FF',
      '#6633CC',
      '#6633FF',
      '#66CC00',
      '#66CC33',
      '#9900CC',
      '#9900FF',
      '#9933CC',
      '#9933FF',
      '#99CC00',
      '#99CC33',
      '#CC0000',
      '#CC0033',
      '#CC0066',
      '#CC0099',
      '#CC00CC',
      '#CC00FF',
      '#CC3300',
      '#CC3333',
      '#CC3366',
      '#CC3399',
      '#CC33CC',
      '#CC33FF',
      '#CC6600',
      '#CC6633',
      '#CC9900',
      '#CC9933',
      '#CCCC00',
      '#CCCC33',
      '#FF0000',
      '#FF0033',
      '#FF0066',
      '#FF0099',
      '#FF00CC',
      '#FF00FF',
      '#FF3300',
      '#FF3333',
      '#FF3366',
      '#FF3399',
      '#FF33CC',
      '#FF33FF',
      '#FF6600',
      '#FF6633',
      '#FF9900',
      '#FF9933',
      '#FFCC00',
      '#FFCC33',
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (
        typeof window !== 'undefined' &&
        window.process &&
        (window.process.type === 'renderer' || window.process.__nwjs)
      ) {
        return true;
      }

      // Internet Explorer and Edge do not support colors.
      if (
        typeof navigator !== 'undefined' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
      ) {
        return false;
      }

      let m;

      // Is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return (
        (typeof document !== 'undefined' &&
          document.documentElement &&
          document.documentElement.style &&
          document.documentElement.style.WebkitAppearance) ||
        // Is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== 'undefined' &&
          window.console &&
          (window.console.firebug || (window.console.exception && window.console.table))) ||
        // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== 'undefined' &&
          navigator.userAgent &&
          (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
          parseInt(m[1], 10) >= 31) ||
        // Double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== 'undefined' &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
      );
    }

    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      args[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        args[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        module.exports.humanize(this.diff);

      if (!this.useColors) {
        return;
      }

      const c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // The final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, match => {
        if (match === '%%') {
          return;
        }
        index++;
        if (match === '%c') {
          // We only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.debug()` when available.
     * No-op when `console.debug` is not a "function".
     * If `console.debug` is not available, falls back
     * to `console.log`.
     *
     * @api public
     */
    exports.log = console.debug || console.log || (() => {});

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem('debug', namespaces);
        } else {
          exports.storage.removeItem('debug');
        }
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */
    function load() {
      let r;
      try {
        r = exports.storage.getItem('debug');
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
      } catch (error) {
        // Swallow
        // XXX (@Qix-) should we be logging these?
      }
    }

    module.exports = __webpack_require__(7709)(exports);

    const { formatters } = module.exports;

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    formatters.j = function (v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
      }
    };

    /***/
  },

  /***/ 581: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const identity = __webpack_require__(7182);
    const YAMLSeq = __webpack_require__(2016);

    const seq = {
      collection: 'seq',
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: 'tag:yaml.org,2002:seq',
      resolve(seq, onError) {
        if (!identity.isSeq(seq)) onError('Expected a sequence for this tag');
        return seq;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx),
    };

    exports.seq = seq;

    /***/
  },

  /***/ 616: /***/ function (__unused_webpack_module, exports, __webpack_require__) {
    const __importDefault =
      (this && this.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Namespace = exports.RESERVED_EVENTS = void 0;
    const socket_1 = __webpack_require__(414);
    const typed_events_1 = __webpack_require__(21);
    const debug_1 = __importDefault(__webpack_require__(1106));
    const broadcast_operator_1 = __webpack_require__(3761);
    const debug = (0, debug_1.default)('socket.io:namespace');
    exports.RESERVED_EVENTS = new Set(['connect', 'connection', 'new_namespace']);
    /**
     * A Namespace is a communication channel that allows you to split the logic of your application over a single shared
     * connection.
     *
     * Each namespace has its own:
     *
     * - event handlers
     *
     * ```
     * io.of("/orders").on("connection", (socket) => {
     *   socket.on("order:list", () => {});
     *   socket.on("order:create", () => {});
     * });
     *
     * io.of("/users").on("connection", (socket) => {
     *   socket.on("user:list", () => {});
     * });
     * ```
     *
     * - rooms
     *
     * ```
     * const orderNamespace = io.of("/orders");
     *
     * orderNamespace.on("connection", (socket) => {
     *   socket.join("room1");
     *   orderNamespace.to("room1").emit("hello");
     * });
     *
     * const userNamespace = io.of("/users");
     *
     * userNamespace.on("connection", (socket) => {
     *   socket.join("room1"); // distinct from the room in the "orders" namespace
     *   userNamespace.to("room1").emit("holà");
     * });
     * ```
     *
     * - middlewares
     *
     * ```
     * const orderNamespace = io.of("/orders");
     *
     * orderNamespace.use((socket, next) => {
     *   // ensure the socket has access to the "orders" namespace
     * });
     *
     * const userNamespace = io.of("/users");
     *
     * userNamespace.use((socket, next) => {
     *   // ensure the socket has access to the "users" namespace
     * });
     * ```
     */
    class Namespace extends typed_events_1.StrictEventEmitter {
      /**
       * Namespace constructor.
       *
       * @param server instance
       * @param name
       */
      constructor(server, name) {
        super();
        /**
         * A map of currently connected sockets.
         */
        this.sockets = new Map();
        /**
         * A map of currently connecting sockets.
         */
        this._preConnectSockets = new Map();
        this._fns = [];
        /** @private */
        this._ids = 0;
        this.server = server;
        this.name = name;
        this._initAdapter();
      }
      /**
       * Initializes the `Adapter` for this nsp.
       * Run upon changing adapter by `Server#adapter`
       * in addition to the constructor.
       *
       * @private
       */
      _initAdapter() {
        // @ts-ignore
        this.adapter = new (this.server.adapter())(this);
      }
      /**
       * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * myNamespace.use((socket, next) => {
       *   // ...
       *   next();
       * });
       *
       * @param fn - the middleware function
       */
      use(fn) {
        this._fns.push(fn);
        return this;
      }
      /**
       * Executes the middleware for an incoming client.
       *
       * @param socket - the socket that will get added
       * @param fn - last fn call in the middleware
       * @private
       */
      run(socket, fn) {
        if (!this._fns.length) return fn();
        const fns = this._fns.slice(0);
        function run(i) {
          fns[i](socket, err => {
            // upon error, short-circuit
            if (err) return fn(err);
            // if no middleware left, summon callback
            if (!fns[i + 1]) return fn();
            // go on to next
            run(i + 1);
          });
        }
        run(0);
      }
      /**
       * Targets a room when emitting.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * // the “foo” event will be broadcast to all connected clients in the “room-101” room
       * myNamespace.to("room-101").emit("foo", "bar");
       *
       * // with an array of rooms (a client will be notified at most once)
       * myNamespace.to(["room-101", "room-102"]).emit("foo", "bar");
       *
       * // with multiple chained calls
       * myNamespace.to("room-101").to("room-102").emit("foo", "bar");
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      to(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
      }
      /**
       * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * // disconnect all clients in the "room-101" room
       * myNamespace.in("room-101").disconnectSockets();
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      in(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).in(room);
      }
      /**
       * Excludes a room when emitting.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
       * myNamespace.except("room-101").emit("foo", "bar");
       *
       * // with an array of rooms
       * myNamespace.except(["room-101", "room-102"]).emit("foo", "bar");
       *
       * // with multiple chained calls
       * myNamespace.except("room-101").except("room-102").emit("foo", "bar");
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      except(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
      }
      /**
       * Adds a new client.
       *
       * @return {Socket}
       * @private
       */
      async _add(client, auth, fn) {
        let _a;
        debug('adding socket to nsp %s', this.name);
        const socket = await this._createSocket(client, auth);
        this._preConnectSockets.set(socket.id, socket);
        if (
          // @ts-ignore
          ((_a = this.server.opts.connectionStateRecovery) === null || _a === void 0 ? void 0 : _a.skipMiddlewares) &&
          socket.recovered &&
          client.conn.readyState === 'open'
        ) {
          return this._doConnect(socket, fn);
        }
        this.run(socket, err => {
          process.nextTick(() => {
            if (client.conn.readyState !== 'open') {
              debug('next called after client was closed - ignoring socket');
              socket._cleanup();
              return;
            }
            if (err) {
              debug('middleware error, sending CONNECT_ERROR packet to the client');
              socket._cleanup();
              if (client.conn.protocol === 3) {
                return socket._error(err.data || err.message);
              } else {
                return socket._error({
                  message: err.message,
                  data: err.data,
                });
              }
            }
            this._doConnect(socket, fn);
          });
        });
      }
      async _createSocket(client, auth) {
        const sessionId = auth.pid;
        const offset = auth.offset;
        if (
          // @ts-ignore
          this.server.opts.connectionStateRecovery &&
          typeof sessionId === 'string' &&
          typeof offset === 'string'
        ) {
          let session;
          try {
            session = await this.adapter.restoreSession(sessionId, offset);
          } catch (e) {
            debug('error while restoring session: %s', e);
          }
          if (session) {
            debug('connection state recovered for sid %s', session.sid);
            return new socket_1.Socket(this, client, auth, session);
          }
        }
        return new socket_1.Socket(this, client, auth);
      }
      _doConnect(socket, fn) {
        this._preConnectSockets.delete(socket.id);
        this.sockets.set(socket.id, socket);
        // it's paramount that the internal `onconnect` logic
        // fires before user-set events to prevent state order
        // violations (such as a disconnection before the connection
        // logic is complete)
        socket._onconnect();
        if (fn) fn(socket);
        // fire user-set events
        this.emitReserved('connect', socket);
        this.emitReserved('connection', socket);
      }
      /**
       * Removes a client. Called by each `Socket`.
       *
       * @private
       */
      _remove(socket) {
        this.sockets.delete(socket.id) || this._preConnectSockets.delete(socket.id);
      }
      /**
       * Emits to all connected clients.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * myNamespace.emit("hello", "world");
       *
       * // all serializable datastructures are supported (no need to call JSON.stringify)
       * myNamespace.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
       *
       * // with an acknowledgement from the clients
       * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
       *   if (err) {
       *     // some clients did not acknowledge the event in the given delay
       *   } else {
       *     console.log(responses); // one response per client
       *   }
       * });
       *
       * @return Always true
       */
      emit(ev, ...args) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).emit(ev, ...args);
      }
      /**
       * Sends a `message` event to all clients.
       *
       * This method mimics the WebSocket.send() method.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * myNamespace.send("hello");
       *
       * // this is equivalent to
       * myNamespace.emit("message", "hello");
       *
       * @return self
       */
      send(...args) {
        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.emit('message', ...args);
        return this;
      }
      /**
       * Sends a `message` event to all clients. Sends a `message` event. Alias of {@link send}.
       *
       * @return self
       */
      write(...args) {
        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.emit('message', ...args);
        return this;
      }
      /**
       * Sends a message to the other Socket.IO servers of the cluster.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * myNamespace.serverSideEmit("hello", "world");
       *
       * myNamespace.on("hello", (arg1) => {
       *   console.log(arg1); // prints "world"
       * });
       *
       * // acknowledgements (without binary content) are supported too:
       * myNamespace.serverSideEmit("ping", (err, responses) => {
       *  if (err) {
       *     // some servers did not acknowledge the event in the given delay
       *   } else {
       *     console.log(responses); // one response per server (except the current one)
       *   }
       * });
       *
       * myNamespace.on("ping", (cb) => {
       *   cb("pong");
       * });
       *
       * @param ev - the event name
       * @param args - an array of arguments, which may include an acknowledgement callback at the end
       */
      serverSideEmit(ev, ...args) {
        if (exports.RESERVED_EVENTS.has(ev)) {
          throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        args.unshift(ev);
        this.adapter.serverSideEmit(args);
        return true;
      }
      /**
       * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * try {
       *   const responses = await myNamespace.serverSideEmitWithAck("ping");
       *   console.log(responses); // one response per server (except the current one)
       * } catch (e) {
       *   // some servers did not acknowledge the event in the given delay
       * }
       *
       * @param ev - the event name
       * @param args - an array of arguments
       *
       * @return a Promise that will be fulfilled when all servers have acknowledged the event
       */
      serverSideEmitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
          args.push((err, responses) => {
            if (err) {
              err.responses = responses;
              return reject(err);
            } else {
              return resolve(responses);
            }
          });
          this.serverSideEmit(ev, ...args);
        });
      }
      /**
       * Called when a packet is received from another Socket.IO server
       *
       * @param args - an array of arguments, which may include an acknowledgement callback at the end
       *
       * @private
       */
      _onServerSideEmit(args) {
        super.emitUntyped.apply(this, args);
      }
      /**
       * Gets a list of clients.
       *
       * @deprecated this method will be removed in the next major release, please use {@link Namespace#serverSideEmit} or
       * {@link Namespace#fetchSockets} instead.
       */
      allSockets() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
      }
      /**
       * Sets the compress flag.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * myNamespace.compress(false).emit("hello");
       *
       * @param compress - if `true`, compresses the sending data
       * @return self
       */
      compress(compress) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(compress);
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
       * receive messages (because of network slowness or other issues, or because they’re connected through long polling
       * and is in the middle of a request-response cycle).
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * myNamespace.volatile.emit("hello"); // the clients may or may not receive it
       *
       * @return self
       */
      get volatile() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).volatile;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * // the “foo” event will be broadcast to all connected clients on this node
       * myNamespace.local.emit("foo", "bar");
       *
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      get local() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
      }
      /**
       * Adds a timeout in milliseconds for the next operation.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * myNamespace.timeout(1000).emit("some-event", (err, responses) => {
       *   if (err) {
       *     // some clients did not acknowledge the event in the given delay
       *   } else {
       *     console.log(responses); // one response per client
       *   }
       * });
       *
       * @param timeout
       */
      timeout(timeout) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).timeout(timeout);
      }
      /**
       * Returns the matching socket instances.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * // return all Socket instances
       * const sockets = await myNamespace.fetchSockets();
       *
       * // return all Socket instances in the "room1" room
       * const sockets = await myNamespace.in("room1").fetchSockets();
       *
       * for (const socket of sockets) {
       *   console.log(socket.id);
       *   console.log(socket.handshake);
       *   console.log(socket.rooms);
       *   console.log(socket.data);
       *
       *   socket.emit("hello");
       *   socket.join("room1");
       *   socket.leave("room2");
       *   socket.disconnect();
       * }
       */
      fetchSockets() {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
      }
      /**
       * Makes the matching socket instances join the specified rooms.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * // make all socket instances join the "room1" room
       * myNamespace.socketsJoin("room1");
       *
       * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
       * myNamespace.in("room1").socketsJoin(["room2", "room3"]);
       *
       * @param room - a room, or an array of rooms
       */
      socketsJoin(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
      }
      /**
       * Makes the matching socket instances leave the specified rooms.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * // make all socket instances leave the "room1" room
       * myNamespace.socketsLeave("room1");
       *
       * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
       * myNamespace.in("room1").socketsLeave(["room2", "room3"]);
       *
       * @param room - a room, or an array of rooms
       */
      socketsLeave(room) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
      }
      /**
       * Makes the matching socket instances disconnect.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * const myNamespace = io.of("/my-namespace");
       *
       * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
       * myNamespace.disconnectSockets();
       *
       * // make all socket instances in the "room1" room disconnect and close the underlying connections
       * myNamespace.in("room1").disconnectSockets(true);
       *
       * @param close - whether to close the underlying connection
       */
      disconnectSockets(close = false) {
        return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
      }
    }
    exports.Namespace = Namespace;

    /***/
  },

  /***/ 704: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Pair = __webpack_require__(6544);
    const YAMLMap = __webpack_require__(8741);
    const resolveProps = __webpack_require__(5300);
    const utilContainsNewline = __webpack_require__(1120);
    const utilFlowIndentCheck = __webpack_require__(2382);
    const utilMapIncludes = __webpack_require__(4752);

    const startColMsg = 'All mapping items must start at the same column';
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map = new NodeClass(ctx.schema);
      if (ctx.atRoot) ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
          indicator: 'explicit-key-ind',
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true,
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === 'block-seq')
              onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
            else if ('indent' in key && key.indent !== bm.indent) onError(offset, 'BAD_INDENT', startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map.comment) map.comment += '\n' + keyProps.comment;
              else map.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(
              key ?? start[start.length - 1],
              'MULTILINE_IMPLICIT_KEY',
              'Implicit keys need to be on a single line',
            );
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key
          ? composeNode(ctx, key, keyProps, onError)
          : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          indicator: 'map-value-ind',
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === 'block-scalar',
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === 'block-map' && !valueProps.hasNewline)
              onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(
                keyNode.range,
                'KEY_OVER_1024_CHARS',
                'The : indicator must be at most 1024 chars after the start of an implicit block mapping key',
              );
          }
          // value value
          const valueNode = value
            ? composeNode(ctx, value, valueProps, onError)
            : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          if (ctx.schema.compat) utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          // key with no value
          if (implicitKey)
            onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
          if (valueProps.comment) {
            if (keyNode.comment) keyNode.comment += '\n' + valueProps.comment;
            else keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset) onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
      map.range = [bm.offset, offset, commentEnd ?? offset];
      return map;
    }

    exports.resolveBlockMap = resolveBlockMap;

    /***/
  },

  /***/ 777: /***/ function (__unused_webpack_module, exports, __webpack_require__) {
    const __importDefault =
      (this && this.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.ParentNamespace = void 0;
    const namespace_1 = __webpack_require__(616);
    const socket_io_adapter_1 = __webpack_require__(8723);
    const debug_1 = __importDefault(__webpack_require__(1106));
    const debug = (0, debug_1.default)('socket.io:parent-namespace');
    /**
     * A parent namespace is a special {@link Namespace} that holds a list of child namespaces which were created either
     * with a regular expression or with a function.
     *
     * @example
     * const parentNamespace = io.of(/\/dynamic-\d+/);
     *
     * parentNamespace.on("connection", (socket) => {
     *   const childNamespace = socket.nsp;
     * }
     *
     * // will reach all the clients that are in one of the child namespaces, like "/dynamic-101"
     * parentNamespace.emit("hello", "world");
     *
     */
    class ParentNamespace extends namespace_1.Namespace {
      constructor(server) {
        super(server, '/_' + ParentNamespace.count++);
        this.children = new Set();
      }
      /**
       * @private
       */
      _initAdapter() {
        this.adapter = new ParentBroadcastAdapter(this);
      }
      emit(ev, ...args) {
        this.children.forEach(nsp => {
          nsp.emit(ev, ...args);
        });
        return true;
      }
      createChild(name) {
        debug('creating child namespace %s', name);
        const namespace = new namespace_1.Namespace(this.server, name);
        this['_fns'].forEach(fn => namespace.use(fn));
        this.listeners('connect').forEach(listener => namespace.on('connect', listener));
        this.listeners('connection').forEach(listener => namespace.on('connection', listener));
        this.children.add(namespace);
        if (this.server._opts.cleanupEmptyChildNamespaces) {
          const remove = namespace._remove;
          namespace._remove = socket => {
            remove.call(namespace, socket);
            if (namespace.sockets.size === 0) {
              debug('closing child namespace %s', name);
              namespace.adapter.close();
              this.server._nsps.delete(namespace.name);
              this.children.delete(namespace);
            }
          };
        }
        this.server._nsps.set(name, namespace);
        // @ts-ignore
        this.server.sockets.emitReserved('new_namespace', namespace);
        return namespace;
      }
      fetchSockets() {
        // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the
        // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but
        // the behavior for namespaces created with a function is less clear
        // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace
        // may exist on one node but not exist on another (since it is created upon client connection)
        throw new Error('fetchSockets() is not supported on parent namespaces');
      }
    }
    exports.ParentNamespace = ParentNamespace;
    ParentNamespace.count = 0;
    /**
     * A dummy adapter that only supports broadcasting to child (concrete) namespaces.
     * @private file
     */
    class ParentBroadcastAdapter extends socket_io_adapter_1.Adapter {
      broadcast(packet, opts) {
        this.nsp.children.forEach(nsp => {
          nsp.adapter.broadcast(packet, opts);
        });
      }
    }

    /***/
  },

  /***/ 810: /***/ (__unused_webpack_module, exports) => {
    /**
     * Stringify a CST document, token, or collection item
     *
     * Fair warning: This applies no validation whatsoever, and
     * simply concatenates the sources in their logical order.
     */
    const stringify = cst => ('type' in cst ? stringifyToken(cst) : stringifyItem(cst));
    function stringifyToken(token) {
      switch (token.type) {
        case 'block-scalar': {
          let res = '';
          for (const tok of token.props) res += stringifyToken(tok);
          return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
          let res = '';
          for (const item of token.items) res += stringifyItem(item);
          return res;
        }
        case 'flow-collection': {
          let res = token.start.source;
          for (const item of token.items) res += stringifyItem(item);
          for (const st of token.end) res += st.source;
          return res;
        }
        case 'document': {
          let res = stringifyItem(token);
          if (token.end) for (const st of token.end) res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ('end' in token && token.end) for (const st of token.end) res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = '';
      for (const st of start) res += st.source;
      if (key) res += stringifyToken(key);
      if (sep) for (const st of sep) res += st.source;
      if (value) res += stringifyToken(value);
      return res;
    }

    exports.stringify = stringify;

    /***/
  },

  /***/ 857: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('os');

    /***/
  },

  /***/ 902: /***/ module => {
    module.exports = { rE: '4.8.1' };

    /***/
  },

  /***/ 914: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Scalar = __webpack_require__(6364);
    const map = __webpack_require__(4304);
    const seq = __webpack_require__(581);

    function intIdentify(value) {
      return typeof value === 'bigint' || Number.isInteger(value);
    }
    const stringifyJSON = ({ value }) => JSON.stringify(value);
    const jsonScalars = [
      {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON,
      },
      {
        identify: value => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON,
      },
      {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true$|^false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON,
      },
      {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str, 10)),
        stringify: ({ value }) => (intIdentify(value) ? value.toString() : JSON.stringify(value)),
      },
      {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON,
      },
    ];
    const jsonError = {
      default: true,
      tag: '',
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      },
    };
    const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

    exports.schema = schema;

    /***/
  },

  /***/ 932: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('process');

    /***/
  },

  /***/ 1106: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    /**
     * Detect Electron renderer / nwjs process, which is node, but we should
     * treat as a browser.
     */

    if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
      module.exports = __webpack_require__(578);
    } else {
      module.exports = __webpack_require__(4200);
    }

    /***/
  },

  /***/ 1120: /***/ (__unused_webpack_module, exports) => {
    function containsNewline(key) {
      if (!key) return null;
      switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
          if (key.source.includes('\n')) return true;
          if (key.end) for (const st of key.end) if (st.type === 'newline') return true;
          return false;
        case 'flow-collection':
          for (const it of key.items) {
            for (const st of it.start) if (st.type === 'newline') return true;
            if (it.sep) for (const st of it.sep) if (st.type === 'newline') return true;
            if (containsNewline(it.key) || containsNewline(it.value)) return true;
          }
          return false;
        default:
          return true;
      }
    }

    exports.containsNewline = containsNewline;

    /***/
  },

  /***/ 1292: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const { InvalidArgumentError } = __webpack_require__(6729);

    class Argument {
      /**
       * Initialize a new command argument with the given name and description.
       * The default is that the argument is required, and you can explicitly
       * indicate this with <> around the name. Put [] around the name for an optional argument.
       *
       * @param {string} name
       * @param {string} [description]
       */

      constructor(name, description) {
        this.description = description || '';
        this.variadic = false;
        this.parseArg = undefined;
        this.defaultValue = undefined;
        this.defaultValueDescription = undefined;
        this.argChoices = undefined;

        switch (name[0]) {
          case '<': // e.g. <required>
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case '[': // e.g. [optional]
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }

        if (this._name.length > 3 && this._name.slice(-3) === '...') {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }

      /**
       * Return argument name.
       *
       * @return {string}
       */

      name() {
        return this._name;
      }

      /**
       * @package
       */

      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }

        return previous.concat(value);
      }

      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Argument}
       */

      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }

      /**
       * Set the custom handler for processing CLI command arguments into argument values.
       *
       * @param {Function} [fn]
       * @return {Argument}
       */

      argParser(fn) {
        this.parseArg = fn;
        return this;
      }

      /**
       * Only allow argument value to be one of choices.
       *
       * @param {string[]} values
       * @return {Argument}
       */

      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }

      /**
       * Make argument required.
       *
       * @returns {Argument}
       */
      argRequired() {
        this.required = true;
        return this;
      }

      /**
       * Make argument optional.
       *
       * @returns {Argument}
       */
      argOptional() {
        this.required = false;
        return this;
      }
    }

    /**
     * Takes an argument and returns its human readable equivalent for help usage.
     *
     * @param {Argument} arg
     * @return {string}
     * @private
     */

    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

      return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';
    }

    exports.Argument = Argument;
    exports.humanReadableArgName = humanReadableArgName;

    /***/
  },

  /***/ 1307: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const identity = __webpack_require__(7182);
    const Scalar = __webpack_require__(6364);
    const stringify = __webpack_require__(8767);
    const stringifyComment = __webpack_require__(3774);

    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const {
        allNullValues,
        doc,
        indent,
        indentStep,
        options: { commentString, indentSeq, simpleKeys },
      } = ctx;
      let keyComment = (identity.isNode(key) && key.comment) || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (identity.isCollection(key) || (!identity.isNode(key) && typeof key === 'object')) {
          const msg = 'With simple keys, collection cannot be used as a key value';
          throw new Error(msg);
        }
      }
      let explicitKey =
        !simpleKeys &&
        (!key ||
          (keyComment && value == null && !ctx.inFlow) ||
          identity.isCollection(key) ||
          (identity.isScalar(key)
            ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL
            : typeof key === 'object'));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep,
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(
        key,
        ctx,
        () => (keyCommentDone = true),
        () => (chompKeep = true),
      );
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys) throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment) onComment();
          return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
      } else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep) onChompKeep();
        return str;
      }
      if (keyCommentDone) keyComment = null;
      if (explicitKey) {
        if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment) str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object') value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value)) ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (
        !indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        identity.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor
      ) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(
        value,
        ctx,
        () => (valueCommentDone = true),
        () => (chompKeep = true),
      );
      let ws = ' ';
      if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
          const cs = commentString(vcb);
          ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
          if (ws === '\n') ws = '\n\n';
        } else {
          ws += `\n${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === '&' || vs0 === '!')) {
            let sp0 = valueStr.indexOf(' ');
            if (vs0 === '&' && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === '!') {
              sp0 = valueStr.indexOf(' ', sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0) hasPropsLine = true;
          }
          if (!hasPropsLine) ws = `\n${ctx.indent}`;
        }
      } else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment) onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }

    exports.stringifyPair = stringifyPair;

    /***/
  },

  /***/ 1322: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const cst = __webpack_require__(7062);

    /*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
    function isEmpty(ch) {
      switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
          return true;
        default:
          return false;
      }
    }
    const hexDigits = new Set('0123456789ABCDEFabcdef');
    const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    const flowIndicatorChars = new Set(',[]{}');
    const invalidAnchorChars = new Set(' ,[]{}\n\r\t');
    const isNotAnchorChar = ch => !ch || invalidAnchorChars.has(ch);
    /**
     * Splits an input string into lexical tokens, i.e. smaller strings that are
     * easily identifiable by `tokens.tokenType()`.
     *
     * Lexing starts always in a "stream" context. Incomplete input may be buffered
     * until a complete token can be emitted.
     *
     * In addition to slices of the original input, the following control characters
     * may also be emitted:
     *
     * - `\x02` (Start of Text): A document starts with the next token
     * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
     * - `\x1f` (Unit Separator): Next token is a scalar value
     * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
     */
    class Lexer {
      constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== 'string') throw TypeError('source is not a string');
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1))) next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t') ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n') return true;
        if (ch === '\r') return this.buffer[i + 1] === '\n';
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === ' ') ch = this.buffer[++indent + offset];
          if (ch === '\r') {
            const next = this.buffer[indent + offset + 1];
            if (next === '\n' || (!next && !this.atEnd)) return offset + indent + 1;
          }
          return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd) ? offset + indent : -1;
        }
        if (ch === '-' || ch === '.') {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3])) return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
          end = this.buffer.indexOf('\n', this.pos);
          this.lineEndPos = end;
        }
        if (end === -1) return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r') end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case 'stream':
            return yield* this.parseStream();
          case 'line-start':
            return yield* this.parseLineStart();
          case 'block-start':
            return yield* this.parseBlockStart();
          case 'doc':
            return yield* this.parseDocument();
          case 'flow':
            return yield* this.parseFlowCollection();
          case 'quoted-scalar':
            return yield* this.parseQuotedScalar();
          case 'block-scalar':
            return yield* this.parseBlockScalar();
          case 'plain-scalar':
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null) return this.setNext('stream');
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === '%') {
          let dirEnd = line.length;
          let cs = line.indexOf('#');
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === ' ' || ch === '\t') {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf('#', cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === ' ' || ch === '\t') dirEnd -= 1;
            else break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n); // possible comment
          this.pushNewline();
          return 'stream';
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd) return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
          if (!this.atEnd && !this.hasChars(4)) return this.setNext('line-start');
          const s = this.peek(3);
          if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === '---' ? 'doc' : 'stream';
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1))) this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd) return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return 'doc';
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null) return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case '#':
            yield* this.pushCount(line.length - n);
          // fallthrough
          case undefined:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case '{':
          case '[':
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return 'flow';
          case '}':
          case ']':
            // this is an error
            yield* this.pushCount(1);
            return 'doc';
          case '*':
            yield* this.pushUntil(isNotAnchorChar);
            return 'doc';
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case '|':
          case '>':
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null) return this.setNext('flow');
        if (
          (indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
          (indent === 0 && (line.startsWith('---') || line.startsWith('...')) && isEmpty(line[3]))
        ) {
          // Allowing for the terminal ] or } at the same (rather than greater)
          // indent level as the initial [ or { is technically invalid, but
          // failing here would be surprising to users.
          const atFlowEndMarker =
            indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === ']' || line[0] === '}');
          if (!atFlowEndMarker) {
            // this is an error
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ',') {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case undefined:
            return 'flow';
          case '#':
            yield* this.pushCount(line.length - n);
            return 'flow';
          case '{':
          case '[':
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return 'flow';
          case '}':
          case ']':
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? 'flow' : 'doc';
          case '*':
            yield* this.pushUntil(isNotAnchorChar);
            return 'flow';
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ':': {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ',') {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return 'flow';
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'") end = this.buffer.indexOf("'", end + 2);
        } else {
          // double-quote
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === '\\') n += 1;
            if (n % 2 === 0) break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1) break;
            nl = qb.indexOf('\n', cs);
          }
          if (nl !== -1) {
            // this is an error caused by an unexpected unindent
            end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd) return this.setNext('quoted-scalar');
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === '+') this.blockScalarKeep = true;
          else if (ch > '0' && ch <= '9') this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== '-') break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
      }
      *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
          switch (ch) {
            case ' ':
              indent += 1;
              break;
            case '\n':
              nl = i;
              indent = 0;
              break;
            case '\r': {
              const next = this.buffer[i + 1];
              if (!next && !this.atEnd) return this.setNext('block-scalar');
              if (next === '\n') break;
            } // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd) return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1) this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1) break;
            nl = this.buffer.indexOf('\n', cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd) return this.setNext('block-scalar');
            nl = this.buffer.length;
          }
        }
        // Trailing insufficiently indented tabs are invalid.
        // To catch that during parsing, we include them in the block scalar value.
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === ' ') ch = this.buffer[++i];
        if (ch === '\t') {
          while (ch === '\t' || ch === ' ' || ch === '\r' || ch === '\n') ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i = nl - 1;
            let ch = this.buffer[i];
            if (ch === '\r') ch = this.buffer[--i];
            const lastChar = i; // Drop the line if last char not more indented
            while (ch === ' ') ch = this.buffer[--i];
            if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar) nl = i;
            else break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
          if (ch === ':') {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next))) break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === '\r') {
              if (next === '\n') {
                i += 1;
                ch = '\n';
                next = this.buffer[i + 1];
              } else end = i;
            }
            if (next === '#' || (inFlow && flowIndicatorChars.has(next))) break;
            if (ch === '\n') {
              const cs = this.continueScalar(i + 1);
              if (cs === -1) break;
              i = Math.max(i, cs - 2); // to advance, but still account for ' #'
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch)) break;
            end = i;
          }
        }
        if (!ch && !this.atEnd) return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty) yield '';
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case '!':
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case '&':
            return (
              (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators())
            );
          case '-': // this is an error
          case '?': // this is an error outside flow collections
          case ':': {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {
              if (!inFlow) this.indentNext = this.indentValue + 1;
              else if (this.flowKey) this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === '<') {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== '>') ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch)) ch = this.buffer[++i];
            else if (ch === '%' && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[(i += 3)];
            } else break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n') return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n') return yield* this.pushCount(2);
        else return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch)) ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    }

    exports.Lexer = Lexer;

    /***/
  },

  /***/ 1324: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const __dirname = __webpack_fileURLToPath__(import.meta.url + '/..').slice(0, -1);

    try {
      module.exports = __webpack_require__(5173)(__dirname);
    } catch (e) {
      module.exports = __webpack_require__(2668);
    }

    /***/
  },

  /***/ 1402: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const stringifyNumber = __webpack_require__(2490);

    const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === '-' || sign === '+') offset += 1;
      str = str.substring(offset).replace(/_/g, '');
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
      }
      const n = parseInt(str, radix);
      return sign === '-' ? -1 * n : n;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    const intBin = {
      identify: intIdentify,
      default: true,
      tag: 'tag:yaml.org,2002:int',
      format: 'BIN',
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: node => intStringify(node, 2, '0b'),
    };
    const intOct = {
      identify: intIdentify,
      default: true,
      tag: 'tag:yaml.org,2002:int',
      format: 'OCT',
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: node => intStringify(node, 8, '0'),
    };
    const int = {
      identify: intIdentify,
      default: true,
      tag: 'tag:yaml.org,2002:int',
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber,
    };
    const intHex = {
      identify: intIdentify,
      default: true,
      tag: 'tag:yaml.org,2002:int',
      format: 'HEX',
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: node => intStringify(node, 16, '0x'),
    };

    exports.int = int;
    exports.intBin = intBin;
    exports.intHex = intHex;
    exports.intOct = intOct;

    /***/
  },

  /***/ 1421: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('node:child_process');

    /***/
  },

  /***/ 1490: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const { InvalidArgumentError } = __webpack_require__(6729);

    class Option {
      /**
       * Initialize a new `Option` with the given `flags` and `description`.
       *
       * @param {string} flags
       * @param {string} [description]
       */

      constructor(flags, description) {
        this.flags = flags;
        this.description = description || '';

        this.required = flags.includes('<'); // A value must be supplied when the option is specified.
        this.optional = flags.includes('['); // A value is optional when the option is specified.
        // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument
        this.variadic = /\w\.\.\.[>\]]$/.test(flags); // The option can take multiple values.
        this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag; // May be a short flag, undefined, or even a long flag (if option has two long flags).
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith('--no-');
        }
        this.defaultValue = undefined;
        this.defaultValueDescription = undefined;
        this.presetArg = undefined;
        this.envVar = undefined;
        this.parseArg = undefined;
        this.hidden = false;
        this.argChoices = undefined;
        this.conflictsWith = [];
        this.implied = undefined;
      }

      /**
       * Set the default value, and optionally supply the description to be displayed in the help.
       *
       * @param {*} value
       * @param {string} [description]
       * @return {Option}
       */

      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }

      /**
       * Preset to use when option used without option-argument, especially optional but also boolean and negated.
       * The custom processing (parseArg) is called.
       *
       * @example
       * new Option('--color').default('GREYSCALE').preset('RGB');
       * new Option('--donate [amount]').preset('20').argParser(parseFloat);
       *
       * @param {*} arg
       * @return {Option}
       */

      preset(arg) {
        this.presetArg = arg;
        return this;
      }

      /**
       * Add option name(s) that conflict with this option.
       * An error will be displayed if conflicting options are found during parsing.
       *
       * @example
       * new Option('--rgb').conflicts('cmyk');
       * new Option('--js').conflicts(['ts', 'jsx']);
       *
       * @param {(string | string[])} names
       * @return {Option}
       */

      conflicts(names) {
        this.conflictsWith = this.conflictsWith.concat(names);
        return this;
      }

      /**
       * Specify implied option values for when this option is set and the implied options are not.
       *
       * The custom processing (parseArg) is not called on the implied values.
       *
       * @example
       * program
       *   .addOption(new Option('--log', 'write logging information to file'))
       *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
       *
       * @param {object} impliedOptionValues
       * @return {Option}
       */
      implies(impliedOptionValues) {
        let newImplied = impliedOptionValues;
        if (typeof impliedOptionValues === 'string') {
          // string is not documented, but easy mistake and we can do what user probably intended.
          newImplied = { [impliedOptionValues]: true };
        }
        this.implied = Object.assign(this.implied || {}, newImplied);
        return this;
      }

      /**
       * Set environment variable to check for option value.
       *
       * An environment variable is only used if when processed the current option value is
       * undefined, or the source of the current value is 'default' or 'config' or 'env'.
       *
       * @param {string} name
       * @return {Option}
       */

      env(name) {
        this.envVar = name;
        return this;
      }

      /**
       * Set the custom handler for processing CLI option arguments into option values.
       *
       * @param {Function} [fn]
       * @return {Option}
       */

      argParser(fn) {
        this.parseArg = fn;
        return this;
      }

      /**
       * Whether the option is mandatory and must have a value after parsing.
       *
       * @param {boolean} [mandatory=true]
       * @return {Option}
       */

      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }

      /**
       * Hide option in help.
       *
       * @param {boolean} [hide=true]
       * @return {Option}
       */

      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }

      /**
       * @package
       */

      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }

        return previous.concat(value);
      }

      /**
       * Only allow option value to be one of choices.
       *
       * @param {string[]} values
       * @return {Option}
       */

      choices(values) {
        this.argChoices = values.slice();
        this.parseArg = (arg, previous) => {
          if (!this.argChoices.includes(arg)) {
            throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }

      /**
       * Return option name.
       *
       * @return {string}
       */

      name() {
        if (this.long) {
          return this.long.replace(/^--/, '');
        }
        return this.short.replace(/^-/, '');
      }

      /**
       * Return option name, in a camelcase format that can be used
       * as an object attribute key.
       *
       * @return {string}
       */

      attributeName() {
        if (this.negate) {
          return camelcase(this.name().replace(/^no-/, ''));
        }
        return camelcase(this.name());
      }

      /**
       * Check if `arg` matches the short or long flag.
       *
       * @param {string} arg
       * @return {boolean}
       * @package
       */

      is(arg) {
        return this.short === arg || this.long === arg;
      }

      /**
       * Return whether a boolean option.
       *
       * Options are one of boolean, negated, required argument, or optional argument.
       *
       * @return {boolean}
       * @package
       */

      isBoolean() {
        return !this.required && !this.optional && !this.negate;
      }
    }

    /**
     * This class is to make it easier to work with dual options, without changing the existing
     * implementation. We support separate dual options for separate positive and negative options,
     * like `--build` and `--no-build`, which share a single option value. This works nicely for some
     * use cases, but is tricky for others where we want separate behaviours despite
     * the single shared option value.
     */
    class DualOptions {
      /**
       * @param {Option[]} options
       */
      constructor(options) {
        this.positiveOptions = new Map();
        this.negativeOptions = new Map();
        this.dualOptions = new Set();
        options.forEach(option => {
          if (option.negate) {
            this.negativeOptions.set(option.attributeName(), option);
          } else {
            this.positiveOptions.set(option.attributeName(), option);
          }
        });
        this.negativeOptions.forEach((value, key) => {
          if (this.positiveOptions.has(key)) {
            this.dualOptions.add(key);
          }
        });
      }

      /**
       * Did the value come from the option, and not from possible matching dual option?
       *
       * @param {*} value
       * @param {Option} option
       * @returns {boolean}
       */
      valueFromOption(value, option) {
        const optionKey = option.attributeName();
        if (!this.dualOptions.has(optionKey)) return true;

        // Use the value to deduce if (probably) came from the option.
        const preset = this.negativeOptions.get(optionKey).presetArg;
        const negativeValue = preset !== undefined ? preset : false;
        return option.negate === (negativeValue === value);
      }
    }

    /**
     * Convert string from kebab-case to camelCase.
     *
     * @param {string} str
     * @return {string}
     * @private
     */

    function camelcase(str) {
      return str.split('-').reduce((str, word) => {
        return str + word[0].toUpperCase() + word.slice(1);
      });
    }

    /**
     * Split the short and long flag out of something like '-m,--mixed <value>'
     *
     * @private
     */

    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      // short flag, single dash and single character
      const shortFlagExp = /^-[^-]$/;
      // long flag, double dash and at least one character
      const longFlagExp = /^--[^-]/;

      const flagParts = flags.split(/[ |,]+/).concat('guard');
      // Normal is short and/or long.
      if (shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
      if (longFlagExp.test(flagParts[0])) longFlag = flagParts.shift();
      // Long then short. Rarely used but fine.
      if (!shortFlag && shortFlagExp.test(flagParts[0])) shortFlag = flagParts.shift();
      // Allow two long flags, like '--ws, --workspace'
      // This is the supported way to have a shortish option flag.
      if (!shortFlag && longFlagExp.test(flagParts[0])) {
        shortFlag = longFlag;
        longFlag = flagParts.shift();
      }

      // Check for unprocessed flag. Fail noisily rather than silently ignore.
      if (flagParts[0].startsWith('-')) {
        const unsupportedFlag = flagParts[0];
        const baseError = `option creation failed due to '${unsupportedFlag}' in option flags '${flags}'`;
        if (/^-[^-][^-]/.test(unsupportedFlag))
          throw new Error(
            `${baseError}
- a short flag is a single dash and a single character
  - either use a single dash and a single character (for a short flag)
  - or use a double dash for a long option (and can have two, like '--ws, --workspace')`,
          );
        if (shortFlagExp.test(unsupportedFlag))
          throw new Error(`${baseError}
- too many short flags`);
        if (longFlagExp.test(unsupportedFlag))
          throw new Error(`${baseError}
- too many long flags`);

        throw new Error(`${baseError}
- unrecognised flag format`);
      }
      if (shortFlag === undefined && longFlag === undefined)
        throw new Error(`option creation failed due to no flags found in '${flags}'.`);

      return { shortFlag, longFlag };
    }

    exports.Option = Option;
    exports.DualOptions = DualOptions;

    /***/
  },

  /***/ 1533: /***/ module => {
    module.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf('--');
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };

    /***/
  },

  /***/ 1610: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const { isUtf8 } = __webpack_require__(181);

    //
    // Allowed token characters:
    //
    // '!', '#', '$', '%', '&', ''', '*', '+', '-',
    // '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
    //
    // tokenChars[32] === 0 // ' '
    // tokenChars[33] === 1 // '!'
    // tokenChars[34] === 0 // '"'
    // ...
    //
    // prettier-ignore
    const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

    /**
     * Checks if a status code is allowed in a close frame.
     *
     * @param {Number} code The status code
     * @return {Boolean} `true` if the status code is valid, else `false`
     * @public
     */
    function isValidStatusCode(code) {
      return (
        (code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006) ||
        (code >= 3000 && code <= 4999)
      );
    }

    /**
     * Checks if a given buffer contains only correct UTF-8.
     * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
     * Markus Kuhn.
     *
     * @param {Buffer} buf The buffer to check
     * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
     * @public
     */
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;

      while (i < len) {
        if ((buf[i] & 0x80) === 0) {
          // 0xxxxxxx
          i++;
        } else if ((buf[i] & 0xe0) === 0xc0) {
          // 110xxxxx 10xxxxxx
          if (
            i + 1 === len ||
            (buf[i + 1] & 0xc0) !== 0x80 ||
            (buf[i] & 0xfe) === 0xc0 // Overlong
          ) {
            return false;
          }

          i += 2;
        } else if ((buf[i] & 0xf0) === 0xe0) {
          // 1110xxxx 10xxxxxx 10xxxxxx
          if (
            i + 2 >= len ||
            (buf[i + 1] & 0xc0) !== 0x80 ||
            (buf[i + 2] & 0xc0) !== 0x80 ||
            (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
            (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
          ) {
            return false;
          }

          i += 3;
        } else if ((buf[i] & 0xf8) === 0xf0) {
          // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
          if (
            i + 3 >= len ||
            (buf[i + 1] & 0xc0) !== 0x80 ||
            (buf[i + 2] & 0xc0) !== 0x80 ||
            (buf[i + 3] & 0xc0) !== 0x80 ||
            (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
            (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
            buf[i] > 0xf4 // > U+10FFFF
          ) {
            return false;
          }

          i += 4;
        } else {
          return false;
        }
      }

      return true;
    }

    module.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars,
    };

    if (isUtf8) {
      module.exports.isValidUTF8 = function (buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = __webpack_require__(1324);

        module.exports.isValidUTF8 = function (buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
        // Continue regardless of the error.
      }
    }

    /***/
  },

  /***/ 1708: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('node:process');

    /***/
  },

  /***/ 1744: /***/ (__unused_webpack_module, exports) => {
    const BREAK = Symbol('break visit');
    const SKIP = Symbol('skip children');
    const REMOVE = Symbol('remove item');
    /**
     * Apply a visitor to a CST document or item.
     *
     * Walks through the tree (depth-first) starting from the root, calling a
     * `visitor` function with two arguments when entering each item:
     *   - `item`: The current item, which included the following members:
     *     - `start: SourceToken[]` – Source tokens before the key or value,
     *       possibly including its anchor or tag.
     *     - `key?: Token | null` – Set for pair values. May then be `null`, if
     *       the key before the `:` separator is empty.
     *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
     *       which should include the `:` map value indicator if `value` is set.
     *     - `value?: Token` – The value of a sequence item, or of a map pair.
     *   - `path`: The steps from the root to the current node, as an array of
     *     `['key' | 'value', number]` tuples.
     *
     * The return value of the visitor may be used to control the traversal:
     *   - `undefined` (default): Do nothing and continue
     *   - `visit.SKIP`: Do not visit the children of this token, continue with
     *      next sibling
     *   - `visit.BREAK`: Terminate traversal completely
     *   - `visit.REMOVE`: Remove the current item, then continue with the next one
     *   - `number`: Set the index of the next step. This is useful especially if
     *     the index of the current token has changed.
     *   - `function`: Define the next visitor for this item. After the original
     *     visitor is called on item entry, next visitors are called after handling
     *     a non-empty `key` and when exiting the item.
     */
    function visit(cst, visitor) {
      if ('type' in cst && cst.type === 'document') cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */
    visit.BREAK = BREAK;
    /** Do not visit the children of the current item */
    visit.SKIP = SKIP;
    /** Remove the current item */
    visit.REMOVE = REMOVE;
    /** Find the item at `path` from `cst` as the root */
    visit.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && 'items' in tok) {
          item = tok.items[index];
        } else return undefined;
      }
      return item;
    };
    /**
     * Get the immediate parent collection of the item at `path` from `cst` as the root.
     *
     * Throws an error if the collection is not found, which should never happen if the item itself exists.
     */
    visit.parentCollection = (cst, path) => {
      const parent = visit.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && 'items' in coll) return coll;
      throw new Error('Parent collection not found');
    };
    function _visit(path, item, visitor) {
      let ctrl = visitor(item, path);
      if (typeof ctrl === 'symbol') return ctrl;
      for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === 'number') i = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === 'function' && field === 'key') ctrl = ctrl(item, path);
        }
      }
      return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
    }

    exports.visit = visit;

    /***/
  },

  /***/ 1882: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    /*!
     * negotiator
     * Copyright(c) 2012 Federico Romero
     * Copyright(c) 2012-2014 Isaac Z. Schlueter
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    const preferredCharsets = __webpack_require__(8958);
    const preferredEncodings = __webpack_require__(8417);
    const preferredLanguages = __webpack_require__(2338);
    const preferredMediaTypes = __webpack_require__(5434);

    /**
     * Module exports.
     * @public
     */

    module.exports = Negotiator;
    module.exports.Negotiator = Negotiator;

    /**
     * Create a Negotiator instance from a request.
     * @param {object} request
     * @public
     */

    function Negotiator(request) {
      if (!(this instanceof Negotiator)) {
        return new Negotiator(request);
      }

      this.request = request;
    }

    Negotiator.prototype.charset = function charset(available) {
      const set = this.charsets(available);
      return set && set[0];
    };

    Negotiator.prototype.charsets = function charsets(available) {
      return preferredCharsets(this.request.headers['accept-charset'], available);
    };

    Negotiator.prototype.encoding = function encoding(available) {
      const set = this.encodings(available);
      return set && set[0];
    };

    Negotiator.prototype.encodings = function encodings(available) {
      return preferredEncodings(this.request.headers['accept-encoding'], available);
    };

    Negotiator.prototype.language = function language(available) {
      const set = this.languages(available);
      return set && set[0];
    };

    Negotiator.prototype.languages = function languages(available) {
      return preferredLanguages(this.request.headers['accept-language'], available);
    };

    Negotiator.prototype.mediaType = function mediaType(available) {
      const set = this.mediaTypes(available);
      return set && set[0];
    };

    Negotiator.prototype.mediaTypes = function mediaTypes(available) {
      return preferredMediaTypes(this.request.headers.accept, available);
    };

    // Backwards compatibility
    Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
    Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
    Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
    Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
    Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
    Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
    Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
    Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

    /***/
  },

  /***/ 1976: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    /*!
     * mime-types
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module dependencies.
     * @private
     */

    const db = __webpack_require__(6713);
    const extname = __webpack_require__(6928).extname;

    /**
     * Module variables.
     * @private
     */

    const EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    const TEXT_TYPE_REGEXP = /^text\//i;

    /**
     * Module exports.
     * @public
     */

    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = Object.create(null);
    exports.lookup = lookup;
    exports.types = Object.create(null);

    // Populate the extensions/types maps
    populateMaps(exports.extensions, exports.types);

    /**
     * Get the default charset for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */

    function charset(type) {
      if (!type || typeof type !== 'string') {
        return false;
      }

      // TODO: use media-typer
      const match = EXTRACT_TYPE_REGEXP.exec(type);
      const mime = match && db[match[1].toLowerCase()];

      if (mime && mime.charset) {
        return mime.charset;
      }

      // default text/* to utf-8
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
      }

      return false;
    }

    /**
     * Create a full Content-Type header given a MIME type or extension.
     *
     * @param {string} str
     * @return {boolean|string}
     */

    function contentType(str) {
      // TODO: should this even be in this module?
      if (!str || typeof str !== 'string') {
        return false;
      }

      let mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;

      if (!mime) {
        return false;
      }

      // TODO: use content-type or other module
      if (mime.indexOf('charset') === -1) {
        const charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
      }

      return mime;
    }

    /**
     * Get the default extension for a MIME type.
     *
     * @param {string} type
     * @return {boolean|string}
     */

    function extension(type) {
      if (!type || typeof type !== 'string') {
        return false;
      }

      // TODO: use media-typer
      const match = EXTRACT_TYPE_REGEXP.exec(type);

      // get extensions
      const exts = match && exports.extensions[match[1].toLowerCase()];

      if (!exts || !exts.length) {
        return false;
      }

      return exts[0];
    }

    /**
     * Lookup the MIME type for a file path/extension.
     *
     * @param {string} path
     * @return {boolean|string}
     */

    function lookup(path) {
      if (!path || typeof path !== 'string') {
        return false;
      }

      // get the extension ("ext" or ".ext" or full path)
      const extension = extname('x.' + path)
        .toLowerCase()
        .substr(1);

      if (!extension) {
        return false;
      }

      return exports.types[extension] || false;
    }

    /**
     * Populate the extensions and types maps.
     * @private
     */

    function populateMaps(extensions, types) {
      // source preference (least -> most)
      const preference = ['nginx', 'apache', undefined, 'iana'];

      Object.keys(db).forEach(function forEachMimeType(type) {
        const mime = db[type];
        const exts = mime.extensions;

        if (!exts || !exts.length) {
          return;
        }

        // mime -> extensions
        extensions[type] = exts;

        // extension -> mime
        for (let i = 0; i < exts.length; i++) {
          const extension = exts[i];

          if (types[extension]) {
            const from = preference.indexOf(db[types[extension]].source);
            const to = preference.indexOf(mime.source);

            if (
              types[extension] !== 'application/octet-stream' &&
              (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))
            ) {
              // skip the remapping
              continue;
            }
          }

          // set the extension -> mime
          types[extension] = type;
        }
      });
    }

    /***/
  },

  /***/ 1978: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.WebSocket = void 0;
    const transport_1 = __webpack_require__(2879);
    const debug_1 = __webpack_require__(1106);
    const debug = (0, debug_1.default)('engine:ws');
    class WebSocket extends transport_1.Transport {
      /**
       * WebSocket transport
       *
       * @param req
       */
      constructor(req) {
        super(req);
        this.writable = false;
        this.perMessageDeflate = null;
      }
      /**
       * Transport name
       */
      get name() {
        return 'websocket';
      }
      /**
       * Advertise upgrade support.
       */
      get handlesUpgrades() {
        return true;
      }
      /**
       * Writes a packet payload.
       *
       * @param {Array} packets
       * @private
       */
      send(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const isLast = i + 1 === packets.length;
          const send = data => {
            const isBinary = typeof data !== 'string';
            const compress = this.perMessageDeflate && Buffer.byteLength(data) > this.perMessageDeflate.threshold;
            debug('writing "%s"', data);
            this.socket.send(data, isBinary, compress);
            if (isLast) {
              this.emit('drain');
              this.writable = true;
              this.emit('ready');
            }
          };
          if (packet.options && typeof packet.options.wsPreEncoded === 'string') {
            send(packet.options.wsPreEncoded);
          } else {
            this.parser.encodePacket(packet, this.supportsBinary, send);
          }
        }
      }
      /**
       * Closes the transport.
       *
       * @private
       */
      doClose(fn) {
        debug('closing');
        fn && fn();
        // call fn first since socket.end() immediately emits a "close" event
        this.socket.end();
      }
    }
    exports.WebSocket = WebSocket;

    /***/
  },

  /***/ 2016: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const createNode = __webpack_require__(6421);
    const stringifyCollection = __webpack_require__(7515);
    const Collection = __webpack_require__(5920);
    const identity = __webpack_require__(7182);
    const Scalar = __webpack_require__(6364);
    const toJS = __webpack_require__(9126);

    class YAMLSeq extends Collection.Collection {
      static get tagName() {
        return 'tag:yaml.org,2002:seq';
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number') return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number') return undefined;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number') throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value)) prev.value = value;
        else this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate) ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items) seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: '- ',
          flowChars: { start: '[', end: ']' },
          itemIndent: (ctx.indent || '') + '  ',
          onChompKeep,
          onComment,
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === 'function') {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, undefined, ctx));
          }
        }
        return seq;
      }
    }
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === 'string') idx = Number(idx);
      return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }

    exports.YAMLSeq = YAMLSeq;

    /***/
  },

  /***/ 2018: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('tty');

    /***/
  },

  /***/ 2203: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('stream');

    /***/
  },

  /***/ 2216: /***/ (__unused_webpack_module, exports) => {
    const FOLD_FLOW = 'flow';
    const FOLD_BLOCK = 'block';
    const FOLD_QUOTED = 'quoted';
    /**
     * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
     * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
     * terminated with `\n` and started with `indent`.
     */
    function foldFlowLines(
      text,
      indent,
      mode = 'flow',
      { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {},
    ) {
      if (!lineWidth || lineWidth < 0) return text;
      if (lineWidth < minContentWidth) minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep) return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth)) folds.push(0);
        else end = lineWidth - indentAtStart;
      }
      let split = undefined;
      let prev = undefined;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1) end = i + endStep;
      }
      for (let ch; (ch = text[(i += 1)]); ) {
        if (mode === FOLD_QUOTED && ch === '\\') {
          escStart = i;
          switch (text[i + 1]) {
            case 'x':
              i += 3;
              break;
            case 'u':
              i += 5;
              break;
            case 'U':
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === '\n') {
          if (mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text, i, indent.length);
          end = i + indent.length + endStep;
          split = undefined;
        } else {
          if (ch === ' ' && prev && prev !== ' ' && prev !== '\n' && prev !== '\t') {
            // space surrounded by non-space can be replaced with newline + indent
            const next = text[i + 1];
            if (next && next !== ' ' && next !== '\n' && next !== '\t') split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = undefined;
            } else if (mode === FOLD_QUOTED) {
              // white-space collected at end may stretch past lineWidth
              while (prev === ' ' || prev === '\t') {
                prev = ch;
                ch = text[(i += 1)];
                overflow = true;
              }
              // Account for newline escape, but don't break preceding escape
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              // Bail out if lineWidth & minContentWidth are shorter than an escape string
              if (escapedFolds[j]) return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = undefined;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow) onOverflow();
      if (folds.length === 0) return text;
      if (onFold) onFold();
      let res = text.slice(0, folds[0]);
      for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0) res = `\n${indent}${text.slice(0, end)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold]) res += `${text[fold]}\\`;
          res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
      }
      return res;
    }
    /**
     * Presumes `i + 1` is at the start of a line
     * @returns index of last newline in more-indented block
     */
    function consumeMoreIndentedLines(text, i, indent) {
      let end = i;
      let start = i + 1;
      let ch = text[start];
      while (ch === ' ' || ch === '\t') {
        if (i < start + indent) {
          ch = text[++i];
        } else {
          do {
            ch = text[++i];
          } while (ch && ch !== '\n');
          end = i;
          start = i + 1;
          ch = text[start];
        }
      }
      return end;
    }

    exports.FOLD_BLOCK = FOLD_BLOCK;
    exports.FOLD_FLOW = FOLD_FLOW;
    exports.FOLD_QUOTED = FOLD_QUOTED;
    exports.foldFlowLines = foldFlowLines;

    /***/
  },

  /***/ 2313: /***/ module => {
    /*! https://mths.be/utf8js v2.1.2 by @mathias */
    const stringFromCharCode = String.fromCharCode;
    // Taken from https://mths.be/punycode
    function ucs2decode(string) {
      const output = [];
      let counter = 0;
      const length = string.length;
      let value;
      let extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 0xd800 && value <= 0xdbff && counter < length) {
          // high surrogate, and there is a next character
          extra = string.charCodeAt(counter++);
          if ((extra & 0xfc00) == 0xdc00) {
            // low surrogate
            output.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
          } else {
            // unmatched surrogate; only append this code unit, in case the next
            // code unit is the high surrogate of a surrogate pair
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    // Taken from https://mths.be/punycode
    function ucs2encode(array) {
      const length = array.length;
      let index = -1;
      let value;
      let output = '';
      while (++index < length) {
        value = array[index];
        if (value > 0xffff) {
          value -= 0x10000;
          output += stringFromCharCode(((value >>> 10) & 0x3ff) | 0xd800);
          value = 0xdc00 | (value & 0x3ff);
        }
        output += stringFromCharCode(value);
      }
      return output;
    }
    function checkScalarValue(codePoint, strict) {
      if (codePoint >= 0xd800 && codePoint <= 0xdfff) {
        if (strict) {
          throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
        }
        return false;
      }
      return true;
    }
    /*--------------------------------------------------------------------------*/
    function createByte(codePoint, shift) {
      return stringFromCharCode(((codePoint >> shift) & 0x3f) | 0x80);
    }
    function encodeCodePoint(codePoint, strict) {
      if ((codePoint & 0xffffff80) == 0) {
        // 1-byte sequence
        return stringFromCharCode(codePoint);
      }
      let symbol = '';
      if ((codePoint & 0xfffff800) == 0) {
        // 2-byte sequence
        symbol = stringFromCharCode(((codePoint >> 6) & 0x1f) | 0xc0);
      } else if ((codePoint & 0xffff0000) == 0) {
        // 3-byte sequence
        if (!checkScalarValue(codePoint, strict)) {
          codePoint = 0xfffd;
        }
        symbol = stringFromCharCode(((codePoint >> 12) & 0x0f) | 0xe0);
        symbol += createByte(codePoint, 6);
      } else if ((codePoint & 0xffe00000) == 0) {
        // 4-byte sequence
        symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xf0);
        symbol += createByte(codePoint, 12);
        symbol += createByte(codePoint, 6);
      }
      symbol += stringFromCharCode((codePoint & 0x3f) | 0x80);
      return symbol;
    }
    function utf8encode(string, opts) {
      opts = opts || {};
      const strict = opts.strict !== false;
      const codePoints = ucs2decode(string);
      const length = codePoints.length;
      let index = -1;
      let codePoint;
      let byteString = '';
      while (++index < length) {
        codePoint = codePoints[index];
        byteString += encodeCodePoint(codePoint, strict);
      }
      return byteString;
    }
    /*--------------------------------------------------------------------------*/
    function readContinuationByte() {
      if (byteIndex >= byteCount) {
        throw Error('Invalid byte index');
      }
      const continuationByte = byteArray[byteIndex] & 0xff;
      byteIndex++;
      if ((continuationByte & 0xc0) == 0x80) {
        return continuationByte & 0x3f;
      }
      // If we end up here, it’s not a continuation byte
      throw Error('Invalid continuation byte');
    }
    function decodeSymbol(strict) {
      let byte1;
      let byte2;
      let byte3;
      let byte4;
      let codePoint;
      if (byteIndex > byteCount) {
        throw Error('Invalid byte index');
      }
      if (byteIndex == byteCount) {
        return false;
      }
      // Read first byte
      byte1 = byteArray[byteIndex] & 0xff;
      byteIndex++;
      // 1-byte sequence (no continuation bytes)
      if ((byte1 & 0x80) == 0) {
        return byte1;
      }
      // 2-byte sequence
      if ((byte1 & 0xe0) == 0xc0) {
        byte2 = readContinuationByte();
        codePoint = ((byte1 & 0x1f) << 6) | byte2;
        if (codePoint >= 0x80) {
          return codePoint;
        } else {
          throw Error('Invalid continuation byte');
        }
      }
      // 3-byte sequence (may include unpaired surrogates)
      if ((byte1 & 0xf0) == 0xe0) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        codePoint = ((byte1 & 0x0f) << 12) | (byte2 << 6) | byte3;
        if (codePoint >= 0x0800) {
          return checkScalarValue(codePoint, strict) ? codePoint : 0xfffd;
        } else {
          throw Error('Invalid continuation byte');
        }
      }
      // 4-byte sequence
      if ((byte1 & 0xf8) == 0xf0) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        byte4 = readContinuationByte();
        codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;
        if (codePoint >= 0x010000 && codePoint <= 0x10ffff) {
          return codePoint;
        }
      }
      throw Error('Invalid UTF-8 detected');
    }
    let byteArray;
    let byteCount;
    let byteIndex;
    function utf8decode(byteString, opts) {
      opts = opts || {};
      const strict = opts.strict !== false;
      byteArray = ucs2decode(byteString);
      byteCount = byteArray.length;
      byteIndex = 0;
      const codePoints = [];
      let tmp;
      while ((tmp = decodeSymbol(strict)) !== false) {
        codePoints.push(tmp);
      }
      return ucs2encode(codePoints);
    }
    module.exports = {
      version: '2.1.2',
      encode: utf8encode,
      decode: utf8decode,
    };

    /***/
  },

  /***/ 2338: /***/ module => {
    /**
     * negotiator
     * Copyright(c) 2012 Isaac Z. Schlueter
     * Copyright(c) 2014 Federico Romero
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module exports.
     * @public
     */

    module.exports = preferredLanguages;
    module.exports.preferredLanguages = preferredLanguages;

    /**
     * Module variables.
     * @private
     */

    const simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;

    /**
     * Parse the Accept-Language header.
     * @private
     */

    function parseAcceptLanguage(accept) {
      const accepts = accept.split(',');

      for (var i = 0, j = 0; i < accepts.length; i++) {
        const language = parseLanguage(accepts[i].trim(), i);

        if (language) {
          accepts[j++] = language;
        }
      }

      // trim accepts
      accepts.length = j;

      return accepts;
    }

    /**
     * Parse a language from the Accept-Language header.
     * @private
     */

    function parseLanguage(str, i) {
      const match = simpleLanguageRegExp.exec(str);
      if (!match) return null;

      const prefix = match[1];
      const suffix = match[2];
      let full = prefix;

      if (suffix) full += '-' + suffix;

      let q = 1;
      if (match[3]) {
        const params = match[3].split(';');
        for (let j = 0; j < params.length; j++) {
          const p = params[j].split('=');
          if (p[0] === 'q') q = parseFloat(p[1]);
        }
      }

      return {
        prefix: prefix,
        suffix: suffix,
        q: q,
        i: i,
        full: full,
      };
    }

    /**
     * Get the priority of a language.
     * @private
     */

    function getLanguagePriority(language, accepted, index) {
      let priority = { o: -1, q: 0, s: 0 };

      for (let i = 0; i < accepted.length; i++) {
        const spec = specify(language, accepted[i], index);

        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }

      return priority;
    }

    /**
     * Get the specificity of the language.
     * @private
     */

    function specify(language, spec, index) {
      const p = parseLanguage(language);
      if (!p) return null;
      let s = 0;
      if (spec.full.toLowerCase() === p.full.toLowerCase()) {
        s |= 4;
      } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
        s |= 2;
      } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
        s |= 1;
      } else if (spec.full !== '*') {
        return null;
      }

      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s,
      };
    }

    /**
     * Get the preferred languages from an Accept-Language header.
     * @public
     */

    function preferredLanguages(accept, provided) {
      // RFC 2616 sec 14.4: no header = *
      const accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

      if (!provided) {
        // sorted list of all languages
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
      }

      const priorities = provided.map(function getPriority(type, index) {
        return getLanguagePriority(type, accepts, index);
      });

      // sorted list of accepted languages
      return priorities
        .filter(isQuality)
        .sort(compareSpecs)
        .map(function getLanguage(priority) {
          return provided[priorities.indexOf(priority)];
        });
    }

    /**
     * Compare two specs.
     * @private
     */

    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }

    /**
     * Get full language string.
     * @private
     */

    function getFullLanguage(spec) {
      return spec.full;
    }

    /**
     * Check if a spec has any quality.
     * @private
     */

    function isQuality(spec) {
      return spec.q > 0;
    }

    /***/
  },

  /***/ 2350: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.uServer = void 0;
    const debug_1 = __webpack_require__(1106);
    const server_1 = __webpack_require__(5287);
    const transports_uws_1 = __webpack_require__(8069);
    const debug = (0, debug_1.default)('engine:uws');
    /**
     * An Engine.IO server based on the `uWebSockets.js` package.
     */
    // TODO export it into its own package
    class uServer extends server_1.BaseServer {
      init() {}
      cleanup() {}
      /**
       * Prepares a request by processing the query string.
       *
       * @private
       */
      prepare(req, res) {
        req.method = req.getMethod().toUpperCase();
        req.url = req.getUrl();
        const params = new URLSearchParams(req.getQuery());
        req._query = Object.fromEntries(params.entries());
        req.headers = {};
        req.forEach((key, value) => {
          req.headers[key] = value;
        });
        req.connection = {
          remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString(),
        };
        res.onAborted(() => {
          debug('response has been aborted');
        });
      }
      createTransport(transportName, req) {
        return new transports_uws_1.default[transportName](req);
      }
      /**
       * Attach the engine to a µWebSockets.js server
       * @param app
       * @param options
       */
      attach(app /* : TemplatedApp */, options = {}) {
        const path = this._computePath(options);
        app
          .any(path, this.handleRequest.bind(this))
          //
          .ws(path, {
            compression: options.compression,
            idleTimeout: options.idleTimeout,
            maxBackpressure: options.maxBackpressure,
            maxPayloadLength: this.opts.maxHttpBufferSize,
            upgrade: this.handleUpgrade.bind(this),
            open: ws => {
              const transport = ws.getUserData().transport;
              transport.socket = ws;
              transport.writable = true;
              transport.emit('ready');
            },
            message: (ws, message, isBinary) => {
              ws.getUserData().transport.onData(isBinary ? message : Buffer.from(message).toString());
            },
            close: (ws, code, message) => {
              ws.getUserData().transport.onClose(code, message);
            },
          });
      }
      _applyMiddlewares(req, res, callback) {
        if (this.middlewares.length === 0) {
          return callback();
        }
        // needed to buffer headers until the status is computed
        req.res = new ResponseWrapper(res);
        super._applyMiddlewares(req, req.res, err => {
          // some middlewares (like express-session) wait for the writeHead() call to flush their headers
          // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244
          req.res.writeHead();
          callback(err);
        });
      }
      handleRequest(res, req) {
        debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
        this.prepare(req, res);
        req.res = res;
        const callback = (errorCode, errorContext) => {
          if (errorCode !== undefined) {
            this.emit('connection_error', {
              req,
              code: errorCode,
              message: server_1.Server.errorMessages[errorCode],
              context: errorContext,
            });
            this.abortRequest(req.res, errorCode, errorContext);
            return;
          }
          if (req._query.sid) {
            debug('setting new request for existing client');
            // @ts-ignore
            this.clients[req._query.sid].transport.onRequest(req);
          } else {
            const closeConnection = (errorCode, errorContext) => this.abortRequest(res, errorCode, errorContext);
            this.handshake(req._query.transport, req, closeConnection);
          }
        };
        this._applyMiddlewares(req, res, err => {
          if (err) {
            callback(server_1.Server.errors.BAD_REQUEST, { name: 'MIDDLEWARE_FAILURE' });
          } else {
            this.verify(req, false, callback);
          }
        });
      }
      handleUpgrade(res, req, context) {
        debug('on upgrade');
        this.prepare(req, res);
        req.res = res;
        const callback = async (errorCode, errorContext) => {
          if (errorCode !== undefined) {
            this.emit('connection_error', {
              req,
              code: errorCode,
              message: server_1.Server.errorMessages[errorCode],
              context: errorContext,
            });
            this.abortRequest(res, errorCode, errorContext);
            return;
          }
          const id = req._query.sid;
          let transport;
          if (id) {
            const client = this.clients[id];
            if (!client) {
              debug('upgrade attempt for closed client');
              return res.close();
            } else if (client.upgrading) {
              debug('transport has already been trying to upgrade');
              return res.close();
            } else if (client.upgraded) {
              debug('transport had already been upgraded');
              return res.close();
            } else {
              debug('upgrading existing transport');
              transport = this.createTransport(req._query.transport, req);
              client._maybeUpgrade(transport);
            }
          } else {
            transport = await this.handshake(req._query.transport, req, (errorCode, errorContext) =>
              this.abortRequest(res, errorCode, errorContext),
            );
            if (!transport) {
              return;
            }
          }
          // calling writeStatus() triggers the flushing of any header added in a middleware
          req.res.writeStatus('101 Switching Protocols');
          res.upgrade(
            {
              transport,
            },
            req.getHeader('sec-websocket-key'),
            req.getHeader('sec-websocket-protocol'),
            req.getHeader('sec-websocket-extensions'),
            context,
          );
        };
        this._applyMiddlewares(req, res, err => {
          if (err) {
            callback(server_1.Server.errors.BAD_REQUEST, { name: 'MIDDLEWARE_FAILURE' });
          } else {
            this.verify(req, true, callback);
          }
        });
      }
      abortRequest(res, errorCode, errorContext) {
        const statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? '403 Forbidden' : '400 Bad Request';
        const message =
          errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
        res.writeStatus(statusCode);
        res.writeHeader('Content-Type', 'application/json');
        res.end(
          JSON.stringify({
            code: errorCode,
            message,
          }),
        );
      }
    }
    exports.uServer = uServer;
    class ResponseWrapper {
      constructor(res) {
        this.res = res;
        this.statusWritten = false;
        this.headers = [];
        this.isAborted = false;
      }
      set statusCode(status) {
        if (!status) {
          return;
        }
        // FIXME: handle all status codes?
        this.writeStatus(status === 200 ? '200 OK' : '204 No Content');
      }
      writeHead(status) {
        this.statusCode = status;
      }
      setHeader(key, value) {
        if (Array.isArray(value)) {
          value.forEach(val => {
            this.writeHeader(key, val);
          });
        } else {
          this.writeHeader(key, value);
        }
      }
      removeHeader() {
        // FIXME: not implemented
      }
      // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134
      getHeader() {}
      writeStatus(status) {
        if (this.isAborted) return;
        this.res.writeStatus(status);
        this.statusWritten = true;
        this.writeBufferedHeaders();
        return this;
      }
      writeHeader(key, value) {
        if (this.isAborted) return;
        if (key === 'Content-Length') {
          // the content length is automatically added by uWebSockets.js
          return;
        }
        if (this.statusWritten) {
          this.res.writeHeader(key, value);
        } else {
          this.headers.push([key, value]);
        }
      }
      writeBufferedHeaders() {
        this.headers.forEach(([key, value]) => {
          this.res.writeHeader(key, value);
        });
      }
      end(data) {
        if (this.isAborted) return;
        this.res.cork(() => {
          if (!this.statusWritten) {
            // status will be inferred as "200 OK"
            this.writeBufferedHeaders();
          }
          this.res.end(data);
        });
      }
      onData(fn) {
        if (this.isAborted) return;
        this.res.onData(fn);
      }
      onAborted(fn) {
        if (this.isAborted) return;
        this.res.onAborted(() => {
          // Any attempt to use the UWS response object after abort will throw!
          this.isAborted = true;
          fn();
        });
      }
      cork(fn) {
        if (this.isAborted) return;
        this.res.cork(fn);
      }
    }

    /***/
  },

  /***/ 2382: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const utilContainsNewline = __webpack_require__(1120);

    function flowIndentCheck(indent, fc, onError) {
      if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (
          end.indent === indent &&
          (end.source === ']' || end.source === '}') &&
          utilContainsNewline.containsNewline(fc)
        ) {
          const msg = 'Flow end indicator should be more indented than parent';
          onError(end, 'BAD_INDENT', msg, true);
        }
      }
    }

    exports.flowIndentCheck = flowIndentCheck;

    /***/
  },

  /***/ 2443: /***/ function (__unused_webpack_module, exports, __webpack_require__) {
    const __rest =
      (this && this.__rest) ||
      function (s, e) {
        const t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === 'function')
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
          }
        return t;
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.ClusterAdapterWithHeartbeat = exports.ClusterAdapter = exports.MessageType = void 0;
    const in_memory_adapter_1 = __webpack_require__(9595);
    const debug_1 = __webpack_require__(1106);
    const crypto_1 = __webpack_require__(6982);
    const debug = (0, debug_1.debug)('socket.io-adapter');
    const EMITTER_UID = 'emitter';
    const DEFAULT_TIMEOUT = 5000;
    function randomId() {
      return (0, crypto_1.randomBytes)(8).toString('hex');
    }
    let MessageType;
    (function (MessageType) {
      MessageType[(MessageType['INITIAL_HEARTBEAT'] = 1)] = 'INITIAL_HEARTBEAT';
      MessageType[(MessageType['HEARTBEAT'] = 2)] = 'HEARTBEAT';
      MessageType[(MessageType['BROADCAST'] = 3)] = 'BROADCAST';
      MessageType[(MessageType['SOCKETS_JOIN'] = 4)] = 'SOCKETS_JOIN';
      MessageType[(MessageType['SOCKETS_LEAVE'] = 5)] = 'SOCKETS_LEAVE';
      MessageType[(MessageType['DISCONNECT_SOCKETS'] = 6)] = 'DISCONNECT_SOCKETS';
      MessageType[(MessageType['FETCH_SOCKETS'] = 7)] = 'FETCH_SOCKETS';
      MessageType[(MessageType['FETCH_SOCKETS_RESPONSE'] = 8)] = 'FETCH_SOCKETS_RESPONSE';
      MessageType[(MessageType['SERVER_SIDE_EMIT'] = 9)] = 'SERVER_SIDE_EMIT';
      MessageType[(MessageType['SERVER_SIDE_EMIT_RESPONSE'] = 10)] = 'SERVER_SIDE_EMIT_RESPONSE';
      MessageType[(MessageType['BROADCAST_CLIENT_COUNT'] = 11)] = 'BROADCAST_CLIENT_COUNT';
      MessageType[(MessageType['BROADCAST_ACK'] = 12)] = 'BROADCAST_ACK';
      MessageType[(MessageType['ADAPTER_CLOSE'] = 13)] = 'ADAPTER_CLOSE';
    })((MessageType = exports.MessageType || (exports.MessageType = {})));
    function encodeOptions(opts) {
      return {
        rooms: [...opts.rooms],
        except: [...opts.except],
        flags: opts.flags,
      };
    }
    function decodeOptions(opts) {
      return {
        rooms: new Set(opts.rooms),
        except: new Set(opts.except),
        flags: opts.flags,
      };
    }
    /**
     * A cluster-ready adapter. Any extending class must:
     *
     * - implement {@link ClusterAdapter#doPublish} and {@link ClusterAdapter#doPublishResponse}
     * - call {@link ClusterAdapter#onMessage} and {@link ClusterAdapter#onResponse}
     */
    class ClusterAdapter extends in_memory_adapter_1.Adapter {
      constructor(nsp) {
        super(nsp);
        this.requests = new Map();
        this.ackRequests = new Map();
        this.uid = randomId();
      }
      /**
       * Called when receiving a message from another member of the cluster.
       *
       * @param message
       * @param offset
       * @protected
       */
      onMessage(message, offset) {
        if (message.uid === this.uid) {
          return debug('[%s] ignore message from self', this.uid);
        }
        debug('[%s] new event of type %d from %s', this.uid, message.type, message.uid);
        switch (message.type) {
          case MessageType.BROADCAST: {
            const withAck = message.data.requestId !== undefined;
            if (withAck) {
              super.broadcastWithAck(
                message.data.packet,
                decodeOptions(message.data.opts),
                clientCount => {
                  debug('[%s] waiting for %d client acknowledgements', this.uid, clientCount);
                  this.publishResponse(message.uid, {
                    type: MessageType.BROADCAST_CLIENT_COUNT,
                    data: {
                      requestId: message.data.requestId,
                      clientCount,
                    },
                  });
                },
                arg => {
                  debug('[%s] received acknowledgement with value %j', this.uid, arg);
                  this.publishResponse(message.uid, {
                    type: MessageType.BROADCAST_ACK,
                    data: {
                      requestId: message.data.requestId,
                      packet: arg,
                    },
                  });
                },
              );
            } else {
              const packet = message.data.packet;
              const opts = decodeOptions(message.data.opts);
              this.addOffsetIfNecessary(packet, opts, offset);
              super.broadcast(packet, opts);
            }
            break;
          }
          case MessageType.SOCKETS_JOIN:
            super.addSockets(decodeOptions(message.data.opts), message.data.rooms);
            break;
          case MessageType.SOCKETS_LEAVE:
            super.delSockets(decodeOptions(message.data.opts), message.data.rooms);
            break;
          case MessageType.DISCONNECT_SOCKETS:
            super.disconnectSockets(decodeOptions(message.data.opts), message.data.close);
            break;
          case MessageType.FETCH_SOCKETS: {
            debug('[%s] calling fetchSockets with opts %j', this.uid, message.data.opts);
            super.fetchSockets(decodeOptions(message.data.opts)).then(localSockets => {
              this.publishResponse(message.uid, {
                type: MessageType.FETCH_SOCKETS_RESPONSE,
                data: {
                  requestId: message.data.requestId,
                  sockets: localSockets.map(socket => {
                    // remove sessionStore from handshake, as it may contain circular references
                    const _a = socket.handshake,
                      { sessionStore } = _a,
                      handshake = __rest(_a, ['sessionStore']);
                    return {
                      id: socket.id,
                      handshake,
                      rooms: [...socket.rooms],
                      data: socket.data,
                    };
                  }),
                },
              });
            });
            break;
          }
          case MessageType.SERVER_SIDE_EMIT: {
            const packet = message.data.packet;
            const withAck = message.data.requestId !== undefined;
            if (!withAck) {
              this.nsp._onServerSideEmit(packet);
              return;
            }
            let called = false;
            const callback = arg => {
              // only one argument is expected
              if (called) {
                return;
              }
              called = true;
              debug('[%s] calling acknowledgement with %j', this.uid, arg);
              this.publishResponse(message.uid, {
                type: MessageType.SERVER_SIDE_EMIT_RESPONSE,
                data: {
                  requestId: message.data.requestId,
                  packet: arg,
                },
              });
            };
            this.nsp._onServerSideEmit([...packet, callback]);
            break;
          }
          // @ts-ignore
          case MessageType.BROADCAST_CLIENT_COUNT:
          // @ts-ignore
          case MessageType.BROADCAST_ACK:
          // @ts-ignore
          case MessageType.FETCH_SOCKETS_RESPONSE:
          // @ts-ignore
          case MessageType.SERVER_SIDE_EMIT_RESPONSE:
            // extending classes may not make a distinction between a ClusterMessage and a ClusterResponse payload and may
            // always call the onMessage() method
            this.onResponse(message);
            break;
          default:
            debug('[%s] unknown message type: %s', this.uid, message.type);
        }
      }
      /**
       * Called when receiving a response from another member of the cluster.
       *
       * @param response
       * @protected
       */
      onResponse(response) {
        let _a, _b;
        const requestId = response.data.requestId;
        debug('[%s] received response %s to request %s', this.uid, response.type, requestId);
        switch (response.type) {
          case MessageType.BROADCAST_CLIENT_COUNT: {
            (_a = this.ackRequests.get(requestId)) === null || _a === void 0
              ? void 0
              : _a.clientCountCallback(response.data.clientCount);
            break;
          }
          case MessageType.BROADCAST_ACK: {
            (_b = this.ackRequests.get(requestId)) === null || _b === void 0 ? void 0 : _b.ack(response.data.packet);
            break;
          }
          case MessageType.FETCH_SOCKETS_RESPONSE: {
            const request = this.requests.get(requestId);
            if (!request) {
              return;
            }
            request.current++;
            response.data.sockets.forEach(socket => request.responses.push(socket));
            if (request.current === request.expected) {
              clearTimeout(request.timeout);
              request.resolve(request.responses);
              this.requests.delete(requestId);
            }
            break;
          }
          case MessageType.SERVER_SIDE_EMIT_RESPONSE: {
            const request = this.requests.get(requestId);
            if (!request) {
              return;
            }
            request.current++;
            request.responses.push(response.data.packet);
            if (request.current === request.expected) {
              clearTimeout(request.timeout);
              request.resolve(null, request.responses);
              this.requests.delete(requestId);
            }
            break;
          }
          default:
            // @ts-ignore
            debug('[%s] unknown response type: %s', this.uid, response.type);
        }
      }
      async broadcast(packet, opts) {
        let _a;
        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (!onlyLocal) {
          try {
            const offset = await this.publishAndReturnOffset({
              type: MessageType.BROADCAST,
              data: {
                packet,
                opts: encodeOptions(opts),
              },
            });
            this.addOffsetIfNecessary(packet, opts, offset);
          } catch (e) {
            return debug('[%s] error while broadcasting message: %s', this.uid, e.message);
          }
        }
        super.broadcast(packet, opts);
      }
      /**
       * Adds an offset at the end of the data array in order to allow the client to receive any missed packets when it
       * reconnects after a temporary disconnection.
       *
       * @param packet
       * @param opts
       * @param offset
       * @private
       */
      addOffsetIfNecessary(packet, opts, offset) {
        let _a;
        if (!this.nsp.server.opts.connectionStateRecovery) {
          return;
        }
        const isEventPacket = packet.type === 2;
        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and
        // restored on another server upon reconnection
        const withoutAcknowledgement = packet.id === undefined;
        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;
        if (isEventPacket && withoutAcknowledgement && notVolatile) {
          packet.data.push(offset);
        }
      }
      broadcastWithAck(packet, opts, clientCountCallback, ack) {
        let _a;
        const onlyLocal =
          (_a = opts === null || opts === void 0 ? void 0 : opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (!onlyLocal) {
          const requestId = randomId();
          this.ackRequests.set(requestId, {
            clientCountCallback,
            ack,
          });
          this.publish({
            type: MessageType.BROADCAST,
            data: {
              packet,
              requestId,
              opts: encodeOptions(opts),
            },
          });
          // we have no way to know at this level whether the server has received an acknowledgement from each client, so we
          // will simply clean up the ackRequests map after the given delay
          setTimeout(() => {
            this.ackRequests.delete(requestId);
          }, opts.flags.timeout);
        }
        super.broadcastWithAck(packet, opts, clientCountCallback, ack);
      }
      async addSockets(opts, rooms) {
        let _a;
        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (!onlyLocal) {
          try {
            await this.publishAndReturnOffset({
              type: MessageType.SOCKETS_JOIN,
              data: {
                opts: encodeOptions(opts),
                rooms,
              },
            });
          } catch (e) {
            debug('[%s] error while publishing message: %s', this.uid, e.message);
          }
        }
        super.addSockets(opts, rooms);
      }
      async delSockets(opts, rooms) {
        let _a;
        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (!onlyLocal) {
          try {
            await this.publishAndReturnOffset({
              type: MessageType.SOCKETS_LEAVE,
              data: {
                opts: encodeOptions(opts),
                rooms,
              },
            });
          } catch (e) {
            debug('[%s] error while publishing message: %s', this.uid, e.message);
          }
        }
        super.delSockets(opts, rooms);
      }
      async disconnectSockets(opts, close) {
        let _a;
        const onlyLocal = (_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local;
        if (!onlyLocal) {
          try {
            await this.publishAndReturnOffset({
              type: MessageType.DISCONNECT_SOCKETS,
              data: {
                opts: encodeOptions(opts),
                close,
              },
            });
          } catch (e) {
            debug('[%s] error while publishing message: %s', this.uid, e.message);
          }
        }
        super.disconnectSockets(opts, close);
      }
      async fetchSockets(opts) {
        let _a;
        const [localSockets, serverCount] = await Promise.all([super.fetchSockets(opts), this.serverCount()]);
        const expectedResponseCount = serverCount - 1;
        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {
          return localSockets;
        }
        const requestId = randomId();
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            const storedRequest = this.requests.get(requestId);
            if (storedRequest) {
              reject(
                new Error(
                  `timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`,
                ),
              );
              this.requests.delete(requestId);
            }
          }, opts.flags.timeout || DEFAULT_TIMEOUT);
          const storedRequest = {
            type: MessageType.FETCH_SOCKETS,
            resolve,
            timeout,
            current: 0,
            expected: expectedResponseCount,
            responses: localSockets,
          };
          this.requests.set(requestId, storedRequest);
          this.publish({
            type: MessageType.FETCH_SOCKETS,
            data: {
              opts: encodeOptions(opts),
              requestId,
            },
          });
        });
      }
      async serverSideEmit(packet) {
        const withAck = typeof packet[packet.length - 1] === 'function';
        if (!withAck) {
          return this.publish({
            type: MessageType.SERVER_SIDE_EMIT,
            data: {
              packet,
            },
          });
        }
        const ack = packet.pop();
        const expectedResponseCount = (await this.serverCount()) - 1;
        debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
        if (expectedResponseCount <= 0) {
          return ack(null, []);
        }
        const requestId = randomId();
        const timeout = setTimeout(() => {
          const storedRequest = this.requests.get(requestId);
          if (storedRequest) {
            ack(
              new Error(
                `timeout reached: only ${storedRequest.current} responses received out of ${storedRequest.expected}`,
              ),
              storedRequest.responses,
            );
            this.requests.delete(requestId);
          }
        }, DEFAULT_TIMEOUT);
        const storedRequest = {
          type: MessageType.SERVER_SIDE_EMIT,
          resolve: ack,
          timeout,
          current: 0,
          expected: expectedResponseCount,
          responses: [],
        };
        this.requests.set(requestId, storedRequest);
        this.publish({
          type: MessageType.SERVER_SIDE_EMIT,
          data: {
            requestId,
            packet,
          },
        });
      }
      publish(message) {
        this.publishAndReturnOffset(message).catch(err => {
          debug('[%s] error while publishing message: %s', this.uid, err);
        });
      }
      publishAndReturnOffset(message) {
        message.uid = this.uid;
        message.nsp = this.nsp.name;
        return this.doPublish(message);
      }
      publishResponse(requesterUid, response) {
        response.uid = this.uid;
        response.nsp = this.nsp.name;
        this.doPublishResponse(requesterUid, response).catch(err => {
          debug('[%s] error while publishing response: %s', this.uid, err);
        });
      }
    }
    exports.ClusterAdapter = ClusterAdapter;
    class ClusterAdapterWithHeartbeat extends ClusterAdapter {
      constructor(nsp, opts) {
        super(nsp);
        this.nodesMap = new Map(); // uid => timestamp of last message
        this.customRequests = new Map();
        this._opts = Object.assign(
          {
            heartbeatInterval: 5000,
            heartbeatTimeout: 10000,
          },
          opts,
        );
        this.cleanupTimer = setInterval(() => {
          const now = Date.now();
          this.nodesMap.forEach((lastSeen, uid) => {
            const nodeSeemsDown = now - lastSeen > this._opts.heartbeatTimeout;
            if (nodeSeemsDown) {
              debug('[%s] node %s seems down', this.uid, uid);
              this.removeNode(uid);
            }
          });
        }, 1000);
      }
      init() {
        this.publish({
          type: MessageType.INITIAL_HEARTBEAT,
        });
      }
      scheduleHeartbeat() {
        if (this.heartbeatTimer) {
          this.heartbeatTimer.refresh();
        } else {
          this.heartbeatTimer = setTimeout(() => {
            this.publish({
              type: MessageType.HEARTBEAT,
            });
          }, this._opts.heartbeatInterval);
        }
      }
      close() {
        this.publish({
          type: MessageType.ADAPTER_CLOSE,
        });
        clearTimeout(this.heartbeatTimer);
        if (this.cleanupTimer) {
          clearInterval(this.cleanupTimer);
        }
      }
      onMessage(message, offset) {
        if (message.uid === this.uid) {
          return debug('[%s] ignore message from self', this.uid);
        }
        if (message.uid && message.uid !== EMITTER_UID) {
          // we track the UID of each sender, in order to know how many servers there are in the cluster
          this.nodesMap.set(message.uid, Date.now());
        }
        debug('[%s] new event of type %d from %s', this.uid, message.type, message.uid);
        switch (message.type) {
          case MessageType.INITIAL_HEARTBEAT:
            this.publish({
              type: MessageType.HEARTBEAT,
            });
            break;
          case MessageType.HEARTBEAT:
            // nothing to do
            break;
          case MessageType.ADAPTER_CLOSE:
            this.removeNode(message.uid);
            break;
          default:
            super.onMessage(message, offset);
        }
      }
      serverCount() {
        return Promise.resolve(1 + this.nodesMap.size);
      }
      publish(message) {
        this.scheduleHeartbeat();
        return super.publish(message);
      }
      async serverSideEmit(packet) {
        const withAck = typeof packet[packet.length - 1] === 'function';
        if (!withAck) {
          return this.publish({
            type: MessageType.SERVER_SIDE_EMIT,
            data: {
              packet,
            },
          });
        }
        const ack = packet.pop();
        const expectedResponseCount = this.nodesMap.size;
        debug('[%s] waiting for %d responses to "serverSideEmit" request', this.uid, expectedResponseCount);
        if (expectedResponseCount <= 0) {
          return ack(null, []);
        }
        const requestId = randomId();
        const timeout = setTimeout(() => {
          const storedRequest = this.customRequests.get(requestId);
          if (storedRequest) {
            ack(
              new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`),
              storedRequest.responses,
            );
            this.customRequests.delete(requestId);
          }
        }, DEFAULT_TIMEOUT);
        const storedRequest = {
          type: MessageType.SERVER_SIDE_EMIT,
          resolve: ack,
          timeout,
          missingUids: new Set([...this.nodesMap.keys()]),
          responses: [],
        };
        this.customRequests.set(requestId, storedRequest);
        this.publish({
          type: MessageType.SERVER_SIDE_EMIT,
          data: {
            requestId,
            packet,
          },
        });
      }
      async fetchSockets(opts) {
        let _a;
        const [localSockets, serverCount] = await Promise.all([
          super.fetchSockets({
            rooms: opts.rooms,
            except: opts.except,
            flags: {
              local: true,
            },
          }),
          this.serverCount(),
        ]);
        const expectedResponseCount = serverCount - 1;
        if (((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.local) || expectedResponseCount <= 0) {
          return localSockets;
        }
        const requestId = randomId();
        return new Promise((resolve, reject) => {
          const timeout = setTimeout(() => {
            const storedRequest = this.customRequests.get(requestId);
            if (storedRequest) {
              reject(new Error(`timeout reached: missing ${storedRequest.missingUids.size} responses`));
              this.customRequests.delete(requestId);
            }
          }, opts.flags.timeout || DEFAULT_TIMEOUT);
          const storedRequest = {
            type: MessageType.FETCH_SOCKETS,
            resolve,
            timeout,
            missingUids: new Set([...this.nodesMap.keys()]),
            responses: localSockets,
          };
          this.customRequests.set(requestId, storedRequest);
          this.publish({
            type: MessageType.FETCH_SOCKETS,
            data: {
              opts: encodeOptions(opts),
              requestId,
            },
          });
        });
      }
      onResponse(response) {
        const requestId = response.data.requestId;
        debug('[%s] received response %s to request %s', this.uid, response.type, requestId);
        switch (response.type) {
          case MessageType.FETCH_SOCKETS_RESPONSE: {
            const request = this.customRequests.get(requestId);
            if (!request) {
              return;
            }
            response.data.sockets.forEach(socket => request.responses.push(socket));
            request.missingUids.delete(response.uid);
            if (request.missingUids.size === 0) {
              clearTimeout(request.timeout);
              request.resolve(request.responses);
              this.customRequests.delete(requestId);
            }
            break;
          }
          case MessageType.SERVER_SIDE_EMIT_RESPONSE: {
            const request = this.customRequests.get(requestId);
            if (!request) {
              return;
            }
            request.responses.push(response.data.packet);
            request.missingUids.delete(response.uid);
            if (request.missingUids.size === 0) {
              clearTimeout(request.timeout);
              request.resolve(null, request.responses);
              this.customRequests.delete(requestId);
            }
            break;
          }
          default:
            super.onResponse(response);
        }
      }
      removeNode(uid) {
        this.customRequests.forEach((request, requestId) => {
          request.missingUids.delete(uid);
          if (request.missingUids.size === 0) {
            clearTimeout(request.timeout);
            if (request.type === MessageType.FETCH_SOCKETS) {
              request.resolve(request.responses);
            } else if (request.type === MessageType.SERVER_SIDE_EMIT) {
              request.resolve(null, request.responses);
            }
            this.customRequests.delete(requestId);
          }
        });
        this.nodesMap.delete(uid);
      }
    }
    exports.ClusterAdapterWithHeartbeat = ClusterAdapterWithHeartbeat;

    /***/
  },

  /***/ 2490: /***/ (__unused_webpack_module, exports) => {
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value === 'bigint') return String(value);
      const num = typeof value === 'number' ? value : Number(value);
      if (!isFinite(num)) return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
      let n = JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === 'tag:yaml.org,2002:float') && /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
          i = n.length;
          n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0) n += '0';
      }
      return n;
    }

    exports.stringifyNumber = stringifyNumber;

    /***/
  },

  /***/ 2556: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const identity = __webpack_require__(7182);
    const Scalar = __webpack_require__(6364);
    const resolveBlockScalar = __webpack_require__(140);
    const resolveFlowScalar = __webpack_require__(8113);

    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } =
        token.type === 'block-scalar'
          ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError)
          : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName) tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
      else if (token.type === 'scalar') tag = findScalarTagByTest(ctx, value, token, onError);
      else tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type) scalar.type = type;
      if (tagName) scalar.tag = tagName;
      if (tag.format) scalar.format = tag.format;
      if (comment) scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      if (tagName === '!') return schema[identity.SCALAR]; // non-specific tag
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test) matchWithTest.push(tag);
          else return tag;
        }
      }
      for (const tag of matchWithTest) if (tag.test?.test(value)) return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
      }
      onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
      const tag =
        schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) && tag.test?.test(value)) ||
        schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
      }
      return tag;
    }

    exports.composeScalar = composeScalar;

    /***/
  },

  /***/ 2576: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Alias = __webpack_require__(9814);
    const identity = __webpack_require__(7182);
    const composeCollection = __webpack_require__(7952);
    const composeScalar = __webpack_require__(2556);
    const resolveEnd = __webpack_require__(191);
    const utilEmptyScalarPosition = __webpack_require__(4078);

    const CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case 'alias':
          node = composeAlias(ctx, token, onError);
          if (anchor || tag) onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
          break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor) node.anchor = anchor.source.substring(1);
          break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor) node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === 'error' ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, 'UNEXPECTED_TOKEN', message);
          node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
      if (
        atKey &&
        ctx.options.stringKeys &&
        (!identity.isScalar(node) ||
          typeof node.value !== 'string' ||
          (node.tag && node.tag !== 'tag:yaml.org,2002:str'))
      ) {
        const msg = 'With stringKeys, all keys must be strings';
        onError(tag ?? token, 'NON_STRING_KEY', msg);
      }
      if (spaceBefore) node.spaceBefore = true;
      if (comment) {
        if (token.type === 'scalar' && token.source === '') node.comment = comment;
        else node.commentBefore = comment;
      }
      // @ts-expect-error Type checking misses meaning of isSrcToken
      if (ctx.options.keepSourceTokens && isSrcToken) node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: 'scalar',
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: '',
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '') onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
      }
      if (spaceBefore) node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === '') onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
      if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment) alias.comment = re.comment;
      return alias;
    }

    exports.composeEmptyNode = composeEmptyNode;
    exports.composeNode = composeNode;

    /***/
  },

  /***/ 2668: /***/ module => {
    /**
     * Checks if a given buffer contains only correct UTF-8.
     * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
     * Markus Kuhn.
     *
     * @param {Buffer} buf The buffer to check
     * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
     * @public
     */
    function isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;

      while (i < len) {
        if ((buf[i] & 0x80) === 0x00) {
          // 0xxxxxxx
          i++;
        } else if ((buf[i] & 0xe0) === 0xc0) {
          // 110xxxxx 10xxxxxx
          if (
            i + 1 === len ||
            (buf[i + 1] & 0xc0) !== 0x80 ||
            (buf[i] & 0xfe) === 0xc0 // overlong
          ) {
            return false;
          }

          i += 2;
        } else if ((buf[i] & 0xf0) === 0xe0) {
          // 1110xxxx 10xxxxxx 10xxxxxx
          if (
            i + 2 >= len ||
            (buf[i + 1] & 0xc0) !== 0x80 ||
            (buf[i + 2] & 0xc0) !== 0x80 ||
            (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // overlong
            (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // surrogate (U+D800 - U+DFFF)
          ) {
            return false;
          }

          i += 3;
        } else if ((buf[i] & 0xf8) === 0xf0) {
          // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
          if (
            i + 3 >= len ||
            (buf[i + 1] & 0xc0) !== 0x80 ||
            (buf[i + 2] & 0xc0) !== 0x80 ||
            (buf[i + 3] & 0xc0) !== 0x80 ||
            (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // overlong
            (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
            buf[i] > 0xf4 // > U+10FFFF
          ) {
            return false;
          }

          i += 4;
        } else {
          return false;
        }
      }

      return true;
    }

    module.exports = isValidUTF8;

    /***/
  },

  /***/ 2680: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.decodePayload =
      exports.decodePacket =
      exports.encodePayload =
      exports.encodePacket =
      exports.protocol =
        void 0;
    exports.createPacketEncoderStream = createPacketEncoderStream;
    exports.createPacketDecoderStream = createPacketDecoderStream;
    const encodePacket_js_1 = __webpack_require__(2760);
    Object.defineProperty(exports, 'encodePacket', {
      enumerable: true,
      get: function () {
        return encodePacket_js_1.encodePacket;
      },
    });
    const decodePacket_js_1 = __webpack_require__(5552);
    Object.defineProperty(exports, 'decodePacket', {
      enumerable: true,
      get: function () {
        return decodePacket_js_1.decodePacket;
      },
    });
    const commons_js_1 = __webpack_require__(7758);
    const SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
    const encodePayload = (packets, callback) => {
      // some packets may be added to the array while encoding, so the initial length must be saved
      const length = packets.length;
      const encodedPackets = new Array(length);
      let count = 0;
      packets.forEach((packet, i) => {
        // force base64 encoding for binary packets
        (0, encodePacket_js_1.encodePacket)(packet, false, encodedPacket => {
          encodedPackets[i] = encodedPacket;
          if (++count === length) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };
    exports.encodePayload = encodePayload;
    const decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.decodePacket)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === 'error') {
          break;
        }
      }
      return packets;
    };
    exports.decodePayload = decodePayload;
    function createPacketEncoderStream() {
      return new TransformStream({
        transform(packet, controller) {
          (0, encodePacket_js_1.encodePacketToBinary)(packet, encodedPacket => {
            const payloadLength = encodedPacket.length;
            let header;
            // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length
            if (payloadLength < 126) {
              header = new Uint8Array(1);
              new DataView(header.buffer).setUint8(0, payloadLength);
            } else if (payloadLength < 65536) {
              header = new Uint8Array(3);
              const view = new DataView(header.buffer);
              view.setUint8(0, 126);
              view.setUint16(1, payloadLength);
            } else {
              header = new Uint8Array(9);
              const view = new DataView(header.buffer);
              view.setUint8(0, 127);
              view.setBigUint64(1, BigInt(payloadLength));
            }
            // first bit indicates whether the payload is plain text (0) or binary (1)
            if (packet.data && typeof packet.data !== 'string') {
              header[0] |= 0x80;
            }
            controller.enqueue(header);
            controller.enqueue(encodedPacket);
          });
        },
      });
    }
    let TEXT_DECODER;
    function totalLength(chunks) {
      return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
    }
    function concatChunks(chunks, size) {
      if (chunks[0].length === size) {
        return chunks.shift();
      }
      const buffer = new Uint8Array(size);
      let j = 0;
      for (let i = 0; i < size; i++) {
        buffer[i] = chunks[0][j++];
        if (j === chunks[0].length) {
          chunks.shift();
          j = 0;
        }
      }
      if (chunks.length && j < chunks[0].length) {
        chunks[0] = chunks[0].slice(j);
      }
      return buffer;
    }
    function createPacketDecoderStream(maxPayload, binaryType) {
      if (!TEXT_DECODER) {
        TEXT_DECODER = new TextDecoder();
      }
      const chunks = [];
      let state = 0; /* State.READ_HEADER */
      let expectedLength = -1;
      let isBinary = false;
      return new TransformStream({
        transform(chunk, controller) {
          chunks.push(chunk);
          while (true) {
            if (state === 0 /* State.READ_HEADER */) {
              if (totalLength(chunks) < 1) {
                break;
              }
              const header = concatChunks(chunks, 1);
              isBinary = (header[0] & 0x80) === 0x80;
              expectedLength = header[0] & 0x7f;
              if (expectedLength < 126) {
                state = 3 /* State.READ_PAYLOAD */;
              } else if (expectedLength === 126) {
                state = 1 /* State.READ_EXTENDED_LENGTH_16 */;
              } else {
                state = 2 /* State.READ_EXTENDED_LENGTH_64 */;
              }
            } else if (state === 1 /* State.READ_EXTENDED_LENGTH_16 */) {
              if (totalLength(chunks) < 2) {
                break;
              }
              const headerArray = concatChunks(chunks, 2);
              expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(
                0,
              );
              state = 3 /* State.READ_PAYLOAD */;
            } else if (state === 2 /* State.READ_EXTENDED_LENGTH_64 */) {
              if (totalLength(chunks) < 8) {
                break;
              }
              const headerArray = concatChunks(chunks, 8);
              const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
              const n = view.getUint32(0);
              if (n > Math.pow(2, 53 - 32) - 1) {
                // the maximum safe integer in JavaScript is 2^53 - 1
                controller.enqueue(commons_js_1.ERROR_PACKET);
                break;
              }
              expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
              state = 3 /* State.READ_PAYLOAD */;
            } else {
              if (totalLength(chunks) < expectedLength) {
                break;
              }
              const data = concatChunks(chunks, expectedLength);
              controller.enqueue(
                (0, decodePacket_js_1.decodePacket)(isBinary ? data : TEXT_DECODER.decode(data), binaryType),
              );
              state = 0 /* State.READ_HEADER */;
            }
            if (expectedLength === 0 || expectedLength > maxPayload) {
              controller.enqueue(commons_js_1.ERROR_PACKET);
              break;
            }
          }
        },
      });
    }
    exports.protocol = 4;

    /***/
  },

  /***/ 2760: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.encodePacket = void 0;
    exports.encodePacketToBinary = encodePacketToBinary;
    const commons_js_1 = __webpack_require__(7758);
    const encodePacket = ({ type, data }, supportsBinary, callback) => {
      if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
        return callback(supportsBinary ? data : 'b' + toBuffer(data, true).toString('base64'));
      }
      // plain string
      return callback(commons_js_1.PACKET_TYPES[type] + (data || ''));
    };
    exports.encodePacket = encodePacket;
    const toBuffer = (data, forceBufferConversion) => {
      if (Buffer.isBuffer(data) || (data instanceof Uint8Array && !forceBufferConversion)) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return Buffer.from(data);
      } else {
        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      }
    };
    let TEXT_ENCODER;
    function encodePacketToBinary(packet, callback) {
      if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return callback(toBuffer(packet.data, false));
      }
      (0, exports.encodePacket)(packet, true, encoded => {
        if (!TEXT_ENCODER) {
          // lazily created for compatibility with Node.js 10
          TEXT_ENCODER = new TextEncoder();
        }
        callback(TEXT_ENCODER.encode(encoded));
      });
    }

    /***/
  },

  /***/ 2822: /***/ module => {
    /**
     * Masks a buffer using the given mask.
     *
     * @param {Buffer} source The buffer to mask
     * @param {Buffer} mask The mask to use
     * @param {Buffer} output The buffer where to store the result
     * @param {Number} offset The offset at which to start writing
     * @param {Number} length The number of bytes to mask.
     * @public
     */
    const mask = (source, mask, output, offset, length) => {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    };

    /**
     * Unmasks a buffer using the given mask.
     *
     * @param {Buffer} buffer The buffer to unmask
     * @param {Buffer} mask The mask to use
     * @public
     */
    const unmask = (buffer, mask) => {
      // Required until https://github.com/nodejs/node/issues/9006 is resolved.
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    };

    module.exports = { mask, unmask };

    /***/
  },

  /***/ 2879: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Transport = void 0;
    const events_1 = __webpack_require__(4434);
    const parser_v4 = __webpack_require__(2680);
    const parser_v3 = __webpack_require__(5076);
    const debug_1 = __webpack_require__(1106);
    const debug = (0, debug_1.default)('engine:transport');
    function noop() {}
    class Transport extends events_1.EventEmitter {
      get readyState() {
        return this._readyState;
      }
      set readyState(state) {
        debug('readyState updated from %s to %s (%s)', this._readyState, state, this.name);
        this._readyState = state;
      }
      /**
       * Transport constructor.
       *
       * @param {EngineRequest} req
       */
      constructor(req) {
        super();
        /**
         * Whether the transport is currently ready to send packets.
         */
        this.writable = false;
        /**
         * The current state of the transport.
         * @protected
         */
        this._readyState = 'open';
        /**
         * Whether the transport is discarded and can be safely closed (used during upgrade).
         * @protected
         */
        this.discarded = false;
        this.protocol = req._query.EIO === '4' ? 4 : 3; // 3rd revision by default
        this.parser = this.protocol === 4 ? parser_v4 : parser_v3;
        this.supportsBinary = !(req._query && req._query.b64);
      }
      /**
       * Flags the transport as discarded.
       *
       * @package
       */
      discard() {
        this.discarded = true;
      }
      /**
       * Called with an incoming HTTP request.
       *
       * @param req
       * @package
       */
      onRequest(req) {}
      /**
       * Closes the transport.
       *
       * @package
       */
      close(fn) {
        if (this.readyState === 'closed' || this.readyState === 'closing') return;
        this.readyState = 'closing';
        this.doClose(fn || noop);
      }
      /**
       * Called with a transport error.
       *
       * @param {String} msg - message error
       * @param {Object} desc - error description
       * @protected
       */
      onError(msg, desc) {
        if (this.listeners('error').length) {
          const err = new Error(msg);
          // @ts-ignore
          err.type = 'TransportError';
          // @ts-ignore
          err.description = desc;
          this.emit('error', err);
        } else {
          debug('ignored transport error %s (%s)', msg, desc);
        }
      }
      /**
       * Called with parsed out a packets from the data stream.
       *
       * @param {Object} packet
       * @protected
       */
      onPacket(packet) {
        this.emit('packet', packet);
      }
      /**
       * Called with the encoded packet data.
       *
       * @param {String} data
       * @protected
       */
      onData(data) {
        this.onPacket(this.parser.decodePacket(data));
      }
      /**
       * Called upon transport close.
       *
       * @protected
       */
      onClose() {
        this.readyState = 'closed';
        this.emit('close');
      }
    }
    exports.Transport = Transport;

    /***/
  },

  /***/ 2935: /***/ function (module, exports, __webpack_require__) {
    /* module decorator */ module = __webpack_require__.nmd(module);
    let __WEBPACK_AMD_DEFINE_RESULT__; /**
     * @license
     * Lodash <https://lodash.com/>
     * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */
    (function () {
      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      let undefined;

      /** Used as the semantic version number. */
      const VERSION = '4.17.21';

      /** Used as the size to enable large array optimizations. */
      const LARGE_ARRAY_SIZE = 200;

      /** Error message constants. */
      const CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
        FUNC_ERROR_TEXT = 'Expected a function',
        INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

      /** Used to stand-in for `undefined` hash values. */
      const HASH_UNDEFINED = '__lodash_hash_undefined__';

      /** Used as the maximum memoize cache size. */
      const MAX_MEMOIZE_SIZE = 500;

      /** Used as the internal argument placeholder. */
      const PLACEHOLDER = '__lodash_placeholder__';

      /** Used to compose bitmasks for cloning. */
      const CLONE_DEEP_FLAG = 1,
        CLONE_FLAT_FLAG = 2,
        CLONE_SYMBOLS_FLAG = 4;

      /** Used to compose bitmasks for value comparisons. */
      const COMPARE_PARTIAL_FLAG = 1,
        COMPARE_UNORDERED_FLAG = 2;

      /** Used to compose bitmasks for function metadata. */
      const WRAP_BIND_FLAG = 1,
        WRAP_BIND_KEY_FLAG = 2,
        WRAP_CURRY_BOUND_FLAG = 4,
        WRAP_CURRY_FLAG = 8,
        WRAP_CURRY_RIGHT_FLAG = 16,
        WRAP_PARTIAL_FLAG = 32,
        WRAP_PARTIAL_RIGHT_FLAG = 64,
        WRAP_ARY_FLAG = 128,
        WRAP_REARG_FLAG = 256,
        WRAP_FLIP_FLAG = 512;

      /** Used as default options for `_.truncate`. */
      const DEFAULT_TRUNC_LENGTH = 30,
        DEFAULT_TRUNC_OMISSION = '...';

      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      const HOT_COUNT = 800,
        HOT_SPAN = 16;

      /** Used to indicate the type of lazy iteratees. */
      const LAZY_FILTER_FLAG = 1,
        LAZY_MAP_FLAG = 2,
        LAZY_WHILE_FLAG = 3;

      /** Used as references for various `Number` constants. */
      const INFINITY = 1 / 0,
        MAX_SAFE_INTEGER = 9007199254740991,
        MAX_INTEGER = 1.7976931348623157e308,
        NAN = 0 / 0;

      /** Used as references for the maximum length and index of an array. */
      const MAX_ARRAY_LENGTH = 4294967295,
        MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
        HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

      /** Used to associate wrap methods with their bit flags. */
      const wrapFlags = [
        ['ary', WRAP_ARY_FLAG],
        ['bind', WRAP_BIND_FLAG],
        ['bindKey', WRAP_BIND_KEY_FLAG],
        ['curry', WRAP_CURRY_FLAG],
        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
        ['flip', WRAP_FLIP_FLAG],
        ['partial', WRAP_PARTIAL_FLAG],
        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
        ['rearg', WRAP_REARG_FLAG],
      ];

      /** `Object#toString` result references. */
      const argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        asyncTag = '[object AsyncFunction]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        domExcTag = '[object DOMException]',
        errorTag = '[object Error]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        nullTag = '[object Null]',
        objectTag = '[object Object]',
        promiseTag = '[object Promise]',
        proxyTag = '[object Proxy]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        symbolTag = '[object Symbol]',
        undefinedTag = '[object Undefined]',
        weakMapTag = '[object WeakMap]',
        weakSetTag = '[object WeakSet]';

      const arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

      /** Used to match empty string literals in compiled template source. */
      const reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

      /** Used to match HTML entities and HTML characters. */
      const reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
        reUnescapedHtml = /[&<>"']/g,
        reHasEscapedHtml = RegExp(reEscapedHtml.source),
        reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

      /** Used to match template delimiters. */
      const reEscape = /<%-([\s\S]+?)%>/g,
        reEvaluate = /<%([\s\S]+?)%>/g,
        reInterpolate = /<%=([\s\S]+?)%>/g;

      /** Used to match property names within property paths. */
      const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        reIsPlainProp = /^\w*$/,
        rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      const reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
        reHasRegExpChar = RegExp(reRegExpChar.source);

      /** Used to match leading whitespace. */
      const reTrimStart = /^\s+/;

      /** Used to match a single whitespace character. */
      const reWhitespace = /\s/;

      /** Used to match wrap detail comments. */
      const reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
        reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
        reSplitDetails = /,? & /;

      /** Used to match words composed of alphanumeric characters. */
      const reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

      /**
       * Used to validate the `validate` option in `_.template` variable.
       *
       * Forbids characters which could potentially change the meaning of the function argument definition:
       * - "()," (modification of function parameters)
       * - "=" (default value)
       * - "[]{}" (destructuring of function parameters)
       * - "/" (beginning of a comment)
       * - whitespace
       */
      const reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

      /** Used to match backslashes in property paths. */
      const reEscapeChar = /\\(\\)?/g;

      /**
       * Used to match
       * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
       */
      const reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

      /** Used to match `RegExp` flags from their coerced string values. */
      const reFlags = /\w*$/;

      /** Used to detect bad signed hexadecimal string values. */
      const reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      const reIsBinary = /^0b[01]+$/i;

      /** Used to detect host constructors (Safari). */
      const reIsHostCtor = /^\[object .+?Constructor\]$/;

      /** Used to detect octal string values. */
      const reIsOctal = /^0o[0-7]+$/i;

      /** Used to detect unsigned integer values. */
      const reIsUint = /^(?:0|[1-9]\d*)$/;

      /** Used to match Latin Unicode letters (excluding mathematical operators). */
      const reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

      /** Used to ensure capturing order of template delimiters. */
      const reNoMatch = /($^)/;

      /** Used to match unescaped characters in compiled string literals. */
      const reUnescapedString = /['\n\r\u2028\u2029\\]/g;

      /** Used to compose unicode character classes. */
      const rsAstralRange = '\\ud800-\\udfff',
        rsComboMarksRange = '\\u0300-\\u036f',
        reComboHalfMarksRange = '\\ufe20-\\ufe2f',
        rsComboSymbolsRange = '\\u20d0-\\u20ff',
        rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
        rsDingbatRange = '\\u2700-\\u27bf',
        rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
        rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
        rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
        rsPunctuationRange = '\\u2000-\\u206f',
        rsSpaceRange =
          ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
        rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
        rsVarRange = '\\ufe0e\\ufe0f',
        rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

      /** Used to compose unicode capture groups. */
      const rsApos = "['\u2019]",
        rsAstral = '[' + rsAstralRange + ']',
        rsBreak = '[' + rsBreakRange + ']',
        rsCombo = '[' + rsComboRange + ']',
        rsDigits = '\\d+',
        rsDingbat = '[' + rsDingbatRange + ']',
        rsLower = '[' + rsLowerRange + ']',
        rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
        rsFitz = '\\ud83c[\\udffb-\\udfff]',
        rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
        rsNonAstral = '[^' + rsAstralRange + ']',
        rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
        rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
        rsUpper = '[' + rsUpperRange + ']',
        rsZWJ = '\\u200d';

      /** Used to compose unicode regexes. */
      const rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
        rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
        rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
        rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
        reOptMod = rsModifier + '?',
        rsOptVar = '[' + rsVarRange + ']?',
        rsOptJoin =
          '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
        rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
        rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
        rsSeq = rsOptVar + reOptMod + rsOptJoin,
        rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
        rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

      /** Used to match apostrophes. */
      const reApos = RegExp(rsApos, 'g');

      /**
       * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
       * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
       */
      const reComboMark = RegExp(rsCombo, 'g');

      /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
      const reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

      /** Used to match complex or compound words. */
      const reUnicodeWord = RegExp(
        [
          rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
          rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
          rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
          rsUpper + '+' + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji,
        ].join('|'),
        'g',
      );

      /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
      const reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');

      /** Used to detect strings that need a more robust regexp to match words. */
      const reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

      /** Used to assign default `context` object properties. */
      const contextProps = [
        'Array',
        'Buffer',
        'DataView',
        'Date',
        'Error',
        'Float32Array',
        'Float64Array',
        'Function',
        'Int8Array',
        'Int16Array',
        'Int32Array',
        'Map',
        'Math',
        'Object',
        'Promise',
        'RegExp',
        'Set',
        'String',
        'Symbol',
        'TypeError',
        'Uint8Array',
        'Uint8ClampedArray',
        'Uint16Array',
        'Uint32Array',
        'WeakMap',
        '_',
        'clearTimeout',
        'isFinite',
        'parseInt',
        'setTimeout',
      ];

      /** Used to make template sourceURLs easier to identify. */
      let templateCounter = -1;

      /** Used to identify `toStringTag` values of typed arrays. */
      const typedArrayTags = {};
      typedArrayTags[float32Tag] =
        typedArrayTags[float64Tag] =
        typedArrayTags[int8Tag] =
        typedArrayTags[int16Tag] =
        typedArrayTags[int32Tag] =
        typedArrayTags[uint8Tag] =
        typedArrayTags[uint8ClampedTag] =
        typedArrayTags[uint16Tag] =
        typedArrayTags[uint32Tag] =
          true;
      typedArrayTags[argsTag] =
        typedArrayTags[arrayTag] =
        typedArrayTags[arrayBufferTag] =
        typedArrayTags[boolTag] =
        typedArrayTags[dataViewTag] =
        typedArrayTags[dateTag] =
        typedArrayTags[errorTag] =
        typedArrayTags[funcTag] =
        typedArrayTags[mapTag] =
        typedArrayTags[numberTag] =
        typedArrayTags[objectTag] =
        typedArrayTags[regexpTag] =
        typedArrayTags[setTag] =
        typedArrayTags[stringTag] =
        typedArrayTags[weakMapTag] =
          false;

      /** Used to identify `toStringTag` values supported by `_.clone`. */
      const cloneableTags = {};
      cloneableTags[argsTag] =
        cloneableTags[arrayTag] =
        cloneableTags[arrayBufferTag] =
        cloneableTags[dataViewTag] =
        cloneableTags[boolTag] =
        cloneableTags[dateTag] =
        cloneableTags[float32Tag] =
        cloneableTags[float64Tag] =
        cloneableTags[int8Tag] =
        cloneableTags[int16Tag] =
        cloneableTags[int32Tag] =
        cloneableTags[mapTag] =
        cloneableTags[numberTag] =
        cloneableTags[objectTag] =
        cloneableTags[regexpTag] =
        cloneableTags[setTag] =
        cloneableTags[stringTag] =
        cloneableTags[symbolTag] =
        cloneableTags[uint8Tag] =
        cloneableTags[uint8ClampedTag] =
        cloneableTags[uint16Tag] =
        cloneableTags[uint32Tag] =
          true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

      /** Used to map Latin Unicode letters to basic Latin letters. */
      const deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A',
        '\xc1': 'A',
        '\xc2': 'A',
        '\xc3': 'A',
        '\xc4': 'A',
        '\xc5': 'A',
        '\xe0': 'a',
        '\xe1': 'a',
        '\xe2': 'a',
        '\xe3': 'a',
        '\xe4': 'a',
        '\xe5': 'a',
        '\xc7': 'C',
        '\xe7': 'c',
        '\xd0': 'D',
        '\xf0': 'd',
        '\xc8': 'E',
        '\xc9': 'E',
        '\xca': 'E',
        '\xcb': 'E',
        '\xe8': 'e',
        '\xe9': 'e',
        '\xea': 'e',
        '\xeb': 'e',
        '\xcc': 'I',
        '\xcd': 'I',
        '\xce': 'I',
        '\xcf': 'I',
        '\xec': 'i',
        '\xed': 'i',
        '\xee': 'i',
        '\xef': 'i',
        '\xd1': 'N',
        '\xf1': 'n',
        '\xd2': 'O',
        '\xd3': 'O',
        '\xd4': 'O',
        '\xd5': 'O',
        '\xd6': 'O',
        '\xd8': 'O',
        '\xf2': 'o',
        '\xf3': 'o',
        '\xf4': 'o',
        '\xf5': 'o',
        '\xf6': 'o',
        '\xf8': 'o',
        '\xd9': 'U',
        '\xda': 'U',
        '\xdb': 'U',
        '\xdc': 'U',
        '\xf9': 'u',
        '\xfa': 'u',
        '\xfb': 'u',
        '\xfc': 'u',
        '\xdd': 'Y',
        '\xfd': 'y',
        '\xff': 'y',
        '\xc6': 'Ae',
        '\xe6': 'ae',
        '\xde': 'Th',
        '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        '\u0100': 'A',
        '\u0102': 'A',
        '\u0104': 'A',
        '\u0101': 'a',
        '\u0103': 'a',
        '\u0105': 'a',
        '\u0106': 'C',
        '\u0108': 'C',
        '\u010a': 'C',
        '\u010c': 'C',
        '\u0107': 'c',
        '\u0109': 'c',
        '\u010b': 'c',
        '\u010d': 'c',
        '\u010e': 'D',
        '\u0110': 'D',
        '\u010f': 'd',
        '\u0111': 'd',
        '\u0112': 'E',
        '\u0114': 'E',
        '\u0116': 'E',
        '\u0118': 'E',
        '\u011a': 'E',
        '\u0113': 'e',
        '\u0115': 'e',
        '\u0117': 'e',
        '\u0119': 'e',
        '\u011b': 'e',
        '\u011c': 'G',
        '\u011e': 'G',
        '\u0120': 'G',
        '\u0122': 'G',
        '\u011d': 'g',
        '\u011f': 'g',
        '\u0121': 'g',
        '\u0123': 'g',
        '\u0124': 'H',
        '\u0126': 'H',
        '\u0125': 'h',
        '\u0127': 'h',
        '\u0128': 'I',
        '\u012a': 'I',
        '\u012c': 'I',
        '\u012e': 'I',
        '\u0130': 'I',
        '\u0129': 'i',
        '\u012b': 'i',
        '\u012d': 'i',
        '\u012f': 'i',
        '\u0131': 'i',
        '\u0134': 'J',
        '\u0135': 'j',
        '\u0136': 'K',
        '\u0137': 'k',
        '\u0138': 'k',
        '\u0139': 'L',
        '\u013b': 'L',
        '\u013d': 'L',
        '\u013f': 'L',
        '\u0141': 'L',
        '\u013a': 'l',
        '\u013c': 'l',
        '\u013e': 'l',
        '\u0140': 'l',
        '\u0142': 'l',
        '\u0143': 'N',
        '\u0145': 'N',
        '\u0147': 'N',
        '\u014a': 'N',
        '\u0144': 'n',
        '\u0146': 'n',
        '\u0148': 'n',
        '\u014b': 'n',
        '\u014c': 'O',
        '\u014e': 'O',
        '\u0150': 'O',
        '\u014d': 'o',
        '\u014f': 'o',
        '\u0151': 'o',
        '\u0154': 'R',
        '\u0156': 'R',
        '\u0158': 'R',
        '\u0155': 'r',
        '\u0157': 'r',
        '\u0159': 'r',
        '\u015a': 'S',
        '\u015c': 'S',
        '\u015e': 'S',
        '\u0160': 'S',
        '\u015b': 's',
        '\u015d': 's',
        '\u015f': 's',
        '\u0161': 's',
        '\u0162': 'T',
        '\u0164': 'T',
        '\u0166': 'T',
        '\u0163': 't',
        '\u0165': 't',
        '\u0167': 't',
        '\u0168': 'U',
        '\u016a': 'U',
        '\u016c': 'U',
        '\u016e': 'U',
        '\u0170': 'U',
        '\u0172': 'U',
        '\u0169': 'u',
        '\u016b': 'u',
        '\u016d': 'u',
        '\u016f': 'u',
        '\u0171': 'u',
        '\u0173': 'u',
        '\u0174': 'W',
        '\u0175': 'w',
        '\u0176': 'Y',
        '\u0177': 'y',
        '\u0178': 'Y',
        '\u0179': 'Z',
        '\u017b': 'Z',
        '\u017d': 'Z',
        '\u017a': 'z',
        '\u017c': 'z',
        '\u017e': 'z',
        '\u0132': 'IJ',
        '\u0133': 'ij',
        '\u0152': 'Oe',
        '\u0153': 'oe',
        '\u0149': "'n",
        '\u017f': 's',
      };

      /** Used to map characters to HTML entities. */
      const htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
      };

      /** Used to map HTML entities to characters. */
      const htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'",
      };

      /** Used to escape characters for inclusion in compiled string literals. */
      const stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029',
      };

      /** Built-in method references without a dependency on `root`. */
      const freeParseFloat = parseFloat,
        freeParseInt = parseInt;

      /** Detect free variable `global` from Node.js. */
      const freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

      /** Detect free variable `self`. */
      const freeSelf = typeof self == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      const root = freeGlobal || freeSelf || Function('return this')();

      /** Detect free variable `exports`. */
      const freeExports = true && exports && !exports.nodeType && exports;

      /** Detect free variable `module`. */
      const freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

      /** Detect the popular CommonJS extension `module.exports`. */
      const moduleExports = freeModule && freeModule.exports === freeExports;

      /** Detect free variable `process` from Node.js. */
      const freeProcess = moduleExports && freeGlobal.process;

      /** Used to access faster Node.js helpers. */
      const nodeUtil = (function () {
        try {
          // Use `util.types` for Node.js 10+.
          const types = freeModule && freeModule.require && freeModule.require('util').types;

          if (types) {
            return types;
          }

          // Legacy `process.binding('util')` for Node.js < 10.
          return freeProcess && freeProcess.binding && freeProcess.binding('util');
        } catch (e) {}
      })();

      /* Node.js helper references. */
      const nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
        nodeIsDate = nodeUtil && nodeUtil.isDate,
        nodeIsMap = nodeUtil && nodeUtil.isMap,
        nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
        nodeIsSet = nodeUtil && nodeUtil.isSet,
        nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

      /*--------------------------------------------------------------------------*/

      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }

      /**
       * A specialized version of `baseAggregator` for arrays.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function arrayAggregator(array, setter, iteratee, accumulator) {
        let index = -1,
          length = array == null ? 0 : array.length;

        while (++index < length) {
          const value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.forEach` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        let index = -1,
          length = array == null ? 0 : array.length;

        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.forEachRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEachRight(array, iteratee) {
        let length = array == null ? 0 : array.length;

        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.every` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       */
      function arrayEvery(array, predicate) {
        let index = -1,
          length = array == null ? 0 : array.length;

        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }

      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        let index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

        while (++index < length) {
          const value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        const length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }

      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        let index = -1,
          length = array == null ? 0 : array.length;

        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }

      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        let index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        let index = -1,
          length = values.length,
          offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }

      /**
       * A specialized version of `_.reduce` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the first element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        let index = -1,
          length = array == null ? 0 : array.length;

        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.reduceRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the last element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        let length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.some` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function arraySome(array, predicate) {
        let index = -1,
          length = array == null ? 0 : array.length;

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Gets the size of an ASCII `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      const asciiSize = baseProperty('length');

      /**
       * Converts an ASCII `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function asciiToArray(string) {
        return string.split('');
      }

      /**
       * Splits an ASCII `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }

      /**
       * The base implementation of methods like `_.findKey` and `_.findLastKey`,
       * without support for iteratee shorthands, which iterates over `collection`
       * using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the found element or its key, else `undefined`.
       */
      function baseFindKey(collection, predicate, eachFunc) {
        let result;
        eachFunc(collection, function (value, key, collection) {
          if (predicate(value, key, collection)) {
            result = key;
            return false;
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        let length = array.length,
          index = fromIndex + (fromRight ? 1 : -1);

        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }

      /**
       * This function is like `baseIndexOf` except that it accepts a comparator.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        let index = fromIndex - 1,
          length = array.length;

        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.isNaN` without support for number objects.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       */
      function baseIsNaN(value) {
        return value !== value;
      }

      /**
       * The base implementation of `_.mean` and `_.meanBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the mean.
       */
      function baseMean(array, iteratee) {
        const length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }

      /**
       * The base implementation of `_.property` without support for deep paths.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function baseProperty(key) {
        return function (object) {
          return object == null ? undefined : object[key];
        };
      }

      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyOf(object) {
        return function (key) {
          return object == null ? undefined : object[key];
        };
      }

      /**
       * The base implementation of `_.reduce` and `_.reduceRight`, without support
       * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} accumulator The initial value.
       * @param {boolean} initAccum Specify using the first or last element of
       *  `collection` as the initial value.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the accumulated value.
       */
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function (value, index, collection) {
          accumulator = initAccum ? ((initAccum = false), value) : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }

      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define the
       * sort order of `array` and replaces criteria objects with their corresponding
       * values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        let length = array.length;

        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }

      /**
       * The base implementation of `_.sum` and `_.sumBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the sum.
       */
      function baseSum(array, iteratee) {
        let result,
          index = -1,
          length = array.length;

        while (++index < length) {
          const current = iteratee(array[index]);
          if (current !== undefined) {
            result = result === undefined ? current : result + current;
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        let index = -1,
          result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }

      /**
       * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
       * of key-value pairs for `object` corresponding to the property names of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the key-value pairs.
       */
      function baseToPairs(object, props) {
        return arrayMap(props, function (key) {
          return [key, object[key]];
        });
      }

      /**
       * The base implementation of `_.trim`.
       *
       * @private
       * @param {string} string The string to trim.
       * @returns {string} Returns the trimmed string.
       */
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
      }

      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function (value) {
          return func(value);
        };
      }

      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        return arrayMap(props, function (key) {
          return object[key];
        });
      }

      /**
       * Checks if a `cache` value for `key` exists.
       *
       * @private
       * @param {Object} cache The cache to query.
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function cacheHas(cache, key) {
        return cache.has(key);
      }

      /**
       * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the first unmatched string symbol.
       */
      function charsStartIndex(strSymbols, chrSymbols) {
        let index = -1,
          length = strSymbols.length;

        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the last unmatched string symbol.
       */
      function charsEndIndex(strSymbols, chrSymbols) {
        let index = strSymbols.length;

        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Gets the number of `placeholder` occurrences in `array`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} placeholder The placeholder to search for.
       * @returns {number} Returns the placeholder count.
       */
      function countHolders(array, placeholder) {
        let length = array.length,
          result = 0;

        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }

      /**
       * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
       * letters to basic Latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      const deburrLetter = basePropertyOf(deburredLetters);

      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      const escapeHtmlChar = basePropertyOf(htmlEscapes);

      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }

      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined : object[key];
      }

      /**
       * Checks if `string` contains Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a symbol is found, else `false`.
       */
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }

      /**
       * Checks if `string` contains a word composed of Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a word is found, else `false`.
       */
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }

      /**
       * Converts `iterator` to an array.
       *
       * @private
       * @param {Object} iterator The iterator to convert.
       * @returns {Array} Returns the converted array.
       */
      function iteratorToArray(iterator) {
        let data,
          result = [];

        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }

      /**
       * Converts `map` to its key-value pairs.
       *
       * @private
       * @param {Object} map The map to convert.
       * @returns {Array} Returns the key-value pairs.
       */
      function mapToArray(map) {
        let index = -1,
          result = Array(map.size);

        map.forEach(function (value, key) {
          result[++index] = [key, value];
        });
        return result;
      }

      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function (arg) {
          return func(transform(arg));
        };
      }

      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        let index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

        while (++index < length) {
          const value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }

      /**
       * Converts `set` to an array of its values.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the values.
       */
      function setToArray(set) {
        let index = -1,
          result = Array(set.size);

        set.forEach(function (value) {
          result[++index] = value;
        });
        return result;
      }

      /**
       * Converts `set` to its value-value pairs.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the value-value pairs.
       */
      function setToPairs(set) {
        let index = -1,
          result = Array(set.size);

        set.forEach(function (value) {
          result[++index] = [value, value];
        });
        return result;
      }

      /**
       * A specialized version of `_.indexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictIndexOf(array, value, fromIndex) {
        let index = fromIndex - 1,
          length = array.length;

        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }

      /**
       * A specialized version of `_.lastIndexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictLastIndexOf(array, value, fromIndex) {
        let index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }

      /**
       * Gets the number of symbols in `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the string size.
       */
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }

      /**
       * Converts `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
       * character of `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the index of the last non-whitespace character.
       */
      function trimmedEndIndex(string) {
        let index = string.length;

        while (index-- && reWhitespace.test(string.charAt(index))) {}
        return index;
      }

      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      const unescapeHtmlChar = basePropertyOf(htmlUnescapes);

      /**
       * Gets the size of a Unicode `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      function unicodeSize(string) {
        let result = (reUnicode.lastIndex = 0);
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }

      /**
       * Converts a Unicode `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }

      /**
       * Splits a Unicode `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }

      /*--------------------------------------------------------------------------*/

      /**
       * Create a new pristine `lodash` function using the `context` object.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Util
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // Create a suped-up `defer` in Node.js.
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      const runInContext = function runInContext(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

        /** Built-in constructor references. */
        const Array = context.Array,
          Date = context.Date,
          Error = context.Error,
          Function = context.Function,
          Math = context.Math,
          Object = context.Object,
          RegExp = context.RegExp,
          String = context.String,
          TypeError = context.TypeError;

        /** Used for built-in method references. */
        const arrayProto = Array.prototype,
          funcProto = Function.prototype,
          objectProto = Object.prototype;

        /** Used to detect overreaching core-js shims. */
        const coreJsData = context['__core-js_shared__'];

        /** Used to resolve the decompiled source of functions. */
        const funcToString = funcProto.toString;

        /** Used to check objects for own properties. */
        const hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to generate unique IDs. */
        let idCounter = 0;

        /** Used to detect methods masquerading as native. */
        const maskSrcKey = (function () {
          const uid = /[^.]+$/.exec((coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO) || '');
          return uid ? 'Symbol(src)_1.' + uid : '';
        })();

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        const nativeObjectToString = objectProto.toString;

        /** Used to infer the `Object` constructor. */
        const objectCtorString = funcToString.call(Object);

        /** Used to restore the original `_` reference in `_.noConflict`. */
        const oldDash = root._;

        /** Used to detect if a method is native. */
        const reIsNative = RegExp(
          '^' +
            funcToString
              .call(hasOwnProperty)
              .replace(reRegExpChar, '\\$&')
              .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') +
            '$',
        );

        /** Built-in value references. */
        const Buffer = moduleExports ? context.Buffer : undefined,
          Symbol = context.Symbol,
          Uint8Array = context.Uint8Array,
          allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
          getPrototype = overArg(Object.getPrototypeOf, Object),
          objectCreate = Object.create,
          propertyIsEnumerable = objectProto.propertyIsEnumerable,
          splice = arrayProto.splice,
          spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
          symIterator = Symbol ? Symbol.iterator : undefined,
          symToStringTag = Symbol ? Symbol.toStringTag : undefined;

        const defineProperty = (function () {
          try {
            const func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        })();

        /** Mocked built-ins. */
        const ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
          ctxNow = Date && Date.now !== root.Date.now && Date.now,
          ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        const nativeCeil = Math.ceil,
          nativeFloor = Math.floor,
          nativeGetSymbols = Object.getOwnPropertySymbols,
          nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
          nativeIsFinite = context.isFinite,
          nativeJoin = arrayProto.join,
          nativeKeys = overArg(Object.keys, Object),
          nativeMax = Math.max,
          nativeMin = Math.min,
          nativeNow = Date.now,
          nativeParseInt = context.parseInt,
          nativeRandom = Math.random,
          nativeReverse = arrayProto.reverse;

        /* Built-in method references that are verified to be native. */
        const DataView = getNative(context, 'DataView'),
          Map = getNative(context, 'Map'),
          Promise = getNative(context, 'Promise'),
          Set = getNative(context, 'Set'),
          WeakMap = getNative(context, 'WeakMap'),
          nativeCreate = getNative(Object, 'create');

        /** Used to store function metadata. */
        const metaMap = WeakMap && new WeakMap();

        /** Used to lookup unminified function names. */
        const realNames = {};

        /** Used to detect maps, sets, and weakmaps. */
        const dataViewCtorString = toSource(DataView),
          mapCtorString = toSource(Map),
          promiseCtorString = toSource(Promise),
          setCtorString = toSource(Set),
          weakMapCtorString = toSource(WeakMap);

        /** Used to convert symbols to primitives and strings. */
        const symbolProto = Symbol ? Symbol.prototype : undefined,
          symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
          symbolToString = symbolProto ? symbolProto.toString : undefined;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` object which wraps `value` to enable implicit method
         * chain sequences. Methods that operate on and return arrays, collections,
         * and functions can be chained together. Methods that retrieve a single value
         * or may return a primitive value will automatically end the chain sequence
         * and return the unwrapped value. Otherwise, the value must be unwrapped
         * with `_#value`.
         *
         * Explicit chain sequences, which must be unwrapped with `_#value`, may be
         * enabled using `_.chain`.
         *
         * The execution of chained methods is lazy, that is, it's deferred until
         * `_#value` is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion.
         * Shortcut fusion is an optimization to merge iteratee calls; this avoids
         * the creation of intermediate arrays and can greatly reduce the number of
         * iteratee executions. Sections of a chain sequence qualify for shortcut
         * fusion if the section is applied to an array and iteratees accept only
         * one argument. The heuristic for whether a section qualifies for shortcut
         * fusion is subject to change.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
         * `zipObject`, `zipObjectDeep`, and `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
         * `upperFirst`, `value`, and `words`
         *
         * @name _
         * @constructor
         * @category Seq
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // Returns an unwrapped value.
         * wrapped.reduce(_.add);
         * // => 6
         *
         * // Returns a wrapped value.
         * var squares = wrapped.map(square);
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        const baseCreate = (function () {
          function object() {}
          return function (proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            const result = new object();
            object.prototype = undefined;
            return result;
          };
        })();

        /**
         * The function whose prototype chain sequence wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }

        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable explicit method chain sequences.
         */
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined;
        }

        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
         * following template settings to use alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type {Object}
         */
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          escape: reEscape,

          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          evaluate: reEvaluate,

          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          interpolate: reInterpolate,

          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          variable: '',

          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          imports: {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            _: lodash,
          },
        };

        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;

        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @constructor
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }

        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          const result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = copyArray(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = copyArray(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = copyArray(this.__views__);
          return result;
        }

        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }

        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          let array = this.__wrapped__.value(),
            dir = this.__dir__,
            isArr = isArray(array),
            isRight = dir < 0,
            arrLength = isArr ? array.length : 0,
            view = getView(0, arrLength, this.__views__),
            start = view.start,
            end = view.end,
            length = end - start,
            index = isRight ? end : start - 1,
            iteratees = this.__iteratees__,
            iterLength = iteratees.length,
            resIndex = 0,
            takeCount = nativeMin(length, this.__takeCount__);

          if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          const result = [];

          outer: while (length-- && resIndex < takeCount) {
            index += dir;

            let iterIndex = -1,
              value = array[index];

            while (++iterIndex < iterLength) {
              const data = iteratees[iterIndex],
                iteratee = data.iteratee,
                type = data.type,
                computed = iteratee(value);

              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }

        // Ensure `LazyWrapper` is an instance of `baseLodash`.
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash(entries) {
          let index = -1,
            length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            const entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          const result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(key) {
          const data = this.__data__;
          if (nativeCreate) {
            const result = data[key];
            return result === HASH_UNDEFINED ? undefined : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined;
        }

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(key) {
          const data = this.__data__;
          return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
        }

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet(key, value) {
          const data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
          return this;
        }

        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache(entries) {
          let index = -1,
            length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            const entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete(key) {
          const data = this.__data__,
            index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }
          const lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet(key) {
          const data = this.__data__,
            index = assocIndexOf(data, key);

          return index < 0 ? undefined : data[index][1];
        }

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet(key, value) {
          const data = this.__data__,
            index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }

        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache(entries) {
          let index = -1,
            length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            const entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            hash: new Hash(),
            map: new (Map || ListCache)(),
            string: new Hash(),
          };
        }

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete(key) {
          const result = getMapData(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet(key, value) {
          const data = getMapData(this, key),
            size = data.size;

          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          let index = -1,
            length = values == null ? 0 : values.length;

          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values[index]);
          }
        }

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack(entries) {
          const data = (this.__data__ = new ListCache(entries));
          this.size = data.size;
        }

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          const data = this.__data__,
            result = data['delete'](key);

          this.size = data.size;
          return result;
        }

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet(key, value) {
          let data = this.__data__;
          if (data instanceof ListCache) {
            const pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }

        // Add methods to `Stack`.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
          const isArr = isArray(value),
            isArg = !isArr && isArguments(value),
            isBuff = !isArr && !isArg && isBuffer(value),
            isType = !isArr && !isArg && !isBuff && isTypedArray(value),
            skipIndexes = isArr || isArg || isBuff || isType,
            result = skipIndexes ? baseTimes(value.length, String) : [],
            length = result.length;

          for (const key in value) {
            if (
              (inherited || hasOwnProperty.call(value, key)) &&
              !(
                skipIndexes &&
                // Safari 9 has enumerable `arguments.length` in strict mode.
                (key == 'length' ||
                  // Node.js 0.10 has enumerable non-index properties on buffers.
                  (isBuff && (key == 'offset' || key == 'parent')) ||
                  // PhantomJS 2 has enumerable non-index properties on typed arrays.
                  (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                  // Skip index properties.
                  isIndex(key, length))
              )
            ) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * A specialized version of `_.sample` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @returns {*} Returns the random element.
         */
        function arraySample(array) {
          const length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined;
        }

        /**
         * A specialized version of `_.sampleSize` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }

        /**
         * A specialized version of `_.shuffle` for arrays.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue(object, key, value) {
          if ((value !== undefined && !eq(object[key], value)) || (value === undefined && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
          const objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || (value === undefined && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          let length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }

        /**
         * Aggregates elements of `collection` on `accumulator` with keys transformed
         * by `iteratee` and values set by `setter`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function (value, key, collection) {
            setter(accumulator, value, iteratee(value), collection);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }

        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue(object, key, value) {
          if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true,
            });
          } else {
            object[key] = value;
          }
        }

        /**
         * The base implementation of `_.at` without support for individual paths.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {string[]} paths The property paths to pick.
         * @returns {Array} Returns the picked elements.
         */
        function baseAt(object, paths) {
          let index = -1,
            length = paths.length,
            result = Array(length),
            skip = object == null;

          while (++index < length) {
            result[index] = skip ? undefined : get(object, paths[index]);
          }
          return result;
        }

        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }

        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, bitmask, customizer, key, object, stack) {
          let result,
            isDeep = bitmask & CLONE_DEEP_FLAG,
            isFlat = bitmask & CLONE_FLAT_FLAG,
            isFull = bitmask & CLONE_SYMBOLS_FLAG;

          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          const isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            const tag = getTag(value),
              isFunc = tag == funcTag || tag == genTag;

            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result, value))
                  : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack());
          const stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);

          if (isSet(value)) {
            value.forEach(function (subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function (subValue, key) {
              result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
          }

          const keysFunc = isFull ? (isFlat ? getAllKeysIn : getAllKeys) : isFlat ? keysIn : keys;

          const props = isArr ? undefined : keysFunc(value);
          arrayEach(props || value, function (subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }

        /**
         * The base implementation of `_.conforms` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         */
        function baseConforms(source) {
          const props = keys(source);
          return function (object) {
            return baseConformsTo(object, source, props);
          };
        }

        /**
         * The base implementation of `_.conformsTo` which accepts `props` to check.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         */
        function baseConformsTo(object, source, props) {
          let length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (length--) {
            const key = props[length],
              predicate = source[key],
              value = object[key];

            if ((value === undefined && !(key in object)) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.delay` and `_.defer` which accepts `args`
         * to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Array} args The arguments to provide to `func`.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function () {
            func.apply(undefined, args);
          }, wait);
        }

        /**
         * The base implementation of methods like `_.difference` without support
         * for excluding multiple arrays or iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values, iteratee, comparator) {
          let index = -1,
            includes = arrayIncludes,
            isCommon = true,
            length = array.length,
            result = [],
            valuesLength = values.length;

          if (!length) {
            return result;
          }
          if (iteratee) {
            values = arrayMap(values, baseUnary(iteratee));
          }
          if (comparator) {
            includes = arrayIncludesWith;
            isCommon = false;
          } else if (values.length >= LARGE_ARRAY_SIZE) {
            includes = cacheHas;
            isCommon = false;
            values = new SetCache(values);
          }
          outer: while (++index < length) {
            let value = array[index],
              computed = iteratee == null ? value : iteratee(value);

            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              let valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            } else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        /**
         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        const baseEachRight = createBaseEach(baseForOwnRight, true);

        /**
         * The base implementation of `_.every` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          let result = true;
          baseEach(collection, function (value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }

        /**
         * The base implementation of methods like `_.max` and `_.min` which accepts a
         * `comparator` to determine the extremum value.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The iteratee invoked per iteration.
         * @param {Function} comparator The comparator used to compare values.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(array, iteratee, comparator) {
          let index = -1,
            length = array.length;

          while (++index < length) {
            const value = array[index],
              current = iteratee(value);

            if (
              current != null &&
              (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))
            ) {
              var computed = current,
                result = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          const length = array.length;

          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }

        /**
         * The base implementation of `_.filter` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          const result = [];
          baseEach(collection, function (value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }

        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, depth, predicate, isStrict, result) {
          let index = -1,
            length = array.length;

          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            const value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        const baseFor = createBaseFor();

        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        const baseForRight = createBaseFor(true);

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return object && baseForRight(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from `props`.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the function names.
         */
        function baseFunctions(object, props) {
          return arrayFilter(props, function (key) {
            return isFunction(object[key]);
          });
        }

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path) {
          path = castPath(path, object);

          let index = 0,
            length = path.length;

          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined;
        }

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          const result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }

        /**
         * The base implementation of `_.gt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         */
        function baseGt(value, other) {
          return value > other;
        }

        /**
         * The base implementation of `_.has` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        /**
         * The base implementation of `_.inRange` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to check.
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         */
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }

        /**
         * The base implementation of methods like `_.intersection`, without support
         * for iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of shared values.
         */
        function baseIntersection(arrays, iteratee, comparator) {
          let includes = comparator ? arrayIncludesWith : arrayIncludes,
            length = arrays[0].length,
            othLength = arrays.length,
            othIndex = othLength,
            caches = Array(othLength),
            maxLength = Infinity,
            result = [];

          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee) {
              array = arrayMap(array, baseUnary(iteratee));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] =
              !comparator && (iteratee || (length >= 120 && array.length >= 120))
                ? new SetCache(othIndex && array)
                : undefined;
          }
          array = arrays[0];

          let index = -1,
            seen = caches[0];

          outer: while (++index < length && result.length < maxLength) {
            let value = array[index],
              computed = iteratee ? iteratee(value) : value;

            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                const cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.invert` and `_.invertBy` which inverts
         * `object` with values transformed by `iteratee` and set by `setter`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform values.
         * @param {Object} accumulator The initial inverted object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseInverter(object, setter, iteratee, accumulator) {
          baseForOwn(object, function (value, key, object) {
            setter(accumulator, iteratee(value), key, object);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.invoke` without support for individual
         * method arguments.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          const func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined : apply(func, object, args);
        }

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        /**
         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         */
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }

        /**
         * The base implementation of `_.isDate` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         */
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          let objIsArr = isArray(object),
            othIsArr = isArray(other),
            objTag = objIsArr ? arrayTag : getTag(object),
            othTag = othIsArr ? arrayTag : getTag(other);

          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;

          let objIsObj = objTag == objectTag,
            othIsObj = othTag == objectTag,
            isSameTag = objTag == othTag;

          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object)
              ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
              : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            const objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
              othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

            if (objIsWrapped || othIsWrapped) {
              const objUnwrapped = objIsWrapped ? object.value() : object,
                othUnwrapped = othIsWrapped ? other.value() : other;

              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }

        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          let index = matchData.length,
            length = index,
            noCustomizer = !customizer;

          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            const key = data[0],
              objValue = object[key],
              srcValue = data[1];

            if (noCustomizer && data[2]) {
              if (objValue === undefined && !(key in object)) {
                return false;
              }
            } else {
              const stack = new Stack();
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (
                !(result === undefined
                  ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                  : result)
              ) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          const pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        /**
         * The base implementation of `_.isRegExp` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         */
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }

        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == 'object') {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          const result = [];
          for (const key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          const isProto = isPrototype(object),
            result = [];

          for (const key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.lt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         */
        function baseLt(value, other) {
          return value < other;
        }

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          let index = -1,
            result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function (value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches(source) {
          const matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function (object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function (object) {
            const objValue = get(object, path);
            return objValue === undefined && objValue === srcValue
              ? hasIn(object, path)
              : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(
            source,
            function (srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                let newValue = customizer
                  ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack)
                  : undefined;

                if (newValue === undefined) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            },
            keysIn,
          );
        }

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          const objValue = safeGet(object, key),
            srcValue = safeGet(source, key),
            stacked = stack.get(srcValue);

          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          let newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;

          let isCommon = newValue === undefined;

          if (isCommon) {
            const isArr = isArray(srcValue),
              isBuff = !isArr && isBuffer(srcValue),
              isTyped = !isArr && !isBuff && isTypedArray(srcValue);

            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }

        /**
         * The base implementation of `_.nth` which doesn't coerce arguments.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {number} n The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         */
        function baseNth(array, n) {
          const length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined;
        }

        /**
         * The base implementation of `_.orderBy` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {string[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function (iteratee) {
              if (isArray(iteratee)) {
                return function (value) {
                  return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                };
              }
              return iteratee;
            });
          } else {
            iteratees = [identity];
          }

          let index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

          const result = baseMap(collection, function (value, key, collection) {
            const criteria = arrayMap(iteratees, function (iteratee) {
              return iteratee(value);
            });
            return { criteria: criteria, index: ++index, value: value };
          });

          return baseSortBy(result, function (object, other) {
            return compareMultiple(object, other, orders);
          });
        }

        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick(object, paths) {
          return basePickBy(object, paths, function (value, path) {
            return hasIn(object, path);
          });
        }

        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy(object, paths, predicate) {
          let index = -1,
            length = paths.length,
            result = {};

          while (++index < length) {
            const path = paths[index],
              value = baseGet(object, path);

            if (predicate(value, path)) {
              baseSet(result, castPath(path, object), value);
            }
          }
          return result;
        }

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep(path) {
          return function (object) {
            return baseGet(object, path);
          };
        }

        /**
         * The base implementation of `_.pullAllBy` without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         */
        function basePullAll(array, values, iteratee, comparator) {
          let indexOf = comparator ? baseIndexOfWith : baseIndexOf,
            index = -1,
            length = values.length,
            seen = array;

          if (array === values) {
            values = copyArray(values);
          }
          if (iteratee) {
            seen = arrayMap(array, baseUnary(iteratee));
          }
          while (++index < length) {
            let fromIndex = 0,
              value = values[index],
              computed = iteratee ? iteratee(value) : value;

            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.pullAt` without support for individual
         * indexes or capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          let length = array ? indexes.length : 0,
            lastIndex = length - 1;

          while (length--) {
            const index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.random` without support for returning
         * floating-point numbers.
         *
         * @private
         * @param {number} lower The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the random number.
         */
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }

        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */
        function baseRange(start, end, step, fromRight) {
          let index = -1,
            length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
            result = Array(length);

          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }

        /**
         * The base implementation of `_.repeat` which doesn't coerce arguments.
         *
         * @private
         * @param {string} string The string to repeat.
         * @param {number} n The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         */
        function baseRepeat(string, n) {
          let result = '';
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);

          return result;
        }

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + '');
        }

        /**
         * The base implementation of `_.sample`.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         */
        function baseSample(collection) {
          return arraySample(values(collection));
        }

        /**
         * The base implementation of `_.sampleSize` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function baseSampleSize(collection, n) {
          const array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }

        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);

          let index = -1,
            length = path.length,
            lastIndex = length - 1,
            nested = object;

          while (nested != null && ++index < length) {
            let key = toKey(path[index]),
              newValue = value;

            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
              return object;
            }

            if (index != lastIndex) {
              const objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined;
              if (newValue === undefined) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }

        /**
         * The base implementation of `setData` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        const baseSetData = !metaMap
          ? identity
          : function (func, data) {
              metaMap.set(func, data);
              return func;
            };

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        const baseSetToString = !defineProperty
          ? identity
          : function (func, string) {
              return defineProperty(func, 'toString', {
                configurable: true,
                enumerable: false,
                value: constant(string),
                writable: true,
              });
            };

        /**
         * The base implementation of `_.shuffle`.
         *
         * @private
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }

        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          let index = -1,
            length = array.length;

          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : (end - start) >>> 0;
          start >>>= 0;

          const result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }

        /**
         * The base implementation of `_.some` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          let result;

          baseEach(collection, function (value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }

        /**
         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
         * performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndex(array, value, retHighest) {
          let low = 0,
            high = array == null ? low : array.length;

          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              const mid = (low + high) >>> 1,
                computed = array[mid];

              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }

        /**
         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
         * which invokes `iteratee` for `value` and each element of `array` to compute
         * their sort ranking. The iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The iteratee invoked per element.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
          let low = 0,
            high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }

          value = iteratee(value);
          const valIsNaN = value !== value,
            valIsNull = value === null,
            valIsSymbol = isSymbol(value),
            valIsUndefined = value === undefined;

          while (low < high) {
            const mid = nativeFloor((low + high) / 2),
              computed = iteratee(array[mid]),
              othIsDefined = computed !== undefined,
              othIsNull = computed === null,
              othIsReflexive = computed === computed,
              othIsSymbol = isSymbol(computed);

            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }

        /**
         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseSortedUniq(array, iteratee) {
          let index = -1,
            length = array.length,
            resIndex = 0,
            result = [];

          while (++index < length) {
            const value = array[index],
              computed = iteratee ? iteratee(value) : value;

            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.toNumber` which doesn't ensure correct
         * conversions of binary, hexadecimal, or octal string values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         */
        function baseToNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          const result = value + '';
          return result == '0' && 1 / value == -INFINITY ? '-0' : result;
        }

        /**
         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee, comparator) {
          let index = -1,
            includes = arrayIncludes,
            length = array.length,
            isCommon = true,
            result = [],
            seen = result;

          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            const set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee ? [] : result;
          }
          outer: while (++index < length) {
            let value = array[index],
              computed = iteratee ? iteratee(value) : value;

            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              let seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            } else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }

        /**
         * The base implementation of `_.update`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to update.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }

        /**
         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
         * without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          let length = array.length,
            index = fromRight ? length : -1;

          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}

          return isDrop
            ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length)
            : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }

        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to perform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          let result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          return arrayReduce(
            actions,
            function (result, action) {
              return action.func.apply(action.thisArg, arrayPush([result], action.args));
            },
            result,
          );
        }

        /**
         * The base implementation of methods like `_.xor`, without support for
         * iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of values.
         */
        function baseXor(arrays, iteratee, comparator) {
          const length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          let index = -1,
            result = Array(length);

          while (++index < length) {
            let array = arrays[index],
              othIndex = -1;

            while (++othIndex < length) {
              if (othIndex != index) {
                result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }

        /**
         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
         *
         * @private
         * @param {Array} props The property identifiers.
         * @param {Array} values The property values.
         * @param {Function} assignFunc The function to assign values.
         * @returns {Object} Returns the new object.
         */
        function baseZipObject(props, values, assignFunc) {
          let index = -1,
            length = props.length,
            valsLength = values.length,
            result = {};

          while (++index < length) {
            const value = index < valsLength ? values[index] : undefined;
            assignFunc(result, props[index], value);
          }
          return result;
        }

        /**
         * Casts `value` to an empty array if it's not an array like object.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array|Object} Returns the cast array-like object.
         */
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction(value) {
          return typeof value == 'function' ? value : identity;
        }

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        /**
         * A `baseRest` alias which can be replaced with `identity` by module
         * replacement plugins.
         *
         * @private
         * @type {Function}
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        const castRest = baseRest;

        /**
         * Casts `array` to a slice if it's needed.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {number} start The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the cast slice.
         */
        function castSlice(array, start, end) {
          const length = array.length;
          end = end === undefined ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }

        /**
         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
         *
         * @private
         * @param {number|Object} id The timer id or timeout object of the timer to clear.
         */
        const clearTimeout =
          ctxClearTimeout ||
          function (id) {
            return root.clearTimeout(id);
          };

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          const length = buffer.length,
            result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

          buffer.copy(result);
          return result;
        }

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          const result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */
        function cloneDataView(dataView, isDeep) {
          const buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }

        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp(regexp) {
          const result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }

        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray(typedArray, isDeep) {
          const buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }

        /**
         * Compares values to sort them in ascending order.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function compareAscending(value, other) {
          if (value !== other) {
            const valIsDefined = value !== undefined,
              valIsNull = value === null,
              valIsReflexive = value === value,
              valIsSymbol = isSymbol(value);

            const othIsDefined = other !== undefined,
              othIsNull = other === null,
              othIsReflexive = other === other,
              othIsSymbol = isSymbol(other);

            if (
              (!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
              (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
              (valIsNull && othIsDefined && othIsReflexive) ||
              (!valIsDefined && othIsReflexive) ||
              !valIsReflexive
            ) {
              return 1;
            }
            if (
              (!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
              (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
              (othIsNull && valIsDefined && valIsReflexive) ||
              (!othIsDefined && valIsReflexive) ||
              !othIsReflexive
            ) {
              return -1;
            }
          }
          return 0;
        }

        /**
         * Used by `_.orderBy` to compare multiple properties of a value to another
         * and stable sort them.
         *
         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
         * specify an order of "desc" for descending or "asc" for ascending sort order
         * of corresponding values.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {boolean[]|string[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareMultiple(object, other, orders) {
          let index = -1,
            objCriteria = object.criteria,
            othCriteria = other.criteria,
            length = objCriteria.length,
            ordersLength = orders.length;

          while (++index < length) {
            const result = compareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              const order = orders[index];
              return result * (order == 'desc' ? -1 : 1);
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
          return object.index - other.index;
        }

        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders, isCurried) {
          let argsIndex = -1,
            argsLength = args.length,
            holdersLength = holders.length,
            leftIndex = -1,
            leftLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(leftLength + rangeLength),
            isUncurried = !isCurried;

          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }

        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders, isCurried) {
          let argsIndex = -1,
            argsLength = args.length,
            holdersIndex = -1,
            holdersLength = holders.length,
            rightIndex = -1,
            rightLength = partials.length,
            rangeLength = nativeMax(argsLength - holdersLength, 0),
            result = Array(rangeLength + rightLength),
            isUncurried = !isCurried;

          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          const offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          let index = -1,
            length = source.length;

          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object, customizer) {
          const isNew = !object;
          object || (object = {});

          let index = -1,
            length = props.length;

          while (++index < length) {
            const key = props[index];

            let newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;

            if (newValue === undefined) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }

        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }

        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }

        /**
         * Creates a function like `_.groupBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} [initializer] The accumulator object initializer.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function (collection, iteratee) {
            const func = isArray(collection) ? arrayAggregator : baseAggregator,
              accumulator = initializer ? initializer() : {};

            return func(collection, setter, getIteratee(iteratee, 2), accumulator);
          };
        }

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return baseRest(function (object, sources) {
            let index = -1,
              length = sources.length,
              customizer = length > 1 ? sources[length - 1] : undefined,
              guard = length > 2 ? sources[2] : undefined;

            customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              const source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function (collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            let length = collection.length,
              index = fromRight ? length : -1,
              iterable = Object(collection);

            while (fromRight ? index-- : ++index < length) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function (object, iteratee, keysFunc) {
            let index = -1,
              iterable = Object(object),
              props = keysFunc(object),
              length = props.length;

            while (length--) {
              const key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }

        /**
         * Creates a function that wraps `func` to invoke it with the optional `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createBind(func, bitmask, thisArg) {
          const isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);

          function wrapper() {
            const fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.lowerFirst`.
         *
         * @private
         * @param {string} methodName The name of the `String` case method to use.
         * @returns {Function} Returns the new case function.
         */
        function createCaseFirst(methodName) {
          return function (string) {
            string = toString(string);

            const strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;

            const chr = strSymbols ? strSymbols[0] : string.charAt(0);

            const trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);

            return chr[methodName]() + trailing;
          };
        }

        /**
         * Creates a function like `_.camelCase`.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function (string) {
            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
          };
        }

        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtor(Ctor) {
          return function () {
            // Use a `switch` statement to work with class constructors. See
            // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            const args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            const thisBinding = baseCreate(Ctor.prototype),
              result = Ctor.apply(thisBinding, args);

            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }

        /**
         * Creates a function that wraps `func` to enable currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {number} arity The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCurry(func, bitmask, arity) {
          const Ctor = createCtor(func);

          function wrapper() {
            let length = arguments.length,
              args = Array(length),
              index = length,
              placeholder = getHolder(wrapper);

            while (index--) {
              args[index] = arguments[index];
            }
            const holders =
              length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder
                ? []
                : replaceHolders(args, placeholder);

            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined,
                args,
                holders,
                undefined,
                undefined,
                arity - length,
              );
            }
            const fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} findIndexFunc The function to find the collection index.
         * @returns {Function} Returns the new find function.
         */
        function createFind(findIndexFunc) {
          return function (collection, predicate, fromIndex) {
            const iterable = Object(collection);
            if (!isArrayLike(collection)) {
              var iteratee = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function (key) {
                return iteratee(iterable[key], key, iterable);
              };
            }
            const index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
          };
        }

        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return flatRest(function (funcs) {
            let length = funcs.length,
              index = length,
              prereq = LodashWrapper.prototype.thru;

            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];

              const funcName = getFuncName(func),
                data = funcName == 'wrapper' ? getData(func) : undefined;

              if (
                data &&
                isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length &&
                data[9] == 1
              ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function () {
              const args = arguments,
                value = args[0];

              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              let index = 0,
                result = length ? funcs[index].apply(this, args) : value;

              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          });
        }

        /**
         * Creates a function that wraps `func` to invoke it with optional `this`
         * binding of `thisArg`, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided
         *  to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybrid(
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary,
          arity,
        ) {
          const isAry = bitmask & WRAP_ARY_FLAG,
            isBind = bitmask & WRAP_BIND_FLAG,
            isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
            isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
            isFlip = bitmask & WRAP_FLIP_FLAG,
            Ctor = isBindKey ? undefined : createCtor(func);

          function wrapper() {
            let length = arguments.length,
              args = Array(length),
              index = length;

            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              const newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary,
                arity - length,
              );
            }
            let thisBinding = isBind ? thisArg : this,
              fn = isBindKey ? thisBinding[func] : func;

            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.invertBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} toIteratee The function to resolve iteratees.
         * @returns {Function} Returns the new inverter function.
         */
        function createInverter(setter, toIteratee) {
          return function (object, iteratee) {
            return baseInverter(object, setter, toIteratee(iteratee), {});
          };
        }

        /**
         * Creates a function that performs a mathematical operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @param {number} [defaultValue] The value used for `undefined` arguments.
         * @returns {Function} Returns the new mathematical operation function.
         */
        function createMathOperation(operator, defaultValue) {
          return function (value, other) {
            let result;
            if (value === undefined && other === undefined) {
              return defaultValue;
            }
            if (value !== undefined) {
              result = value;
            }
            if (other !== undefined) {
              if (result === undefined) {
                return other;
              }
              if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result = operator(value, other);
            }
            return result;
          };
        }

        /**
         * Creates a function like `_.over`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over iteratees.
         * @returns {Function} Returns the new over function.
         */
        function createOver(arrayFunc) {
          return flatRest(function (iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function (args) {
              const thisArg = this;
              return arrayFunc(iteratees, function (iteratee) {
                return apply(iteratee, thisArg, args);
              });
            });
          });
        }

        /**
         * Creates the padding for `string` based on `length`. The `chars` string
         * is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {number} length The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padding for `string`.
         */
        function createPadding(length, chars) {
          chars = chars === undefined ? ' ' : baseToString(chars);

          const charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          const result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
        }

        /**
         * Creates a function that wraps `func` to invoke it with the `this` binding
         * of `thisArg` and `partials` prepended to the arguments it receives.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to
         *  the new function.
         * @returns {Function} Returns the new wrapped function.
         */
        function createPartial(func, bitmask, thisArg, partials) {
          const isBind = bitmask & WRAP_BIND_FLAG,
            Ctor = createCtor(func);

          function wrapper() {
            let argsIndex = -1,
              argsLength = arguments.length,
              leftIndex = -1,
              leftLength = partials.length,
              args = Array(leftLength + argsLength),
              fn = this && this !== root && this instanceof wrapper ? Ctor : func;

            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange(fromRight) {
          return function (start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined;
            }
            // Ensure the sign of `-0` is preserved.
            start = toFinite(start);
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }

        /**
         * Creates a function that performs a relational operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @returns {Function} Returns the new relational operation function.
         */
        function createRelationalOperation(operator) {
          return function (value, other) {
            if (!(typeof value == 'string' && typeof other == 'string')) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }

        /**
         * Creates a function that wraps `func` to continue currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {Function} wrapFunc The function to create the `func` wrapper.
         * @param {*} placeholder The placeholder value.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          const isCurry = bitmask & WRAP_CURRY_FLAG,
            newHolders = isCurry ? holders : undefined,
            newHoldersRight = isCurry ? undefined : holders,
            newPartials = isCurry ? partials : undefined,
            newPartialsRight = isCurry ? undefined : partials;

          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          const newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary,
            arity,
          ];

          const result = wrapFunc.apply(undefined, newData);
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return setWrapToString(result, func, bitmask);
        }

        /**
         * Creates a function like `_.round`.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          const func = Math[methodName];
          return function (number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              // Shift with exponential notation to avoid floating-point issues.
              // See [MDN](https://mdn.io/round#Examples) for more details.
              let pair = (toString(number) + 'e').split('e'),
                value = func(pair[0] + 'e' + (+pair[1] + precision));

              pair = (toString(value) + 'e').split('e');
              return +(pair[0] + 'e' + (+pair[1] - precision));
            }
            return func(number);
          };
        }

        /**
         * Creates a set object of `values`.
         *
         * @private
         * @param {Array} values The values to add to the set.
         * @returns {Object} Returns the new set.
         */
        var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY)
          ? noop
          : function (values) {
              return new Set(values);
            };

        /**
         * Creates a `_.toPairs` or `_.toPairsIn` function.
         *
         * @private
         * @param {Function} keysFunc The function to get the keys of a given object.
         * @returns {Function} Returns the new pairs function.
         */
        function createToPairs(keysFunc) {
          return function (object) {
            const tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }

        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags.
         *    1 - `_.bind`
         *    2 - `_.bindKey`
         *    4 - `_.curry` or `_.curryRight` of a bound function
         *    8 - `_.curry`
         *   16 - `_.curryRight`
         *   32 - `_.partial`
         *   64 - `_.partialRight`
         *  128 - `_.rearg`
         *  256 - `_.ary`
         *  512 - `_.flip`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          const isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          let length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined;
          }
          ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === undefined ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;

          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
              holdersRight = holders;

            partials = holders = undefined;
          }
          const data = isBindKey ? undefined : getData(func);

          const newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] =
            newData[9] === undefined ? (isBindKey ? 0 : func.length) : nativeMax(newData[9] - length, 0);

          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result = createCurry(func, bitmask, arity);
          } else if (
            (bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) &&
            !holders.length
          ) {
            result = createPartial(func, bitmask, thisArg, partials);
          } else {
            result = createHybrid.apply(undefined, newData);
          }
          const setter = data ? baseSetData : setData;
          return setWrapToString(setter(result, newData), func, bitmask);
        }

        /**
         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
         * of source objects to the destination object for all destination properties
         * that resolve to `undefined`.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to assign.
         * @param {Object} object The parent object of `objValue`.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined || (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            return srcValue;
          }
          return objValue;
        }

        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
         * objects into destination objects that are passed thru.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to merge.
         * @param {Object} object The parent object of `objValue`.
         * @param {Object} source The parent object of `srcValue`.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
            stack['delete'](srcValue);
          }
          return objValue;
        }

        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined : value;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          const isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            arrLength = array.length,
            othLength = other.length;

          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Check that cyclic values are equal.
          const arrStacked = stack.get(array);
          const othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          let index = -1,
            result = true,
            seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;

          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
              othValue = other[index];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (
                !arraySome(other, function (othValue, othIndex) {
                  if (
                    !cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))
                  ) {
                    return seen.push(othIndex);
                  }
                })
              ) {
                result = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;

            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;

            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);

            case errorTag:
              return object.name == other.name && object.message == other.message;

            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == other + '';

            case mapTag:
              var convert = mapToArray;

            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);

              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;

            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          const isPartial = bitmask & COMPARE_PARTIAL_FLAG,
            objProps = getAllKeys(object),
            objLength = objProps.length,
            othProps = getAllKeys(other),
            othLength = othProps.length;

          if (objLength != othLength && !isPartial) {
            return false;
          }
          let index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          // Check that cyclic values are equal.
          const objStacked = stack.get(object);
          const othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          let result = true;
          stack.set(object, other);
          stack.set(other, object);

          let skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            const objValue = object[key],
              othValue = other[key];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (
              !(compared === undefined
                ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack)
                : compared)
            ) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            const objCtor = object.constructor,
              othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (
              objCtor != othCtor &&
              'constructor' in object &&
              'constructor' in other &&
              !(
                typeof objCtor == 'function' &&
                objCtor instanceof objCtor &&
                typeof othCtor == 'function' &&
                othCtor instanceof othCtor
              )
            ) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        function flatRest(func) {
          return setToString(overRest(func, undefined, flatten), func + '');
        }

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }

        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }

        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap
          ? noop
          : function (func) {
              return metaMap.get(func);
            };

        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          let result = func.name + '',
            array = realNames[result],
            length = hasOwnProperty.call(realNames, result) ? array.length : 0;

          while (length--) {
            const data = array[length],
              otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }

        /**
         * Gets the argument placeholder value for `func`.
         *
         * @private
         * @param {Function} func The function to inspect.
         * @returns {*} Returns the placeholder value.
         */
        function getHolder(func) {
          const object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
          return object.placeholder;
        }

        /**
         * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
         * this function returns the custom method, otherwise it returns `baseIteratee`.
         * If arguments are provided, the chosen function is invoked with them and
         * its result is returned.
         *
         * @private
         * @param {*} [value] The value to convert to an iteratee.
         * @param {number} [arity] The arity of the created iteratee.
         * @returns {Function} Returns the chosen function or its result.
         */
        function getIteratee() {
          let result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData(map, key) {
          const data = map.__data__;
          return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
        }

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          let result = keys(object),
            length = result.length;

          while (length--) {
            const key = result[length],
              value = object[key];

            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          const value = getValue(object, key);
          return baseIsNative(value) ? value : undefined;
        }

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
          const isOwn = hasOwnProperty.call(value, symToStringTag),
            tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined;
            var unmasked = true;
          } catch (e) {}

          const result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = !nativeGetSymbols
          ? stubArray
          : function (object) {
              if (object == null) {
                return [];
              }
              object = Object(object);
              return arrayFilter(nativeGetSymbols(object), function (symbol) {
                return propertyIsEnumerable.call(object, symbol);
              });
            };

        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbolsIn = !nativeGetSymbols
          ? stubArray
          : function (object) {
              const result = [];
              while (object) {
                arrayPush(result, getSymbols(object));
                object = getPrototype(object);
              }
              return result;
            };

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag = baseGetTag;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if (
          (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
          (Map && getTag(new Map()) != mapTag) ||
          (Promise && getTag(Promise.resolve()) != promiseTag) ||
          (Set && getTag(new Set()) != setTag) ||
          (WeakMap && getTag(new WeakMap()) != weakMapTag)
        ) {
          getTag = function (value) {
            const result = baseGetTag(value),
              Ctor = result == objectTag ? value.constructor : undefined,
              ctorString = Ctor ? toSource(Ctor) : '';

            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result;
          };
        }

        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          let index = -1,
            length = transforms.length;

          while (++index < length) {
            const data = transforms[index],
              size = data.size;

            switch (data.type) {
              case 'drop':
                start += size;
                break;
              case 'dropRight':
                end -= size;
                break;
              case 'take':
                end = nativeMin(end, start + size);
                break;
              case 'takeRight':
                start = nativeMax(start, end - size);
                break;
            }
          }
          return { start: start, end: end };
        }

        /**
         * Extracts wrapper details from the `source` body comment.
         *
         * @private
         * @param {string} source The source to inspect.
         * @returns {Array} Returns the wrapper details.
         */
        function getWrapDetails(source) {
          const match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);

          let index = -1,
            length = path.length,
            result = false;

          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          const length = array.length,
            result = new array.constructor(length);

          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          return typeof object.constructor == 'function' && !isPrototype(object)
            ? baseCreate(getPrototype(object))
            : {};
        }

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          const Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);

            case boolTag:
            case dateTag:
              return new Ctor(+object);

            case dataViewTag:
              return cloneDataView(object, isDeep);

            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);

            case mapTag:
              return new Ctor();

            case numberTag:
            case stringTag:
              return new Ctor(object);

            case regexpTag:
              return cloneRegExp(object);

            case setTag:
              return new Ctor();

            case symbolTag:
              return cloneSymbol(object);
          }
        }

        /**
         * Inserts wrapper `details` in a comment at the top of the `source` body.
         *
         * @private
         * @param {string} source The source to modify.
         * @returns {Array} details The details to insert.
         * @returns {string} Returns the modified source.
         */
        function insertWrapDetails(source, details) {
          const length = details.length;
          if (!length) {
            return source;
          }
          const lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
          details = details.join(length > 2 ? ', ' : ' ');
          return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
        }

        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          const type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;

          return (
            !!length &&
            (type == 'number' || (type != 'symbol' && reIsUint.test(value))) &&
            value > -1 &&
            value % 1 == 0 &&
            value < length
          );
        }

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          const type = typeof index;
          if (
            type == 'number'
              ? isArrayLike(object) && isIndex(index, object.length)
              : type == 'string' && index in object
          ) {
            return eq(object[index], value);
          }
          return false;
        }

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          const type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || (object != null && value in Object(object));
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          const type = typeof value;
          return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean'
            ? value !== '__proto__'
            : value === null;
        }

        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
         *  else `false`.
         */
        function isLaziable(func) {
          const funcName = getFuncName(func),
            other = lodash[funcName];

          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          const data = getData(other);
          return !!data && func === data[0];
        }

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }

        /**
         * Checks if `func` is capable of being masked.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
         */
        const isMaskable = coreJsData ? isFunction : stubFalse;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          const Ctor = value && value.constructor,
            proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

          return value === proto;
        }

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function (object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
          };
        }

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped(func) {
          const result = memoize(func, function (key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });

          var cache = result.cache;
          return result;
        }

        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers used to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and
         * `_.rearg` modify function arguments, making the order in which they are
         * executed important, preventing the merging of metadata. However, we make
         * an exception for a safe combined case where curried functions have `_.ary`
         * and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          let bitmask = data[1],
            srcBitmask = source[1],
            newBitmask = bitmask | srcBitmask,
            isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

          const isCombo =
            (srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG) ||
            (srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8]) ||
            (srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) &&
              source[7].length <= source[8] &&
              bitmask == WRAP_CURRY_FLAG);

          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          let value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = value;
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;

          return data;
        }

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          const result = [];
          if (object != null) {
            for (const key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest(func, start, transform) {
          start = nativeMax(start === undefined ? func.length - 1 : start, 0);
          return function () {
            let args = arguments,
              index = -1,
              length = nativeMax(args.length - start, 0),
              array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            const otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }

        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          let arrLength = array.length,
            length = nativeMin(indexes.length, arrLength),
            oldArray = copyArray(array);

          while (length--) {
            const index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
          }
          return array;
        }

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }

          if (key == '__proto__') {
            return;
          }

          return object[key];
        }

        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity
         * function to avoid garbage collection pauses in V8. See
         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = shortOut(baseSetData);

        /**
         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        var setTimeout =
          ctxSetTimeout ||
          function (func, wait) {
            return root.setTimeout(func, wait);
          };

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString = shortOut(baseSetToString);

        /**
         * Sets the `toString` method of `wrapper` to mimic the source of `reference`
         * with wrapper details in a comment at the top of the source body.
         *
         * @private
         * @param {Function} wrapper The function to modify.
         * @param {Function} reference The reference function.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Function} Returns `wrapper`.
         */
        function setWrapToString(wrapper, reference, bitmask) {
          const source = reference + '';
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut(func) {
          let count = 0,
            lastCalled = 0;

          return function () {
            const stamp = nativeNow(),
              remaining = HOT_SPAN - (stamp - lastCalled);

            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined, arguments);
          };
        }

        /**
         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @param {number} [size=array.length] The size of `array`.
         * @returns {Array} Returns `array`.
         */
        function shuffleSelf(array, size) {
          let index = -1,
            length = array.length,
            lastIndex = length - 1;

          size = size === undefined ? length : size;
          while (++index < size) {
            const rand = baseRandom(index, lastIndex),
              value = array[rand];

            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size;
          return array;
        }

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath = memoizeCapped(function (string) {
          const result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName, function (match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
          });
          return result;
        });

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value;
          }
          const result = value + '';
          return result == '0' && 1 / value == -INFINITY ? '-0' : result;
        }

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return func + '';
            } catch (e) {}
          }
          return '';
        }

        /**
         * Updates wrapper `details` based on `bitmask` flags.
         *
         * @private
         * @returns {Array} details The details to modify.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Array} Returns `details`.
         */
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function (pair) {
            const value = '_.' + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }

        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          const result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result.__actions__ = copyArray(wrapper.__actions__);
          result.__index__ = wrapper.__index__;
          result.__values__ = wrapper.__values__;
          return result;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `array` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the new array of chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }
          const length = array == null ? 0 : array.length;
          if (!length || size < 1) {
            return [];
          }
          let index = 0,
            resIndex = 0,
            result = Array(nativeCeil(length / size));

          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }
          return result;
        }

        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          let index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

          while (++index < length) {
            const value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * Creates a new array concatenating `array` with any additional arrays
         * and/or values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to concatenate.
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var other = _.concat(array, 2, [3], [[4]]);
         *
         * console.log(other);
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        function concat() {
          const length = arguments.length;
          if (!length) {
            return [];
          }
          let args = Array(length - 1),
            array = arguments[0],
            index = length;

          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }

        /**
         * Creates an array of `array` values not included in the other given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * **Note:** Unlike `_.pullAll`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.without, _.xor
         * @example
         *
         * _.difference([2, 1], [2, 3]);
         * // => [1]
         */
        const difference = baseRest(function (array, values) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `iteratee` which
         * is invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        const differenceBy = baseRest(function (array, values) {
          let iteratee = last(values);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `comparator`
         * which is invoked to compare elements of `array` to `values`. The order and
         * references of result values are determined by the first array. The comparator
         * is invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         *
         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }]
         */
        const differenceWith = baseRest(function (array, values) {
          let comparator = last(values);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
            : [];
        });

        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.dropRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropRightWhile(users, ['active', false]);
         * // => objects for ['barney']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropRightWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.dropWhile(users, function(o) { return !o.active; });
         * // => objects for ['pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropWhile(users, ['active', false]);
         * // => objects for ['pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }

        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8, 10], '*', 1, 3);
         * // => [4, '*', '*', 10]
         */
        function fill(array, value, start, end) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }

        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(o) { return o.user == 'barney'; });
         * // => 0
         *
         * // The `_.matches` iteratee shorthand.
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findIndex(users, ['active', false]);
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.findIndex(users, 'active');
         * // => 2
         */
        function findIndex(array, predicate, fromIndex) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          let index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }

        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
         * // => 2
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastIndex(users, ['active', false]);
         * // => 2
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        function findLastIndex(array, predicate, fromIndex) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          let index = length - 1;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }

        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten(array) {
          const length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        /**
         * Recursively flattens `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, [3, [4]], 5]]);
         * // => [1, 2, 3, 4, 5]
         */
        function flattenDeep(array) {
          const length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }

        /**
         * Recursively flatten `array` up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * var array = [1, [2, [3, [4]], 5]];
         *
         * _.flattenDepth(array, 1);
         * // => [1, 2, [3, [4]], 5]
         *
         * _.flattenDepth(array, 2);
         * // => [1, 2, 3, [4], 5]
         */
        function flattenDepth(array, depth) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }

        /**
         * The inverse of `_.toPairs`; this method returns an object composed
         * from key-value `pairs`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} pairs The key-value pairs.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.fromPairs([['a', 1], ['b', 2]]);
         * // => { 'a': 1, 'b': 2 }
         */
        function fromPairs(pairs) {
          let index = -1,
            length = pairs == null ? 0 : pairs.length,
            result = {};

          while (++index < length) {
            const pair = pairs[index];
            result[pair[0]] = pair[1];
          }
          return result;
        }

        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias first
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.head([1, 2, 3]);
         * // => 1
         *
         * _.head([]);
         * // => undefined
         */
        function head(array) {
          return array && array.length ? array[0] : undefined;
        }

        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the
         * offset from the end of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // Search from the `fromIndex`.
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         */
        function indexOf(array, value, fromIndex) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          let index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }

        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          const length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }

        /**
         * Creates an array of unique values that are included in all given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersection([2, 1], [2, 3]);
         * // => [2]
         */
        const intersection = baseRest(function (arrays) {
          const mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `iteratee`
         * which is invoked for each element of each `arrays` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [2.1]
         *
         * // The `_.property` iteratee shorthand.
         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }]
         */
        const intersectionBy = baseRest(function (arrays) {
          let iteratee = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);

          if (iteratee === last(mapped)) {
            iteratee = undefined;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `comparator`
         * which is invoked to compare elements of `arrays`. The order and references
         * of result values are determined by the first array. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.intersectionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }]
         */
        const intersectionWith = baseRest(function (arrays) {
          let comparator = last(arrays),
            mapped = arrayMap(arrays, castArrayLikeObject);

          comparator = typeof comparator == 'function' ? comparator : undefined;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
        });

        /**
         * Converts all elements in `array` into a string separated by `separator`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to convert.
         * @param {string} [separator=','] The element separator.
         * @returns {string} Returns the joined string.
         * @example
         *
         * _.join(['a', 'b', 'c'], '~');
         * // => 'a~b~c'
         */
        function join(array, separator) {
          return array == null ? '' : nativeJoin.call(array, separator);
        }

        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          const length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined;
        }

        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // Search from the `fromIndex`.
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         */
        function lastIndexOf(array, value, fromIndex) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          let index = length;
          if (fromIndex !== undefined) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value
            ? strictLastIndexOf(array, value, index)
            : baseFindIndex(array, baseIsNaN, index, true);
        }

        /**
         * Gets the element at index `n` of `array`. If `n` is negative, the nth
         * element from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.11.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=0] The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         *
         * _.nth(array, 1);
         * // => 'b'
         *
         * _.nth(array, -2);
         * // => 'c';
         */
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined;
        }

        /**
         * Removes all given values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
         * to remove elements from an array by predicate.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pull(array, 'a', 'c');
         * console.log(array);
         * // => ['b', 'b']
         */
        const pull = baseRest(pullAll);

        /**
         * This method is like `_.pull` except that it accepts an array of values to remove.
         *
         * **Note:** Unlike `_.difference`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pullAll(array, ['a', 'c']);
         * console.log(array);
         * // => ['b', 'b']
         */
        function pullAll(array, values) {
          return array && array.length && values && values.length ? basePullAll(array, values) : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `iteratee` which is
         * invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The iteratee is invoked with one argument: (value).
         *
         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
         *
         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
         * console.log(array);
         * // => [{ 'x': 2 }]
         */
        function pullAllBy(array, values, iteratee) {
          return array && array.length && values && values.length
            ? basePullAll(array, values, getIteratee(iteratee, 2))
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `comparator` which
         * is invoked to compare elements of `array` to `values`. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
         *
         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
         * console.log(array);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
         */
        function pullAllWith(array, values, comparator) {
          return array && array.length && values && values.length
            ? basePullAll(array, values, undefined, comparator)
            : array;
        }

        /**
         * Removes elements from `array` corresponding to `indexes` and returns an
         * array of removed elements.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         * var pulled = _.pullAt(array, [1, 3]);
         *
         * console.log(array);
         * // => ['a', 'c']
         *
         * console.log(pulled);
         * // => ['b', 'd']
         */
        const pullAt = flatRest(function (array, indexes) {
          const length = array == null ? 0 : array.length,
            result = baseAt(array, indexes);

          basePullAt(
            array,
            arrayMap(indexes, function (index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending),
          );

          return result;
        });

        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is invoked
         * with three arguments: (value, index, array).
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
         * to pull elements from an array by value.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate) {
          const result = [];
          if (!(array && array.length)) {
            return result;
          }
          let index = -1,
            indexes = [],
            length = array.length;

          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            const value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }

        /**
         * Reverses `array` so that the first element becomes the last, the second
         * element becomes the second to last, and so on.
         *
         * **Note:** This method mutates `array` and is based on
         * [`Array#reverse`](https://mdn.io/Array/reverse).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.reverse(array);
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }

        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of
         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
         * returned.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }

        /**
         * Uses a binary search to determine the lowest index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         */
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }

        /**
         * This method is like `_.sortedIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
         * // => 0
         */
        function sortedIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }

        /**
         * This method is like `_.indexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
         * // => 1
         */
        function sortedIndexOf(array, value) {
          const length = array == null ? 0 : array.length;
          if (length) {
            const index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
         * // => 4
         */
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }

        /**
         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 1
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
         * // => 1
         */
        function sortedLastIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
        }

        /**
         * This method is like `_.lastIndexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
         * // => 3
         */
        function sortedLastIndexOf(array, value) {
          const length = array == null ? 0 : array.length;
          if (length) {
            const index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.uniq` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniq([1, 1, 2]);
         * // => [1, 2]
         */
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }

        /**
         * This method is like `_.uniqBy` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
         * // => [1.1, 2.3]
         */
        function sortedUniqBy(array, iteratee) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
        }

        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.tail([1, 2, 3]);
         * // => [2, 3]
         */
        function tail(array) {
          const length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          const length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.takeRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeRightWhile(users, ['active', false]);
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeRightWhile(users, 'active');
         * // => []
         */
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }

        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.takeWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeWhile(users, ['active', false]);
         * // => objects for ['barney', 'fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeWhile(users, 'active');
         * // => []
         */
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }

        /**
         * Creates an array of unique values, in order, from all given arrays using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([2], [1, 2]);
         * // => [2, 1]
         */
        const union = baseRest(function (arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });

        /**
         * This method is like `_.union` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which uniqueness is computed. Result values are chosen from the first
         * array in which the value occurs. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.unionBy([2.1], [1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        const unionBy = baseRest(function (arrays) {
          let iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.union` except that it accepts `comparator` which
         * is invoked to compare elements of `arrays`. Result values are chosen from
         * the first array in which the value occurs. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.unionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        const unionWith = baseRest(function (arrays) {
          let comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
        });

        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurrence of each element
         * is kept. The order of result values is determined by the order they occur
         * in the array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         */
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * uniqueness is computed. The order of result values is determined by the
         * order they occur in the array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniqBy(array, iteratee) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `comparator` which
         * is invoked to compare elements of `array`. The order of result values is
         * determined by the order they occur in the array.The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.uniqWith(objects, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
         */
        function uniqWith(array, comparator) {
          comparator = typeof comparator == 'function' ? comparator : undefined;
          return array && array.length ? baseUniq(array, undefined, comparator) : [];
        }

        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @since 1.2.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         *
         * _.unzip(zipped);
         * // => [['a', 'b'], [1, 2], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          let length = 0;
          array = arrayFilter(array, function (group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function (index) {
            return arrayMap(array, baseProperty(index));
          });
        }

        /**
         * This method is like `_.unzip` except that it accepts `iteratee` to specify
         * how regrouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  regrouped values.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee) {
          if (!(array && array.length)) {
            return [];
          }
          const result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          return arrayMap(result, function (group) {
            return apply(iteratee, undefined, group);
          });
        }

        /**
         * Creates an array excluding all given values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.pull`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.xor
         * @example
         *
         * _.without([2, 1, 2, 3], 1, 2);
         * // => [3]
         */
        const without = baseRest(function (array, values) {
          return isArrayLikeObject(array) ? baseDifference(array, values) : [];
        });

        /**
         * Creates an array of unique values that is the
         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the given arrays. The order of result values is determined by the order
         * they occur in the arrays.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.without
         * @example
         *
         * _.xor([2, 1], [2, 3]);
         * // => [1, 3]
         */
        const xor = baseRest(function (arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });

        /**
         * This method is like `_.xor` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which by which they're compared. The order of result values is determined
         * by the order they occur in the arrays. The iteratee is invoked with one
         * argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2, 3.4]
         *
         * // The `_.property` iteratee shorthand.
         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        const xorBy = baseRest(function (arrays) {
          let iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.xor` except that it accepts `comparator` which is
         * invoked to compare elements of `arrays`. The order of result values is
         * determined by the order they occur in the arrays. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.xorWith(objects, others, _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        const xorWith = baseRest(function (arrays) {
          let comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
        });

        /**
         * Creates an array of grouped elements, the first of which contains the
         * first elements of the given arrays, the second of which contains the
         * second elements of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         */
        const zip = baseRest(unzip);

        /**
         * This method is like `_.fromPairs` except that it accepts two arrays,
         * one of property identifiers and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 0.4.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject(['a', 'b'], [1, 2]);
         * // => { 'a': 1, 'b': 2 }
         */
        function zipObject(props, values) {
          return baseZipObject(props || [], values || [], assignValue);
        }

        /**
         * This method is like `_.zipObject` except that it supports property paths.
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
         */
        function zipObjectDeep(props, values) {
          return baseZipObject(props || [], values || [], baseSet);
        }

        /**
         * This method is like `_.zip` except that it accepts `iteratee` to specify
         * how grouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  grouped values.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
         *   return a + b + c;
         * });
         * // => [111, 222]
         */
        const zipWith = baseRest(function (arrays) {
          let length = arrays.length,
            iteratee = length > 1 ? arrays[length - 1] : undefined;

          iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
          return unzipWith(arrays, iteratee);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` wrapper instance that wraps `value` with explicit method
         * chain sequences enabled. The result of such sequences must be unwrapped
         * with `_#value`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Seq
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _
         *   .chain(users)
         *   .sortBy('age')
         *   .map(function(o) {
         *     return o.user + ' is ' + o.age;
         *   })
         *   .head()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          const result = lodash(value);
          result.__chain__ = true;
          return result;
        }

        /**
         * This method invokes `interceptor` and returns `value`. The interceptor
         * is invoked with one argument; (value). The purpose of this method is to
         * "tap into" a method chain sequence in order to modify intermediate results.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    // Mutate input array.
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }

        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         * The purpose of this method is to "pass thru" values replacing intermediate
         * results in a method chain sequence.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor) {
          return interceptor(value);
        }

        /**
         * This method is the wrapper version of `_.at`.
         *
         * @name at
         * @memberOf _
         * @since 1.0.0
         * @category Seq
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _(object).at(['a[0].b.c', 'a[1]']).value();
         * // => [3, 4]
         */
        const wrapperAt = flatRest(function (paths) {
          let length = paths.length,
            start = length ? paths[0] : 0,
            value = this.__wrapped__,
            interceptor = function (object) {
              return baseAt(object, paths);
            };

          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            func: thru,
            args: [interceptor],
            thisArg: undefined,
          });
          return new LodashWrapper(value, this.__chain__).thru(function (array) {
            if (length && !array.length) {
              array.push(undefined);
            }
            return array;
          });
        });

        /**
         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
         *
         * @name chain
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // A sequence without explicit chaining.
         * _(users).head();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // A sequence with explicit chaining.
         * _(users)
         *   .chain()
         *   .head()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }

        /**
         * Executes the chain sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }

        /**
         * Gets the next value on a wrapped object following the
         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
         *
         * @name next
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the next iterator value.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 1 }
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 2 }
         *
         * wrapped.next();
         * // => { 'done': true, 'value': undefined }
         */
        function wrapperNext() {
          if (this.__values__ === undefined) {
            this.__values__ = toArray(this.value());
          }
          const done = this.__index__ >= this.__values__.length,
            value = done ? undefined : this.__values__[this.__index__++];

          return { done: done, value: value };
        }

        /**
         * Enables the wrapper to be iterable.
         *
         * @name Symbol.iterator
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the wrapper object.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped[Symbol.iterator]() === wrapped;
         * // => true
         *
         * Array.from(wrapped);
         * // => [1, 2]
         */
        function wrapperToIterator() {
          return this;
        }

        /**
         * Creates a clone of the chain sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @param {*} value The value to plant.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2]).map(square);
         * var other = wrapped.plant([3, 4]);
         *
         * other.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          let result,
            parent = this;

          while (parent instanceof baseLodash) {
            const clone = wrapperClone(parent);
            clone.__index__ = 0;
            clone.__values__ = undefined;
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }

        /**
         * This method is the wrapper version of `_.reverse`.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          const value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            let wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              func: thru,
              args: [reverse],
              thisArg: undefined,
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }

        /**
         * Executes the chain sequence to resolve the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @since 0.1.0
         * @alias toJSON, valueOf
         * @category Seq
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the number of times the key was returned by `iteratee`. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': 1, '6': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        const countBy = createAggregator(function (result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            ++result[key];
          } else {
            baseAssignValue(result, key, 1);
          }
        });

        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * Iteration is stopped once `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * **Note:** This method returns `true` for
         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
         * elements of empty collections.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.every(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, guard) {
          const func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * **Note:** Unlike `_.remove`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.reject
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, { 'age': 36, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.filter(users, 'active');
         * // => objects for ['barney']
         *
         * // Combining several predicates using `_.overEvery` or `_.overSome`.
         * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
         * // => objects for ['fred', 'barney']
         */
        function filter(collection, predicate) {
          const func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.find(users, function(o) { return o.age < 40; });
         * // => object for 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.find(users, { 'age': 1, 'active': true });
         * // => object for 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.find(users, ['active', false]);
         * // => object for 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.find(users, 'active');
         * // => object for 'barney'
         */
        const find = createFind(findIndex);

        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=collection.length-1] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        const findLast = createFind(findLastIndex);

        /**
         * Creates a flattened array of values by running each element in `collection`
         * thru `iteratee` and flattening the mapped results. The iteratee is invoked
         * with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [n, n];
         * }
         *
         * _.flatMap([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMap(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDeep([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMapDeep(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), INFINITY);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDepth([1, 2], duplicate, 2);
         * // => [[1, 1], [2, 2]]
         */
        function flatMapDepth(collection, iteratee, depth) {
          depth = depth === undefined ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee), depth);
        }

        /**
         * Iterates over elements of `collection` and invokes `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length"
         * property are iterated like arrays. To avoid this behavior use `_.forIn`
         * or `_.forOwn` for object iteration.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEachRight
         * @example
         *
         * _.forEach([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `1` then `2`.
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forEach(collection, iteratee) {
          const func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @alias eachRight
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEach
         * @example
         *
         * _.forEachRight([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `2` then `1`.
         */
        function forEachRight(collection, iteratee) {
          const func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The order of grouped values
         * is determined by the order they occur in `collection`. The corresponding
         * value of each key is an array of elements responsible for generating the
         * key. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': [4.2], '6': [6.1, 6.3] }
         *
         * // The `_.property` iteratee shorthand.
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        const groupBy = createAggregator(function (result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            baseAssignValue(result, key, [value]);
          }
        });

        /**
         * Checks if `value` is in `collection`. If `collection` is a string, it's
         * checked for a substring of `value`, otherwise
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * is used for equality comparisons. If `fromIndex` is negative, it's used as
         * the offset from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {boolean} Returns `true` if `value` is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'a': 1, 'b': 2 }, 1);
         * // => true
         *
         * _.includes('abcd', 'bc');
         * // => true
         */
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;

          const length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection)
            ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1
            : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }

        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `path` is a function, it's invoked
         * for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke each method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invokeMap([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        const invokeMap = baseRest(function (collection, path, args) {
          let index = -1,
            isFunc = typeof path == 'function',
            result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function (value) {
            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result;
        });

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the last element responsible for generating the key. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var array = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.keyBy(array, function(o) {
         *   return String.fromCharCode(o.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.keyBy(array, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         */
        const keyBy = createAggregator(function (result, value, key) {
          baseAssignValue(result, key, value);
        });

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee) {
          const func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.sortBy` except that it allows specifying the sort
         * orders of the iteratees to sort by. If `orders` is unspecified, all values
         * are sorted in ascending order. Otherwise, specify an order of "desc" for
         * descending or "asc" for ascending sort order of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @param {string[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // Sort by `user` in ascending order and by `age` in descending order.
         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         */
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }

        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, the second of which
         * contains elements `predicate` returns falsey for. The predicate is
         * invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * _.partition(users, function(o) { return o.active; });
         * // => objects for [['fred'], ['barney', 'pebbles']]
         *
         * // The `_.matches` iteratee shorthand.
         * _.partition(users, { 'age': 1, 'active': false });
         * // => objects for [['pebbles'], ['barney', 'fred']]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.partition(users, ['active', false]);
         * // => objects for [['barney', 'pebbles'], ['fred']]
         *
         * // The `_.property` iteratee shorthand.
         * _.partition(users, 'active');
         * // => objects for [['fred'], ['barney', 'pebbles']]
         */
        const partition = createAggregator(
          function (result, value, key) {
            result[key ? 0 : 1].push(value);
          },
          function () {
            return [[], []];
          },
        );

        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` thru `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not given, the first element of `collection` is used as the initial
         * value. The iteratee is invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
         * and `sortBy`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduceRight
         * @example
         *
         * _.reduce([1, 2], function(sum, n) {
         *   return sum + n;
         * }, 0);
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         *   return result;
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
         */
        function reduce(collection, iteratee, accumulator) {
          const func = isArray(collection) ? arrayReduce : baseReduce,
            initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }

        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduce
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        function reduceRight(collection, iteratee, accumulator) {
          const func = isArray(collection) ? arrayReduceRight : baseReduce,
            initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }

        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.filter
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * _.reject(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.reject(users, { 'age': 40, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.reject(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.reject(users, 'active');
         * // => objects for ['barney']
         */
        function reject(collection, predicate) {
          const func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }

        /**
         * Gets a random element from `collection`.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         */
        function sample(collection) {
          const func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }

        /**
         * Gets `n` random elements at unique keys from `collection` up to the
         * size of `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @param {number} [n=1] The number of elements to sample.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the random elements.
         * @example
         *
         * _.sampleSize([1, 2, 3], 2);
         * // => [3, 1]
         *
         * _.sampleSize([1, 2, 3], 4);
         * // => [2, 3, 1]
         */
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          const func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }

        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          const func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }

        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable string keyed properties for objects.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the collection size.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          const tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }

        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * Iteration is stopped once `predicate` returns truthy. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.some(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, guard) {
          const func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection thru each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 30 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, [function(o) { return o.user; }]);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
         */
        const sortBy = baseRest(function (collection, iteratees) {
          if (collection == null) {
            return [];
          }
          const length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        const now =
          ctxNow ||
          function () {
            return root.Date.now();
          };

        /*------------------------------------------------------------------------*/

        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it's called `n` or more times.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => Logs 'done saving!' after the two async saves have completed.
         */
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function () {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }

        /**
         * Creates a function that invokes `func`, with up to `n` arguments,
         * ignoring any additional arguments.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          n = guard ? undefined : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
        }

        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it's called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery(element).on('click', _.before(5, addContactToList));
         * // => Allows adding up to 4 contacts to the list.
         */
        function before(n, func) {
          let result;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function () {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined;
            }
            return result;
          };
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and `partials` prepended to the arguments it receives.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * function greet(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * }
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = baseRest(function (func, thisArg, partials) {
          let bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });

        /**
         * Creates a function that invokes the method at `object[key]` with `partials`
         * prepended to the arguments it receives.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist. See
         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Function
         * @param {Object} object The object to invoke the method on.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = baseRest(function (object, key, partials) {
          let bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });

        /**
         * Creates a function that accepts arguments of `func` and either invokes
         * `func` returning its result, if at least `arity` number of arguments have
         * been provided, or returns a function that accepts the remaining `func`
         * arguments, and so on. The arity of `func` may be specified if `func.length`
         * is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        function curry(func, arity, guard) {
          arity = guard ? undefined : arity;
          const result = createWrap(
            func,
            WRAP_CURRY_FLAG,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            arity,
          );
          result.placeholder = curry.placeholder;
          return result;
        }

        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        function curryRight(func, arity, guard) {
          arity = guard ? undefined : arity;
          const result = createWrap(
            func,
            WRAP_CURRY_RIGHT_FLAG,
            undefined,
            undefined,
            undefined,
            undefined,
            undefined,
            arity,
          );
          result.placeholder = curryRight.placeholder;
          return result;
        }

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          let lastArgs,
            lastThis,
            maxWait,
            result,
            timerId,
            lastCallTime,
            lastInvokeTime = 0,
            leading = false,
            maxing = false,
            trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }

          function invokeFunc(time) {
            const args = lastArgs,
              thisArg = lastThis;

            lastArgs = lastThis = undefined;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }

          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }

          function remainingWait(time) {
            const timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime,
              timeWaiting = wait - timeSinceLastCall;

            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }

          function shouldInvoke(time) {
            const timeSinceLastCall = time - lastCallTime,
              timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return (
              lastCallTime === undefined ||
              timeSinceLastCall >= wait ||
              timeSinceLastCall < 0 ||
              (maxing && timeSinceLastInvoke >= maxWait)
            );
          }

          function timerExpired() {
            const time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }

          function trailingEdge(time) {
            timerId = undefined;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined;
            return result;
          }

          function cancel() {
            if (timerId !== undefined) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined;
          }

          function flush() {
            return timerId === undefined ? result : trailingEdge(now());
          }

          function debounced() {
            const time = now(),
              isInvoking = shouldInvoke(time);

            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
              if (timerId === undefined) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }

        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // => Logs 'deferred' after one millisecond.
         */
        const defer = baseRest(function (func, args) {
          return baseDelay(func, 1, args);
        });

        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => Logs 'later' after one second.
         */
        const delay = baseRest(function (func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });

        /**
         * Creates a function that invokes `func` with arguments reversed.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to flip arguments for.
         * @returns {Function} Returns the new flipped function.
         * @example
         *
         * var flipped = _.flip(function() {
         *   return _.toArray(arguments);
         * });
         *
         * flipped('a', 'b', 'c', 'd');
         * // => ['d', 'c', 'b', 'a']
         */
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          const memoized = function () {
            const args = arguments,
              key = resolver ? resolver.apply(this, args) : args[0],
              cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }
            const result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }

        // Expose `MapCache`.
        memoize.Cache = MapCache;

        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new negated function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function () {
            const args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }

        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first invocation. The `func` is
         * invoked with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // => `createApplication` is invoked once
         */
        function once(func) {
          return before(2, func);
        }

        /**
         * Creates a function that invokes `func` with its arguments transformed.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms=[_.identity]]
         *  The argument transforms.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var func = _.overArgs(function(x, y) {
         *   return [x, y];
         * }, [square, doubled]);
         *
         * func(9, 3);
         * // => [81, 6]
         *
         * func(10, 5);
         * // => [100, 10]
         */
        const overArgs = castRest(function (func, transforms) {
          transforms =
            transforms.length == 1 && isArray(transforms[0])
              ? arrayMap(transforms[0], baseUnary(getIteratee()))
              : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

          const funcsLength = transforms.length;
          return baseRest(function (args) {
            let index = -1,
              length = nativeMin(args.length, funcsLength);

            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });

        /**
         * Creates a function that invokes `func` with `partials` prepended to the
         * arguments it receives. This method is like `_.bind` except it does **not**
         * alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 0.2.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // Partially applied with placeholders.
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = baseRest(function (func, partials) {
          const holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
        });

        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to the arguments it receives.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // Partially applied with placeholders.
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = baseRest(function (func, partials) {
          const holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
        });

        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified `indexes` where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, [2, 0, 1]);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         */
        const rearg = flatRest(function (func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
        });

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as
         * an array.
         *
         * **Note:** This method is based on the
         * [rest parameter](https://mdn.io/rest_parameters).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.rest(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined ? start : toInteger(start);
          return baseRest(func, start);
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * create function and an array of arguments much like
         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
         *
         * **Note:** This method is based on the
         * [spread operator](https://mdn.io/spread_operator).
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @param {number} [start=0] The start position of the spread.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function (args) {
            const array = args[start],
              otherArgs = castSlice(args, 0, start);

            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }

        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide `options` to indicate whether `func`
         * should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the throttled function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=true]
         *  Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          let leading = true,
            trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            leading: leading,
            maxWait: wait,
            trailing: trailing,
          });
        }

        /**
         * Creates a function that accepts up to one argument, ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.unary(parseInt));
         * // => [6, 8, 10]
         */
        function unary(func) {
          return ary(func, 1);
        }

        /**
         * Creates a function that provides `value` to `wrapper` as its first
         * argument. Any additional arguments provided to the function are appended
         * to those provided to the `wrapper`. The wrapper is invoked with the `this`
         * binding of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} [wrapper=identity] The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Casts `value` as an array if it's not one.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Lang
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the cast array.
         * @example
         *
         * _.castArray(1);
         * // => [1]
         *
         * _.castArray({ 'a': 1 });
         * // => [{ 'a': 1 }]
         *
         * _.castArray('abc');
         * // => ['abc']
         *
         * _.castArray(null);
         * // => [null]
         *
         * _.castArray(undefined);
         * // => [undefined]
         *
         * _.castArray();
         * // => []
         *
         * var array = [1, 2, 3];
         * console.log(_.castArray(array) === array);
         * // => true
         */
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          const value = arguments[0];
          return isArray(value) ? value : [value];
        }

        /**
         * Creates a shallow clone of `value`.
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
         * and supports cloning arrays, array buffers, booleans, date objects, maps,
         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
         * arrays. The own enumerable properties of `arguments` objects are cloned
         * as plain objects. An empty object is returned for uncloneable values such
         * as error objects, functions, DOM nodes, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to clone.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeep
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var shallow = _.clone(objects);
         * console.log(shallow[0] === objects[0]);
         * // => true
         */
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.clone` except that it accepts `customizer` which
         * is invoked to produce the cloned value. If `customizer` returns `undefined`,
         * cloning is handled by the method instead. The `customizer` is invoked with
         * up to four arguments; (value [, index|key, object, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeepWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * }
         *
         * var el = _.cloneWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 0
         */
        function cloneWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @see _.clone
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.cloneWith` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the deep cloned value.
         * @see _.cloneWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * }
         *
         * var el = _.cloneDeepWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 20
         */
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * Checks if `object` conforms to `source` by invoking the predicate
         * properties of `source` with the corresponding property values of `object`.
         *
         * **Note:** This method is equivalent to `_.conforms` when `source` is
         * partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
         * // => true
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
         * // => false
         */
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         * @see _.lt
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        const gt = createRelationalOperation(baseGt);

        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to
         *  `other`, else `false`.
         * @see _.lte
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        const gte = createRelationalOperation(function (value, other) {
          return value >= other;
        });

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments = baseIsArguments(
          (function () {
            return arguments;
          })(),
        )
          ? baseIsArguments
          : function (value) {
              return (
                isObjectLike(value) &&
                hasOwnProperty.call(value, 'callee') &&
                !propertyIsEnumerable.call(value, 'callee')
              );
            };

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;

        /**
         * Checks if `value` is classified as an `ArrayBuffer` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         * @example
         *
         * _.isArrayBuffer(new ArrayBuffer(2));
         * // => true
         *
         * _.isArrayBuffer(new Array(2));
         * // => false
         */
        const isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false || (isObjectLike(value) && baseGetTag(value) == boolTag);
        }

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse;

        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        const isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

        /**
         * Checks if `value` is likely a DOM element.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }

        /**
         * Checks if `value` is an empty object, collection, map, or set.
         *
         * Objects are considered empty if they have no own enumerable string keyed
         * properties.
         *
         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
         * jQuery-like collections are considered empty if they have a `length` of `0`.
         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (
            isArrayLike(value) &&
            (isArray(value) ||
              typeof value == 'string' ||
              typeof value.splice == 'function' ||
              isBuffer(value) ||
              isTypedArray(value) ||
              isArguments(value))
          ) {
            return !value.length;
          }
          const tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (const key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }

        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are compared by strict equality, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }

        /**
         * This method is like `_.isEqual` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with up to
         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, othValue) {
         *   if (isGreeting(objValue) && isGreeting(othValue)) {
         *     return true;
         *   }
         * }
         *
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqualWith(array, other, customizer);
         * // => true
         */
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          const result = customizer ? customizer(value, other) : undefined;
          return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
        }

        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          const tag = baseGetTag(value);
          return (
            tag == errorTag ||
            tag == domExcTag ||
            (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value))
          );
        }

        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on
         * [`Number.isFinite`](https://mdn.io/Number/isFinite).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(3);
         * // => true
         *
         * _.isFinite(Number.MIN_VALUE);
         * // => true
         *
         * _.isFinite(Infinity);
         * // => false
         *
         * _.isFinite('3');
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          const tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }

        /**
         * Checks if `value` is an integer.
         *
         * **Note:** This method is based on
         * [`Number.isInteger`](https://mdn.io/Number/isInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
         * @example
         *
         * _.isInteger(3);
         * // => true
         *
         * _.isInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isInteger(Infinity);
         * // => false
         *
         * _.isInteger('3');
         * // => false
         */
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value);
        }

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          const type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == 'object';
        }

        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

        /**
         * Performs a partial deep comparison between `object` and `source` to
         * determine if `object` contains equivalent property values.
         *
         * **Note:** This method is equivalent to `_.matches` when `source` is
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.isMatch(object, { 'b': 2 });
         * // => true
         *
         * _.isMatch(object, { 'b': 1 });
         * // => false
         */
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }

        /**
         * This method is like `_.isMatch` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with five
         * arguments: (objValue, srcValue, index|key, object, source).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, srcValue) {
         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
         *     return true;
         *   }
         * }
         *
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatchWith(object, source, customizer);
         * // => true
         */
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }

        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is based on
         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
         * `undefined` and other non-number values.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some
          // ActiveX objects in IE.
          return isNumber(value) && value != +value;
        }

        /**
         * Checks if `value` is a pristine native function.
         *
         * **Note:** This method can't reliably detect native functions in the presence
         * of the core-js package because core-js circumvents this kind of detection.
         * Despite multiple requests, the core-js maintainer has made it clear: any
         * attempt to fix the detection will be obstructed. As a result, we're left
         * with little choice but to throw an error. Unfortunately, this also affects
         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
         * which rely on core-js.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }

        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }

        /**
         * Checks if `value` is `null` or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
         * @example
         *
         * _.isNil(null);
         * // => true
         *
         * _.isNil(void 0);
         * // => true
         *
         * _.isNil(NaN);
         * // => false
         */
        function isNil(value) {
          return value == null;
        }

        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
         * classified as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a number, else `false`.
         * @example
         *
         * _.isNumber(3);
         * // => true
         *
         * _.isNumber(Number.MIN_VALUE);
         * // => true
         *
         * _.isNumber(Infinity);
         * // => true
         *
         * _.isNumber('3');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' || (isObjectLike(value) && baseGetTag(value) == numberTag);
        }

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          const proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          const Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }

        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        const isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

        /**
         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
         * double precision number which isn't the result of a rounded unsafe integer.
         *
         * **Note:** This method is based on
         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
         * @example
         *
         * _.isSafeInteger(3);
         * // => true
         *
         * _.isSafeInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isSafeInteger(Infinity);
         * // => false
         *
         * _.isSafeInteger('3');
         * // => false
         */
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' || (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
        }

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
          return typeof value == 'symbol' || (isObjectLike(value) && baseGetTag(value) == symbolTag);
        }

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined;
        }

        /**
         * Checks if `value` is classified as a `WeakMap` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
         * @example
         *
         * _.isWeakMap(new WeakMap);
         * // => true
         *
         * _.isWeakMap(new Map);
         * // => false
         */
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }

        /**
         * Checks if `value` is classified as a `WeakSet` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
         * @example
         *
         * _.isWeakSet(new WeakSet);
         * // => true
         *
         * _.isWeakSet(new Set);
         * // => false
         */
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }

        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         * @see _.gt
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        const lt = createRelationalOperation(baseLt);

        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to
         *  `other`, else `false`.
         * @see _.gte
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        const lte = createRelationalOperation(function (value, other) {
          return value <= other;
        });

        /**
         * Converts `value` to an array.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * _.toArray({ 'a': 1, 'b': 2 });
         * // => [1, 2]
         *
         * _.toArray('abc');
         * // => ['a', 'b', 'c']
         *
         * _.toArray(1);
         * // => []
         *
         * _.toArray(null);
         * // => []
         */
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          const tag = getTag(value),
            func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;

          return func(value);
        }

        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            const sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }

        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */
        function toInteger(value) {
          const result = toFinite(value),
            remainder = result % 1;

          return result === result ? (remainder ? result - remainder : result) : 0;
        }

        /**
         * Converts `value` to an integer suitable for use as the length of an
         * array-like object.
         *
         * **Note:** This method is based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toLength(3.2);
         * // => 3
         *
         * _.toLength(Number.MIN_VALUE);
         * // => 0
         *
         * _.toLength(Infinity);
         * // => 4294967295
         *
         * _.toLength('3.2');
         * // => 3
         */
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            const other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject(other) ? other + '' : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          const isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value)
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : reIsBadHex.test(value)
              ? NAN
              : +value;
        }

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        /**
         * Converts `value` to a safe integer. A safe integer can be compared and
         * represented correctly.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toSafeInteger(3.2);
         * // => 3
         *
         * _.toSafeInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toSafeInteger(Infinity);
         * // => 9007199254740991
         *
         * _.toSafeInteger('3.2');
         * // => 3
         */
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
          return value == null ? '' : baseToString(value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Assigns own enumerable string keyed properties of source objects to the
         * destination object. Source objects are applied from left to right.
         * Subsequent sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object` and is loosely based on
         * [`Object.assign`](https://mdn.io/Object/assign).
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assignIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assign({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'c': 3 }
         */
        const assign = createAssigner(function (object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (const key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });

        /**
         * This method is like `_.assign` except that it iterates over own and
         * inherited source properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assign
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assignIn({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
         */
        const assignIn = createAssigner(function (object, source) {
          copyObject(source, keysIn(source), object);
        });

        /**
         * This method is like `_.assignIn` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extendWith
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        const assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });

        /**
         * This method is like `_.assign` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignInWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        const assignWith = createAssigner(function (object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });

        /**
         * Creates an array of values corresponding to `paths` of `object`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Array} Returns the picked values.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _.at(object, ['a[0].b.c', 'a[1]']);
         * // => [3, 4]
         */
        const at = flatRest(baseAt);

        /**
         * Creates an object that inherits from the `prototype` object. If a
         * `properties` object is given, its own enumerable string keyed properties
         * are assigned to the created object.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties) {
          const result = baseCreate(prototype);
          return properties == null ? result : baseAssign(result, properties);
        }

        /**
         * Assigns own and inherited enumerable string keyed properties of source
         * objects to the destination object for all destination properties that
         * resolve to `undefined`. Source objects are applied from left to right.
         * Once a property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaultsDeep
         * @example
         *
         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        const defaults = baseRest(function (object, sources) {
          object = Object(object);

          let index = -1;
          let length = sources.length;
          const guard = length > 2 ? sources[2] : undefined;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }

          while (++index < length) {
            const source = sources[index];
            const props = keysIn(source);
            let propsIndex = -1;
            const propsLength = props.length;

            while (++propsIndex < propsLength) {
              const key = props[propsIndex];
              const value = object[key];

              if (value === undefined || (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                object[key] = source[key];
              }
            }
          }

          return object;
        });

        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaults
         * @example
         *
         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
         * // => { 'a': { 'b': 2, 'c': 3 } }
         */
        const defaultsDeep = baseRest(function (args) {
          args.push(undefined, customDefaultsMerge);
          return apply(mergeWith, undefined, args);
        });

        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(o) { return o.age < 40; });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // The `_.matches` iteratee shorthand.
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }

        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(o) { return o.age < 40; });
         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }

        /**
         * Iterates over own and inherited enumerable string keyed properties of an
         * object and invokes `iteratee` for each property. The iteratee is invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forInRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
         */
        function forIn(object, iteratee) {
          return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
         */
        function forInRight(object, iteratee) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * Iterates over own enumerable string keyed properties of an object and
         * invokes `iteratee` for each property. The iteratee is invoked with three
         * arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwnRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn(object, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
         */
        function forOwnRight(object, iteratee) {
          return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }

        /**
         * Creates an array of function property names from own enumerable properties
         * of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functionsIn
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functions(new Foo);
         * // => ['a', 'b']
         */
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }

        /**
         * Creates an array of function property names from own and inherited
         * enumerable properties of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functions
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functionsIn(new Foo);
         * // => ['a', 'b', 'c']
         */
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          const result = object == null ? undefined : baseGet(object, path);
          return result === undefined ? defaultValue : result;
        }

        /**
         * Checks if `path` is a direct property of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': 2 } };
         * var other = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b');
         * // => true
         *
         * _.has(object, ['a', 'b']);
         * // => true
         *
         * _.has(other, 'a');
         * // => false
         */
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite
         * property assignments of previous values.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Object
         * @param {Object} object The object to invert.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         */
        const invert = createInverter(function (result, value, key) {
          if (value != null && typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          result[value] = key;
        }, constant(identity));

        /**
         * This method is like `_.invert` except that the inverted object is generated
         * from the results of running each element of `object` thru `iteratee`. The
         * corresponding inverted value of each inverted key is an array of keys
         * responsible for generating the inverted value. The iteratee is invoked
         * with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Object
         * @param {Object} object The object to invert.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invertBy(object);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         *
         * _.invertBy(object, function(value) {
         *   return 'group' + value;
         * });
         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
         */
        const invertBy = createInverter(function (result, value, key) {
          if (value != null && typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }, getIteratee);

        /**
         * Invokes the method at `path` of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
         *
         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
         * // => [2, 3]
         */
        const invoke = baseRest(baseInvoke);

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }

        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * string keyed property of `object` thru `iteratee`. The iteratee is invoked
         * with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapValues
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        function mapKeys(object, iteratee) {
          const result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function (value, key, object) {
            baseAssignValue(result, iteratee(value, key, object), value);
          });
          return result;
        }

        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          const result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function (value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
          });
          return result;
        }

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        const merge = createAssigner(function (object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });

        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined`, merging is handled by the
         * method instead. The `customizer` is invoked with six arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = { 'a': [1], 'b': [2] };
         * var other = { 'a': [3], 'b': [4] };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'a': [1, 3], 'b': [2, 4] }
         */
        var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        const omit = flatRest(function (object, paths) {
          let result = {};
          if (object == null) {
            return result;
          }
          let isDeep = false;
          paths = arrayMap(paths, function (path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result);
          if (isDeep) {
            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          let length = paths.length;
          while (length--) {
            baseUnset(result, paths[length]);
          }
          return result;
        });

        /**
         * The opposite of `_.pickBy`; this method creates an object composed of
         * the own and inherited enumerable string keyed properties of `object` that
         * `predicate` doesn't return truthy for. The predicate is invoked with two
         * arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omitBy(object, _.isNumber);
         * // => { 'b': '2' }
         */
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }

        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        const pick = flatRest(function (object, paths) {
          return object == null ? {} : basePick(object, paths);
        });

        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          const props = arrayMap(getAllKeysIn(object), function (prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function (value, path) {
            return predicate(value, path[0]);
          });
        }

        /**
         * This method is like `_.get` except that if the resolved value is a
         * function it's invoked with the `this` binding of its parent object and
         * its result is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a[0].b.c3', 'default');
         * // => 'default'
         *
         * _.result(object, 'a[0].b.c3', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          path = castPath(path, object);

          let index = -1,
            length = path.length;

          // Ensure the loop is entered when path is empty.
          if (!length) {
            length = 1;
            object = undefined;
          }
          while (++index < length) {
            let value = object == null ? undefined : object[toKey(path[index])];
            if (value === undefined) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }

        /**
         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
         * it's created. Arrays are created for missing index properties while objects
         * are created for all other missing properties. Use `_.setWith` to customize
         * `path` creation.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, ['x', '0', 'y', 'z'], 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }

        /**
         * This method is like `_.set` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.setWith(object, '[0][1]', 'a', Object);
         * // => { '0': { '1': 'a' } }
         */
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return object == null ? object : baseSet(object, path, value, customizer);
        }

        /**
         * Creates an array of own enumerable string keyed-value pairs for `object`
         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
         * entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entries
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairs(new Foo);
         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
         */
        const toPairs = createToPairs(keys);

        /**
         * Creates an array of own and inherited enumerable string keyed-value pairs
         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
         * or set, its entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entriesIn
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairsIn(new Foo);
         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
         */
        const toPairsIn = createToPairs(keysIn);

        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own
         * enumerable string keyed properties thru `iteratee`, with each invocation
         * potentially mutating the `accumulator` object. If `accumulator` is not
         * provided, a new object with the same `[[Prototype]]` will be used. The
         * iteratee is invoked with four arguments: (accumulator, value, key, object).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * }, []);
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function transform(object, iteratee, accumulator) {
          const isArr = isArray(object),
            isArrLike = isArr || isBuffer(object) || isTypedArray(object);

          iteratee = getIteratee(iteratee, 4);
          if (accumulator == null) {
            const Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }

        /**
         * Removes the property at `path` of `object`.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
         * _.unset(object, 'a[0].b.c');
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         *
         * _.unset(object, ['a', '0', 'b', 'c']);
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         */
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }

        /**
         * This method is like `_.set` except that accepts `updater` to produce the
         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
         * is invoked with one argument: (value).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
         * console.log(object.a[0].b.c);
         * // => 9
         *
         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
         * console.log(object.x[0].y.z);
         * // => 0
         */
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }

        /**
         * This method is like `_.update` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
         * // => { '0': { '1': 'a' } }
         */
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }

        /**
         * Creates an array of the own enumerable string keyed property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }

        /**
         * Creates an array of the own and inherited enumerable string keyed property
         * values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }

        /*------------------------------------------------------------------------*/

        /**
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Number
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         * // => 5
         */
        function clamp(number, lower, upper) {
          if (upper === undefined) {
            upper = lower;
            lower = undefined;
          }
          if (upper !== undefined) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }

        /**
         * Checks if `n` is between `start` and up to, but not including, `end`. If
         * `end` is not specified, it's set to `start` with `start` then set to `0`.
         * If `start` is greater than `end` the params are swapped to support
         * negative ranges.
         *
         * @static
         * @memberOf _
         * @since 3.3.0
         * @category Number
         * @param {number} number The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         * @see _.range, _.rangeRight
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         *
         * _.inRange(-3, -2, -6);
         * // => true
         */
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }

        /**
         * Produces a random number between the inclusive `lower` and `upper` bounds.
         * If only one argument is provided a number between `0` and the given number
         * is returned. If `floating` is `true`, or either `lower` or `upper` are
         * floats, a floating-point number is returned instead of an integer.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Number
         * @param {number} [lower=0] The lower bound.
         * @param {number} [upper=1] The upper bound.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(lower, upper, floating) {
          if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined;
          }
          if (floating === undefined) {
            if (typeof upper == 'boolean') {
              floating = upper;
              upper = undefined;
            } else if (typeof lower == 'boolean') {
              floating = lower;
              lower = undefined;
            }
          }
          if (lower === undefined && upper === undefined) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            const temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            const rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar--');
         * // => 'fooBar'
         *
         * _.camelCase('__FOO_BAR__');
         * // => 'fooBar'
         */
        const camelCase = createCompounder(function (result, word, index) {
          word = word.toLowerCase();
          return result + (index ? capitalize(word) : word);
        });

        /**
         * Converts the first character of `string` to upper case and the remaining
         * to lower case.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('FRED');
         * // => 'Fred'
         */
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }

        /**
         * Deburrs `string` by converting
         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
         * letters to basic Latin letters and removing
         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('déjà vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
        }

        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search up to.
         * @returns {boolean} Returns `true` if `string` ends with `target`,
         *  else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);

          const length = string.length;
          position = position === undefined ? length : baseClamp(toInteger(position), 0, length);

          const end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }

        /**
         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
         * corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional
         * characters use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value. See
         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * When working with HTML you should always
         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
         * XSS vectors.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }

        /**
         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
         * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https://lodash\.com/\)'
         */
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
        }

        /**
         * Converts `string` to
         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__FOO_BAR__');
         * // => 'foo-bar'
         */
        const kebabCase = createCompounder(function (result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });

        /**
         * Converts `string`, as space separated words, to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.lowerCase('--Foo-Bar--');
         * // => 'foo bar'
         *
         * _.lowerCase('fooBar');
         * // => 'foo bar'
         *
         * _.lowerCase('__FOO_BAR__');
         * // => 'foo bar'
         */
        const lowerCase = createCompounder(function (result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase();
        });

        /**
         * Converts the first character of `string` to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.lowerFirst('Fred');
         * // => 'fred'
         *
         * _.lowerFirst('FRED');
         * // => 'fRED'
         */
        const lowerFirst = createCaseFirst('toLowerCase');

        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          const strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          const mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }

        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padEnd('abc', 6);
         * // => 'abc   '
         *
         * _.padEnd('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padEnd('abc', 3);
         * // => 'abc'
         */
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          const strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }

        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padStart('abc', 6);
         * // => '   abc'
         *
         * _.padStart('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padStart('abc', 3);
         * // => 'abc'
         */
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          const strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }

        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
         * hexadecimal, in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the
         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix=10] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
        }

        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=1] The number of times to repeat the string.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }

        /**
         * Replaces matches for `pattern` in `string` with `replacement`.
         *
         * **Note:** This method is based on
         * [`String#replace`](https://mdn.io/String/replace).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to modify.
         * @param {RegExp|string} pattern The pattern to replace.
         * @param {Function|string} replacement The match replacement.
         * @returns {string} Returns the modified string.
         * @example
         *
         * _.replace('Hi Fred', 'Fred', 'Barney');
         * // => 'Hi Barney'
         */
        function replace() {
          const args = arguments,
            string = toString(args[0]);

          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }

        /**
         * Converts `string` to
         * [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--FOO-BAR--');
         * // => 'foo_bar'
         */
        const snakeCase = createCompounder(function (result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });

        /**
         * Splits `string` by `separator`.
         *
         * **Note:** This method is based on
         * [`String#split`](https://mdn.io/String/split).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to split.
         * @param {RegExp|string} separator The separator pattern to split by.
         * @param {number} [limit] The length to truncate results to.
         * @returns {Array} Returns the string segments.
         * @example
         *
         * _.split('a-b-c', '-', 2);
         * // => ['a', 'b']
         */
        function split(string, separator, limit) {
          if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined;
          }
          limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == 'string' || (separator != null && !isRegExp(separator)))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }

        /**
         * Converts `string` to
         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @since 3.1.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar--');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__FOO_BAR__');
         * // => 'FOO BAR'
         */
        const startCase = createCompounder(function (result, word, index) {
          return result + (index ? ' ' : '') + upperFirst(word);
        });

        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`,
         *  else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);

          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }

        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is given, it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options={}] The options object.
         * @param {RegExp} [options.escape=_.templateSettings.escape]
         *  The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
         *  The "evaluate" delimiter.
         * @param {Object} [options.imports=_.templateSettings.imports]
         *  An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
         *  The "interpolate" delimiter.
         * @param {string} [options.sourceURL='lodash.templateSources[n]']
         *  The sourceURL of the compiled template.
         * @param {string} [options.variable='obj']
         *  The data object variable name.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // Use the "interpolate" delimiter to create a compiled template.
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // Use the HTML "escape" delimiter to escape data property values.
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the internal `print` function in "evaluate" delimiters.
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // Use the ES template literal delimiter as an "interpolate" delimiter.
         * // Disable support by replacing the "interpolate" delimiter.
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // Use backslashes to treat delimiters as plain text.
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // Use the `imports` option to import `jQuery` as `jq`.
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
         *
         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // Use custom template delimiters.
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // Use the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and stack traces.
         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, guard) {
          // Based on John Resig's `tmpl` implementation
          // (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          const settings = lodash.templateSettings;

          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);

          const imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
            importsKeys = keys(imports),
            importsValues = baseValues(imports, importsKeys);

          let isEscaping,
            isEvaluating,
            index = 0,
            interpolate = options.interpolate || reNoMatch,
            source = "__p += '";

          // Compile the regexp to match each delimiter.
          const reDelimiters = RegExp(
            (options.escape || reNoMatch).source +
              '|' +
              interpolate.source +
              '|' +
              (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source +
              '|' +
              (options.evaluate || reNoMatch).source +
              '|$',
            'g',
          );

          // Use a sourceURL for easier debugging.
          // The sourceURL gets injected into the source that's eval-ed, so be careful
          // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
          // and escape the comment, thus injecting code that gets evaled.
          const sourceURL =
            '//# sourceURL=' +
            (hasOwnProperty.call(options, 'sourceURL')
              ? (options.sourceURL + '').replace(/\s/g, ' ')
              : 'lodash.templateSources[' + ++templateCounter + ']') +
            '\n';

          string.replace(
            reDelimiters,
            function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);

              // Escape characters that can't be included in string literals.
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

              // Replace delimiters with snippets.
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;

              // The JS engine embedded in Adobe products needs `match` returned in
              // order to produce the correct `offset` value.
              return match;
            },
          );

          source += "';\n";

          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          const variable = hasOwnProperty.call(options, 'variable') && options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Throw an error if a forbidden character was found in `variable`, to prevent
          // potential command injection attacks.
          else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
          }

          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');

          // Frame code as the function body.
          source =
            'function(' +
            (variable || 'obj') +
            ') {\n' +
            (variable ? '' : 'obj || (obj = {});\n') +
            "var __t, __p = ''" +
            (isEscaping ? ', __e = _.escape' : '') +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n') +
            source +
            'return __p\n}';

          const result = attempt(function () {
            return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
          });

          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }

        /**
         * Converts `string`, as a whole, to lower case just like
         * [String#toLowerCase](https://mdn.io/toLowerCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.toLower('--Foo-Bar--');
         * // => '--foo-bar--'
         *
         * _.toLower('fooBar');
         * // => 'foobar'
         *
         * _.toLower('__FOO_BAR__');
         * // => '__foo_bar__'
         */
        function toLower(value) {
          return toString(value).toLowerCase();
        }

        /**
         * Converts `string`, as a whole, to upper case just like
         * [String#toUpperCase](https://mdn.io/toUpperCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.toUpper('--foo-bar--');
         * // => '--FOO-BAR--'
         *
         * _.toUpper('fooBar');
         * // => 'FOOBAR'
         *
         * _.toUpper('__foo_bar__');
         * // => '__FOO_BAR__'
         */
        function toUpper(value) {
          return toString(value).toUpperCase();
        }

        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          const strSymbols = stringToArray(string),
            chrSymbols = stringToArray(chars),
            start = charsStartIndex(strSymbols, chrSymbols),
            end = charsEndIndex(strSymbols, chrSymbols) + 1;

          return castSlice(strSymbols, start, end).join('');
        }

        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimEnd('  abc  ');
         * // => '  abc'
         *
         * _.trimEnd('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          const strSymbols = stringToArray(string),
            end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

          return castSlice(strSymbols, 0, end).join('');
        }

        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimStart('  abc  ');
         * // => 'abc  '
         *
         * _.trimStart('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined)) {
            return string.replace(reTrimStart, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          const strSymbols = stringToArray(string),
            start = charsStartIndex(strSymbols, stringToArray(chars));

          return castSlice(strSymbols, start).join('');
        }

        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object} [options={}] The options object.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.truncate('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function truncate(string, options) {
          let length = DEFAULT_TRUNC_LENGTH,
            omission = DEFAULT_TRUNC_OMISSION;

          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? toInteger(options.length) : length;
            omission = 'omission' in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);

          let strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          let end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          let result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);

          if (separator === undefined) {
            return result + omission;
          }
          if (strSymbols) {
            end += result.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              let match,
                substring = result;

              if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result = result.slice(0, newEnd === undefined ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            const index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }

        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
         * their corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional
         * HTML entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @since 0.6.0
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }

        /**
         * Converts `string`, as space separated words, to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.upperCase('--foo-bar');
         * // => 'FOO BAR'
         *
         * _.upperCase('fooBar');
         * // => 'FOO BAR'
         *
         * _.upperCase('__foo_bar__');
         * // => 'FOO BAR'
         */
        const upperCase = createCompounder(function (result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase();
        });

        /**
         * Converts the first character of `string` to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.upperFirst('fred');
         * // => 'Fred'
         *
         * _.upperFirst('FRED');
         * // => 'FRED'
         */
        var upperFirst = createCaseFirst('toUpperCase');

        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined : pattern;

          if (pattern === undefined) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }

        /*------------------------------------------------------------------------*/

        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Function} func The function to attempt.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // Avoid throwing errors for invalid selectors.
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = baseRest(function (func, args) {
          try {
            return apply(func, undefined, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });

        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method.
         *
         * **Note:** This method doesn't set the "length" property of bound functions.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} methodNames The object method names to bind.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'click': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view, ['click']);
         * jQuery(element).on('click', view.click);
         * // => Logs 'clicked docs' when clicked.
         */
        const bindAll = flatRest(function (object, methodNames) {
          arrayEach(methodNames, function (key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });

        /**
         * Creates a function that iterates over `pairs` and invokes the corresponding
         * function of the first predicate to return truthy. The predicate-function
         * pairs are invoked with the `this` binding and arguments of the created
         * function.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Array} pairs The predicate-function pairs.
         * @returns {Function} Returns the new composite function.
         * @example
         *
         * var func = _.cond([
         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
         *   [_.stubTrue,                      _.constant('no match')]
         * ]);
         *
         * func({ 'a': 1, 'b': 2 });
         * // => 'matches A'
         *
         * func({ 'a': 0, 'b': 1 });
         * // => 'matches B'
         *
         * func({ 'a': '1', 'b': '2' });
         * // => 'no match'
         */
        function cond(pairs) {
          const length = pairs == null ? 0 : pairs.length,
            toIteratee = getIteratee();

          pairs = !length
            ? []
            : arrayMap(pairs, function (pair) {
                if (typeof pair[1] != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                return [toIteratee(pair[0]), pair[1]];
              });

          return baseRest(function (args) {
            let index = -1;
            while (++index < length) {
              const pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }

        /**
         * Creates a function that invokes the predicate properties of `source` with
         * the corresponding property values of a given object, returning `true` if
         * all predicates return truthy, else `false`.
         *
         * **Note:** The created function is equivalent to `_.conformsTo` with
         * `source` partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 2, 'b': 1 },
         *   { 'a': 1, 'b': 2 }
         * ];
         *
         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
         * // => [{ 'a': 1, 'b': 2 }]
         */
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function () {
            return value;
          };
        }

        /**
         * Checks `value` to determine whether a default value should be returned in
         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
         * or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Util
         * @param {*} value The value to check.
         * @param {*} defaultValue The default value.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * _.defaultTo(1, 10);
         * // => 1
         *
         * _.defaultTo(undefined, 10);
         * // => 10
         */
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }

        /**
         * Creates a function that returns the result of invoking the given functions
         * with the `this` binding of the created function, where each successive
         * invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flowRight
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow([_.add, square]);
         * addSquare(1, 2);
         * // => 9
         */
        const flow = createFlow();

        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the given functions from right to left.
         *
         * @static
         * @since 3.0.0
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flow
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight([square, _.add]);
         * addSquare(1, 2);
         * // => 9
         */
        const flowRight = createFlow(true);

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        /**
         * Creates a function that invokes `func` with the arguments of the created
         * function. If `func` is a property name, the created function returns the
         * property value for a given element. If `func` is an array or object, the
         * created function returns `true` for elements that contain the equivalent
         * source properties, otherwise it returns `false`.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Util
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, _.iteratee(['user', 'fred']));
         * // => [{ 'user': 'fred', 'age': 40 }]
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, _.iteratee('user'));
         * // => ['barney', 'fred']
         *
         * // Create custom iteratee shorthands.
         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
         *     return func.test(string);
         *   };
         * });
         *
         * _.filter(['abc', 'def'], /ef/);
         * // => ['def']
         */
        function iteratee(func) {
          return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between a given
         * object and `source`, returning `true` if the given object has equivalent
         * property values, else `false`.
         *
         * **Note:** The created function is equivalent to `_.isMatch` with `source`
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * **Note:** Multiple values can be checked by combining several matchers
         * using `_.overSome`
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
         *
         * // Checking for several possible values
         * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between the
         * value at `path` of a given object to `srcValue`, returning `true` if the
         * object value is equivalent, else `false`.
         *
         * **Note:** Partial comparisons will match empty array and empty object
         * `srcValue` values against any array or object value, respectively. See
         * `_.isEqual` for a list of supported value comparisons.
         *
         * **Note:** Multiple values can be checked by combining several matchers
         * using `_.overSome`
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.find(objects, _.matchesProperty('a', 4));
         * // => { 'a': 4, 'b': 5, 'c': 6 }
         *
         * // Checking for several possible values
         * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that invokes the method at `path` of a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': _.constant(2) } },
         *   { 'a': { 'b': _.constant(1) } }
         * ];
         *
         * _.map(objects, _.method('a.b'));
         * // => [2, 1]
         *
         * _.map(objects, _.method(['a', 'b']));
         * // => [2, 1]
         */
        const method = baseRest(function (path, args) {
          return function (object) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path of `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        const methodOf = baseRest(function (object, args) {
          return function (path) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * Adds all own enumerable string keyed function properties of a source
         * object to the destination object. If `object` is a function, then methods
         * are added to its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          let props = keys(source),
            methodNames = baseFunctions(source, props);

          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          const chain = !(isObject(options) && 'chain' in options) || !!options.chain,
            isFunc = isFunction(object);

          arrayEach(methodNames, function (methodName) {
            const func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function () {
                const chainAll = this.__chain__;
                if (chain || chainAll) {
                  const result = object(this.__wrapped__),
                    actions = (result.__actions__ = copyArray(this.__actions__));

                  actions.push({ func: func, args: arguments, thisArg: object });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });

          return object;
        }

        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }

        /**
         * This method returns `undefined`.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Util
         * @example
         *
         * _.times(2, _.noop);
         * // => [undefined, undefined]
         */
        function noop() {
          // No operation performed.
        }

        /**
         * Creates a function that gets the argument at index `n`. If `n` is negative,
         * the nth argument from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [n=0] The index of the argument to return.
         * @returns {Function} Returns the new pass-thru function.
         * @example
         *
         * var func = _.nthArg(1);
         * func('a', 'b', 'c', 'd');
         * // => 'b'
         *
         * var func = _.nthArg(-2);
         * func('a', 'b', 'c', 'd');
         * // => 'c'
         */
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function (args) {
            return baseNth(args, n);
          });
        }

        /**
         * Creates a function that invokes `iteratees` with the arguments it receives
         * and returns their results.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.over([Math.max, Math.min]);
         *
         * func(1, 2, 3, 4);
         * // => [4, 1]
         */
        const over = createOver(arrayMap);

        /**
         * Creates a function that checks if **all** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * Following shorthands are possible for providing predicates.
         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overEvery([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => false
         *
         * func(NaN);
         * // => false
         */
        const overEvery = createOver(arrayEvery);

        /**
         * Creates a function that checks if **any** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * Following shorthands are possible for providing predicates.
         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overSome([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => true
         *
         * func(NaN);
         * // => false
         *
         * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
         * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
         */
        const overSome = createOver(arraySome);

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }

        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the value at a given path of `object`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function (path) {
            return object == null ? undefined : baseGet(object, path);
          };
        }

        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        const range = createRange();

        /**
         * This method is like `_.range` except that it populates values in
         * descending order.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.range
         * @example
         *
         * _.rangeRight(4);
         * // => [3, 2, 1, 0]
         *
         * _.rangeRight(-4);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 5);
         * // => [4, 3, 2, 1]
         *
         * _.rangeRight(0, 20, 5);
         * // => [15, 10, 5, 0]
         *
         * _.rangeRight(0, -4, -1);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.rangeRight(0);
         * // => []
         */
        const rangeRight = createRange(true);

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        /**
         * This method returns a new empty object.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Object} Returns the new empty object.
         * @example
         *
         * var objects = _.times(2, _.stubObject);
         *
         * console.log(objects);
         * // => [{}, {}]
         *
         * console.log(objects[0] === objects[1]);
         * // => false
         */
        function stubObject() {
          return {};
        }

        /**
         * This method returns an empty string.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {string} Returns the empty string.
         * @example
         *
         * _.times(2, _.stubString);
         * // => ['', '']
         */
        function stubString() {
          return '';
        }

        /**
         * This method returns `true`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `true`.
         * @example
         *
         * _.times(2, _.stubTrue);
         * // => [true, true]
         */
        function stubTrue() {
          return true;
        }

        /**
         * Invokes the iteratee `n` times, returning an array of the results of
         * each invocation. The iteratee is invoked with one argument; (index).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.times(3, String);
         * // => ['0', '1', '2']
         *
         *  _.times(4, _.constant(0));
         * // => [0, 0, 0, 0]
         */
        function times(n, iteratee) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          let index = MAX_ARRAY_LENGTH,
            length = nativeMin(n, MAX_ARRAY_LENGTH);

          iteratee = getIteratee(iteratee);
          n -= MAX_ARRAY_LENGTH;

          const result = baseTimes(length, iteratee);
          while (++index < n) {
            iteratee(index);
          }
          return result;
        }

        /**
         * Converts `value` to a property path array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {*} value The value to convert.
         * @returns {Array} Returns the new property path array.
         * @example
         *
         * _.toPath('a.b.c');
         * // => ['a', 'b', 'c']
         *
         * _.toPath('a[0].b.c');
         * // => ['a', '0', 'b', 'c']
         */
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }

        /**
         * Generates a unique ID. If `prefix` is given, the ID is appended to it.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {string} [prefix=''] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          const id = ++idCounter;
          return toString(prefix) + id;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {number} augend The first number in an addition.
         * @param {number} addend The second number in an addition.
         * @returns {number} Returns the total.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        const add = createMathOperation(function (augend, addend) {
          return augend + addend;
        }, 0);

        /**
         * Computes `number` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        const ceil = createRound('ceil');

        /**
         * Divide two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} dividend The first number in a division.
         * @param {number} divisor The second number in a division.
         * @returns {number} Returns the quotient.
         * @example
         *
         * _.divide(6, 4);
         * // => 1.5
         */
        const divide = createMathOperation(function (dividend, divisor) {
          return dividend / divisor;
        }, 1);

        /**
         * Computes `number` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        const floor = createRound('floor');

        /**
         * Computes the maximum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => undefined
         */
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
        }

        /**
         * This method is like `_.max` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.maxBy(objects, function(o) { return o.n; });
         * // => { 'n': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.maxBy(objects, 'n');
         * // => { 'n': 2 }
         */
        function maxBy(array, iteratee) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
        }

        /**
         * Computes the mean of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the mean.
         * @example
         *
         * _.mean([4, 2, 8, 6]);
         * // => 5
         */
        function mean(array) {
          return baseMean(array, identity);
        }

        /**
         * This method is like `_.mean` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be averaged.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the mean.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.meanBy(objects, function(o) { return o.n; });
         * // => 5
         *
         * // The `_.property` iteratee shorthand.
         * _.meanBy(objects, 'n');
         * // => 5
         */
        function meanBy(array, iteratee) {
          return baseMean(array, getIteratee(iteratee, 2));
        }

        /**
         * Computes the minimum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => undefined
         */
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
        }

        /**
         * This method is like `_.min` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.minBy(objects, function(o) { return o.n; });
         * // => { 'n': 1 }
         *
         * // The `_.property` iteratee shorthand.
         * _.minBy(objects, 'n');
         * // => { 'n': 1 }
         */
        function minBy(array, iteratee) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
        }

        /**
         * Multiply two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} multiplier The first number in a multiplication.
         * @param {number} multiplicand The second number in a multiplication.
         * @returns {number} Returns the product.
         * @example
         *
         * _.multiply(6, 4);
         * // => 24
         */
        const multiply = createMathOperation(function (multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);

        /**
         * Computes `number` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        const round = createRound('round');

        /**
         * Subtract two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {number} minuend The first number in a subtraction.
         * @param {number} subtrahend The second number in a subtraction.
         * @returns {number} Returns the difference.
         * @example
         *
         * _.subtract(6, 4);
         * // => 2
         */
        const subtract = createMathOperation(function (minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);

        /**
         * Computes the sum of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 2, 8, 6]);
         * // => 20
         */
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }

        /**
         * This method is like `_.sum` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be summed.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the sum.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.sumBy(objects, function(o) { return o.n; });
         * // => 20
         *
         * // The `_.property` iteratee shorthand.
         * _.sumBy(objects, 'n');
         * // => 20
         */
        function sumBy(array, iteratee) {
          return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
        }

        /*------------------------------------------------------------------------*/

        // Add methods that return wrapped values in chain sequences.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;

        // Add aliases.
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;

        // Add methods to `lodash.prototype`.
        mixin(lodash, lodash);

        /*------------------------------------------------------------------------*/

        // Add methods that return unwrapped values in chain sequences.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;

        // Add aliases.
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;

        mixin(
          lodash,
          (function () {
            const source = {};
            baseForOwn(lodash, function (func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          })(),
          { chain: false },
        );

        /*------------------------------------------------------------------------*/

        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type {string}
         */
        lodash.VERSION = VERSION;

        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
          lodash[methodName].placeholder = lodash;
        });

        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function (methodName, index) {
          LazyWrapper.prototype[methodName] = function (n) {
            n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

            const result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();

            if (result.__filtered__) {
              result.__takeCount__ = nativeMin(n, result.__takeCount__);
            } else {
              result.__views__.push({
                size: nativeMin(n, MAX_ARRAY_LENGTH),
                type: methodName + (result.__dir__ < 0 ? 'Right' : ''),
              });
            }
            return result;
          };

          LazyWrapper.prototype[methodName + 'Right'] = function (n) {
            return this.reverse()[methodName](n).reverse();
          };
        });

        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
          const type = index + 1,
            isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

          LazyWrapper.prototype[methodName] = function (iteratee) {
            const result = this.clone();
            result.__iteratees__.push({
              iteratee: getIteratee(iteratee, 3),
              type: type,
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });

        // Add `LazyWrapper` methods for `_.head` and `_.last`.
        arrayEach(['head', 'last'], function (methodName, index) {
          const takeName = 'take' + (index ? 'Right' : '');

          LazyWrapper.prototype[methodName] = function () {
            return this[takeName](1).value()[0];
          };
        });

        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
        arrayEach(['initial', 'tail'], function (methodName, index) {
          const dropName = 'drop' + (index ? '' : 'Right');

          LazyWrapper.prototype[methodName] = function () {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });

        LazyWrapper.prototype.compact = function () {
          return this.filter(identity);
        };

        LazyWrapper.prototype.find = function (predicate) {
          return this.filter(predicate).head();
        };

        LazyWrapper.prototype.findLast = function (predicate) {
          return this.reverse().find(predicate);
        };

        LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
          if (typeof path == 'function') {
            return new LazyWrapper(this);
          }
          return this.map(function (value) {
            return baseInvoke(value, path, args);
          });
        });

        LazyWrapper.prototype.reject = function (predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };

        LazyWrapper.prototype.slice = function (start, end) {
          start = toInteger(start);

          let result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined) {
            end = toInteger(end);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };

        LazyWrapper.prototype.takeRightWhile = function (predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };

        LazyWrapper.prototype.toArray = function () {
          return this.take(MAX_ARRAY_LENGTH);
        };

        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          const checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
            isTaker = /^(?:head|last)$/.test(methodName),
            lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
            retUnwrapped = isTaker || /^find/.test(methodName);

          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function () {
            let value = this.__wrapped__,
              args = isTaker ? [1] : arguments,
              isLazy = value instanceof LazyWrapper,
              iteratee = args[0],
              useLazy = isLazy || isArray(value);

            const interceptor = function (value) {
              const result = lodashFunc.apply(lodash, arrayPush([value], args));
              return isTaker && chainAll ? result[0] : result;
            };

            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
              isHybrid = !!this.__actions__.length,
              isUnwrapped = retUnwrapped && !chainAll,
              onlyLazy = isLazy && !isHybrid;

            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined });
              return new LodashWrapper(result, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result = this.thru(interceptor);
            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
          };
        });

        // Add `Array` methods to `lodash.prototype`.
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
          const func = arrayProto[methodName],
            chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
            retUnwrapped = /^(?:pop|shift)$/.test(methodName);

          lodash.prototype[methodName] = function () {
            const args = arguments;
            if (retUnwrapped && !this.__chain__) {
              const value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function (value) {
              return func.apply(isArray(value) ? value : [], args);
            });
          };
        });

        // Map minified method names to their real names.
        baseForOwn(LazyWrapper.prototype, function (func, methodName) {
          const lodashFunc = lodash[methodName];
          if (lodashFunc) {
            const key = lodashFunc.name + '';
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ name: methodName, func: lodashFunc });
          }
        });

        realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [
          {
            name: 'wrapper',
            func: undefined,
          },
        ];

        // Add methods to `LazyWrapper`.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;

        // Add chain sequence methods to the `lodash` wrapper.
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

        // Add lazy aliases.
        lodash.prototype.first = lodash.prototype.head;

        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };

      /*--------------------------------------------------------------------------*/

      // Export lodash.
      var _ = runInContext();

      // Some AMD build optimizers, like r.js, check for condition patterns like:
      if (true) {
        // Expose Lodash on the global object to prevent errors when Lodash is
        // loaded by a script tag in the presence of an AMD loader.
        // See http://requirejs.org/docs/errors.html#mismatch for more details.
        // Use `_.noConflict` to remove Lodash from the global object.
        root._ = _;

        // Define as an anonymous module so, through path mapping, it can be
        // referenced as the "underscore" module.
        !((__WEBPACK_AMD_DEFINE_RESULT__ = function () {
          return _;
        }.call(exports, __webpack_require__, exports, module)),
        __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
      }
      // Check for `exports` after `define` in case a build optimizer adds it.
      // removed by dead control flow
      else {
      }
    }).call(this);

    /***/
  },

  /***/ 3001: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const WebSocket = __webpack_require__(7926);

    WebSocket.createWebSocketStream = __webpack_require__(7013);
    WebSocket.Server = __webpack_require__(4240);
    WebSocket.Receiver = __webpack_require__(8348);
    WebSocket.Sender = __webpack_require__(9364);

    WebSocket.WebSocket = WebSocket;
    WebSocket.WebSocketServer = WebSocket.Server;

    module.exports = WebSocket;

    /***/
  },

  /***/ 3024: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('node:fs');

    /***/
  },

  /***/ 3106: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('zlib');

    /***/
  },

  /***/ 3480: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('querystring');

    /***/
  },

  /***/ 3554: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Scalar = __webpack_require__(6364);
    const stringifyNumber = __webpack_require__(2490);

    const floatNaN = {
      identify: value => typeof value === 'number',
      default: true,
      tag: 'tag:yaml.org,2002:float',
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: str =>
        str.slice(-3).toLowerCase() === 'nan'
          ? NaN
          : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber,
    };
    const floatExp = {
      identify: value => typeof value === 'number',
      default: true,
      tag: 'tag:yaml.org,2002:float',
      format: 'EXP',
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: str => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      },
    };
    const float = {
      identify: value => typeof value === 'number',
      default: true,
      tag: 'tag:yaml.org,2002:float',
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0') node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber,
    };

    exports.float = float;
    exports.floatExp = floatExp;
    exports.floatNaN = floatNaN;

    /***/
  },

  /***/ 3557: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('timers');

    /***/
  },

  /***/ 3641: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.reconstructPacket = exports.deconstructPacket = void 0;
    const is_binary_js_1 = __webpack_require__(180);
    /**
     * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
     *
     * @param {Object} packet - socket.io event packet
     * @return {Object} with deconstructed packet and list of buffers
     * @public
     */
    function deconstructPacket(packet) {
      const buffers = [];
      const packetData = packet.data;
      const pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length; // number of binary 'attachments'
      return { packet: pack, buffers: buffers };
    }
    exports.deconstructPacket = deconstructPacket;
    function _deconstructPacket(data, buffers) {
      if (!data) return data;
      if ((0, is_binary_js_1.isBinary)(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
      } else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
          newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
      } else if (typeof data === 'object' && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            newData[key] = _deconstructPacket(data[key], buffers);
          }
        }
        return newData;
      }
      return data;
    }
    /**
     * Reconstructs a binary packet from its placeholder packet and buffers
     *
     * @param {Object} packet - event packet with placeholders
     * @param {Array} buffers - binary buffers to put in placeholder positions
     * @return {Object} reconstructed packet
     * @public
     */
    function reconstructPacket(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      delete packet.attachments; // no longer useful
      return packet;
    }
    exports.reconstructPacket = reconstructPacket;
    function _reconstructPacket(data, buffers) {
      if (!data) return data;
      if (data && data._placeholder === true) {
        const isIndexValid = typeof data.num === 'number' && data.num >= 0 && data.num < buffers.length;
        if (isIndexValid) {
          return buffers[data.num]; // appropriate buffer (should be natural order anyway)
        } else {
          throw new Error('illegal attachments');
        }
      } else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
          data[i] = _reconstructPacket(data[i], buffers);
        }
      } else if (typeof data === 'object') {
        for (const key in data) {
          if (Object.prototype.hasOwnProperty.call(data, key)) {
            data[key] = _reconstructPacket(data[key], buffers);
          }
        }
      }
      return data;
    }

    /***/
  },

  /***/ 3754: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Scalar = __webpack_require__(6364);

    const boolTag = {
      identify: value => typeof value === 'boolean',
      default: true,
      tag: 'tag:yaml.org,2002:bool',
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === 't' || source[0] === 'T';
          if (value === sv) return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      },
    };

    exports.boolTag = boolTag;

    /***/
  },

  /***/ 3761: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.RemoteSocket = exports.BroadcastOperator = void 0;
    const socket_types_1 = __webpack_require__(8578);
    const socket_io_parser_1 = __webpack_require__(9834);
    class BroadcastOperator {
      constructor(adapter, rooms = new Set(), exceptRooms = new Set(), flags = {}) {
        this.adapter = adapter;
        this.rooms = rooms;
        this.exceptRooms = exceptRooms;
        this.flags = flags;
      }
      /**
       * Targets a room when emitting.
       *
       * @example
       * // the “foo” event will be broadcast to all connected clients in the “room-101” room
       * io.to("room-101").emit("foo", "bar");
       *
       * // with an array of rooms (a client will be notified at most once)
       * io.to(["room-101", "room-102"]).emit("foo", "bar");
       *
       * // with multiple chained calls
       * io.to("room-101").to("room-102").emit("foo", "bar");
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      to(room) {
        const rooms = new Set(this.rooms);
        if (Array.isArray(room)) {
          room.forEach(r => rooms.add(r));
        } else {
          rooms.add(room);
        }
        return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
      }
      /**
       * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
       *
       * @example
       * // disconnect all clients in the "room-101" room
       * io.in("room-101").disconnectSockets();
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      in(room) {
        return this.to(room);
      }
      /**
       * Excludes a room when emitting.
       *
       * @example
       * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
       * io.except("room-101").emit("foo", "bar");
       *
       * // with an array of rooms
       * io.except(["room-101", "room-102"]).emit("foo", "bar");
       *
       * // with multiple chained calls
       * io.except("room-101").except("room-102").emit("foo", "bar");
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      except(room) {
        const exceptRooms = new Set(this.exceptRooms);
        if (Array.isArray(room)) {
          room.forEach(r => exceptRooms.add(r));
        } else {
          exceptRooms.add(room);
        }
        return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
      }
      /**
       * Sets the compress flag.
       *
       * @example
       * io.compress(false).emit("hello");
       *
       * @param compress - if `true`, compresses the sending data
       * @return a new BroadcastOperator instance
       */
      compress(compress) {
        const flags = Object.assign({}, this.flags, { compress });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
       * receive messages (because of network slowness or other issues, or because they’re connected through long polling
       * and is in the middle of a request-response cycle).
       *
       * @example
       * io.volatile.emit("hello"); // the clients may or may not receive it
       *
       * @return a new BroadcastOperator instance
       */
      get volatile() {
        const flags = Object.assign({}, this.flags, { volatile: true });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
       *
       * @example
       * // the “foo” event will be broadcast to all connected clients on this node
       * io.local.emit("foo", "bar");
       *
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      get local() {
        const flags = Object.assign({}, this.flags, { local: true });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
      }
      /**
       * Adds a timeout in milliseconds for the next operation
       *
       * @example
       * io.timeout(1000).emit("some-event", (err, responses) => {
       *   if (err) {
       *     // some clients did not acknowledge the event in the given delay
       *   } else {
       *     console.log(responses); // one response per client
       *   }
       * });
       *
       * @param timeout
       */
      timeout(timeout) {
        const flags = Object.assign({}, this.flags, { timeout });
        return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
      }
      /**
       * Emits to all clients.
       *
       * @example
       * // the “foo” event will be broadcast to all connected clients
       * io.emit("foo", "bar");
       *
       * // the “foo” event will be broadcast to all connected clients in the “room-101” room
       * io.to("room-101").emit("foo", "bar");
       *
       * // with an acknowledgement expected from all connected clients
       * io.timeout(1000).emit("some-event", (err, responses) => {
       *   if (err) {
       *     // some clients did not acknowledge the event in the given delay
       *   } else {
       *     console.log(responses); // one response per client
       *   }
       * });
       *
       * @return Always true
       */
      emit(ev, ...args) {
        if (socket_types_1.RESERVED_EVENTS.has(ev)) {
          throw new Error(`"${String(ev)}" is a reserved event name`);
        }
        // set up packet object
        const data = [ev, ...args];
        const packet = {
          type: socket_io_parser_1.PacketType.EVENT,
          data: data,
        };
        const withAck = typeof data[data.length - 1] === 'function';
        if (!withAck) {
          this.adapter.broadcast(packet, {
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
          });
          return true;
        }
        const ack = data.pop();
        let timedOut = false;
        const responses = [];
        const timer = setTimeout(() => {
          timedOut = true;
          ack.apply(this, [new Error('operation has timed out'), this.flags.expectSingleResponse ? null : responses]);
        }, this.flags.timeout);
        let expectedServerCount = -1;
        let actualServerCount = 0;
        let expectedClientCount = 0;
        const checkCompleteness = () => {
          if (!timedOut && expectedServerCount === actualServerCount && responses.length === expectedClientCount) {
            clearTimeout(timer);
            ack.apply(this, [null, this.flags.expectSingleResponse ? responses[0] : responses]);
          }
        };
        this.adapter.broadcastWithAck(
          packet,
          {
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
          },
          clientCount => {
            // each Socket.IO server in the cluster sends the number of clients that were notified
            expectedClientCount += clientCount;
            actualServerCount++;
            checkCompleteness();
          },
          clientResponse => {
            // each client sends an acknowledgement
            responses.push(clientResponse);
            checkCompleteness();
          },
        );
        this.adapter.serverCount().then(serverCount => {
          expectedServerCount = serverCount;
          checkCompleteness();
        });
        return true;
      }
      /**
       * Emits an event and waits for an acknowledgement from all clients.
       *
       * @example
       * try {
       *   const responses = await io.timeout(1000).emitWithAck("some-event");
       *   console.log(responses); // one response per client
       * } catch (e) {
       *   // some clients did not acknowledge the event in the given delay
       * }
       *
       * @return a Promise that will be fulfilled when all clients have acknowledged the event
       */
      emitWithAck(ev, ...args) {
        return new Promise((resolve, reject) => {
          args.push((err, responses) => {
            if (err) {
              err.responses = responses;
              return reject(err);
            } else {
              return resolve(responses);
            }
          });
          this.emit(ev, ...args);
        });
      }
      /**
       * Gets a list of clients.
       *
       * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
       * {@link fetchSockets} instead.
       */
      allSockets() {
        if (!this.adapter) {
          throw new Error(
            'No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?',
          );
        }
        return this.adapter.sockets(this.rooms);
      }
      /**
       * Returns the matching socket instances. This method works across a cluster of several Socket.IO servers.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * // return all Socket instances
       * const sockets = await io.fetchSockets();
       *
       * // return all Socket instances in the "room1" room
       * const sockets = await io.in("room1").fetchSockets();
       *
       * for (const socket of sockets) {
       *   console.log(socket.id);
       *   console.log(socket.handshake);
       *   console.log(socket.rooms);
       *   console.log(socket.data);
       *
       *   socket.emit("hello");
       *   socket.join("room1");
       *   socket.leave("room2");
       *   socket.disconnect();
       * }
       */
      fetchSockets() {
        return this.adapter
          .fetchSockets({
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
          })
          .then(sockets => {
            return sockets.map(socket => {
              if (socket.server) {
                return socket; // local instance
              } else {
                return new RemoteSocket(this.adapter, socket);
              }
            });
          });
      }
      /**
       * Makes the matching socket instances join the specified rooms.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       *
       * // make all socket instances join the "room1" room
       * io.socketsJoin("room1");
       *
       * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
       * io.in("room1").socketsJoin(["room2", "room3"]);
       *
       * @param room - a room, or an array of rooms
       */
      socketsJoin(room) {
        this.adapter.addSockets(
          {
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
          },
          Array.isArray(room) ? room : [room],
        );
      }
      /**
       * Makes the matching socket instances leave the specified rooms.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * // make all socket instances leave the "room1" room
       * io.socketsLeave("room1");
       *
       * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
       * io.in("room1").socketsLeave(["room2", "room3"]);
       *
       * @param room - a room, or an array of rooms
       */
      socketsLeave(room) {
        this.adapter.delSockets(
          {
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
          },
          Array.isArray(room) ? room : [room],
        );
      }
      /**
       * Makes the matching socket instances disconnect.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
       * io.disconnectSockets();
       *
       * // make all socket instances in the "room1" room disconnect and close the underlying connections
       * io.in("room1").disconnectSockets(true);
       *
       * @param close - whether to close the underlying connection
       */
      disconnectSockets(close = false) {
        this.adapter.disconnectSockets(
          {
            rooms: this.rooms,
            except: this.exceptRooms,
            flags: this.flags,
          },
          close,
        );
      }
    }
    exports.BroadcastOperator = BroadcastOperator;
    /**
     * Expose of subset of the attributes and methods of the Socket class
     */
    class RemoteSocket {
      constructor(adapter, details) {
        this.id = details.id;
        this.handshake = details.handshake;
        this.rooms = new Set(details.rooms);
        this.data = details.data;
        this.operator = new BroadcastOperator(adapter, new Set([this.id]), new Set(), {
          expectSingleResponse: true, // so that remoteSocket.emit() with acknowledgement behaves like socket.emit()
        });
      }
      /**
       * Adds a timeout in milliseconds for the next operation.
       *
       * @example
       * const sockets = await io.fetchSockets();
       *
       * for (const socket of sockets) {
       *   if (someCondition) {
       *     socket.timeout(1000).emit("some-event", (err) => {
       *       if (err) {
       *         // the client did not acknowledge the event in the given delay
       *       }
       *     });
       *   }
       * }
       *
       * // note: if possible, using a room instead of looping over all sockets is preferable
       * io.timeout(1000).to(someConditionRoom).emit("some-event", (err, responses) => {
       *   // ...
       * });
       *
       * @param timeout
       */
      timeout(timeout) {
        return this.operator.timeout(timeout);
      }
      emit(ev, ...args) {
        return this.operator.emit(ev, ...args);
      }
      /**
       * Joins a room.
       *
       * @param {String|Array} room - room or array of rooms
       */
      join(room) {
        return this.operator.socketsJoin(room);
      }
      /**
       * Leaves a room.
       *
       * @param {String} room
       */
      leave(room) {
        return this.operator.socketsLeave(room);
      }
      /**
       * Disconnects this client.
       *
       * @param {Boolean} close - if `true`, closes the underlying connection
       * @return {Socket} self
       */
      disconnect(close = false) {
        this.operator.disconnectSockets(close);
        return this;
      }
    }
    exports.RemoteSocket = RemoteSocket;

    /***/
  },

  /***/ 3774: /***/ (__unused_webpack_module, exports) => {
    /**
     * Stringifies a comment.
     *
     * Empty comment lines are left empty,
     * lines consisting of a single space are replaced by `#`,
     * and all other lines are prefixed with a `#`.
     */
    const stringifyComment = str => str.replace(/^(?!$)(?: $)?/gm, '#');
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment)) return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    const lineComment = (str, indent, comment) =>
      str.endsWith('\n')
        ? indentComment(comment, indent)
        : comment.includes('\n')
          ? '\n' + indentComment(comment, indent)
          : (str.endsWith(' ') ? '' : ' ') + comment;

    exports.indentComment = indentComment;
    exports.lineComment = lineComment;
    exports.stringifyComment = stringifyComment;

    /***/
  },

  /***/ 3893: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const node_process = __webpack_require__(932);
    const cst = __webpack_require__(7062);
    const lexer = __webpack_require__(1322);

    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i) if (list[i].type === type) return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case 'space':
          case 'comment':
          case 'newline':
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case 'document':
          return parent.start;
        case 'block-map': {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case 'block-seq':
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    /** Note: May modify input array */
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0) return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case 'doc-start':
          case 'explicit-key-ind':
          case 'map-value-ind':
          case 'seq-item-ind':
          case 'newline':
            break loop;
        }
      }
      while (prev[++i]?.type === 'space') {
        /* loop */
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
          if (
            it.sep &&
            !it.value &&
            !includesToken(it.start, 'explicit-key-ind') &&
            !includesToken(it.sep, 'map-value-ind')
          ) {
            if (it.key) it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end) Array.prototype.push.apply(it.value.end, it.sep);
              else it.value.end = it.sep;
            } else Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    /**
     * A YAML concrete syntax tree (CST) parser
     *
     * ```ts
     * const src: string = ...
     * for (const token of new Parser().parse(src)) {
     *   // token: Token
     * }
     * ```
     *
     * To use the parser with a user-provided lexer:
     *
     * ```ts
     * function* parse(source: string, lexer: Lexer) {
     *   const parser = new Parser()
     *   for (const lexeme of lexer.lex(source))
     *     yield* parser.next(lexeme)
     *   yield* parser.end()
     * }
     *
     * const src: string = ...
     * const lexer = new Lexer()
     * for (const token of parse(src, lexer)) {
     *   // token: Token
     * }
     * ```
     */
    class Parser {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0) this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete)) yield* this.next(lexeme);
        if (!incomplete) yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS) console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: 'error', offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === 'scalar') {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = 'scalar';
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case 'newline':
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine) this.onNewLine(this.offset + source.length);
              break;
            case 'space':
              if (this.atNewLine && source[0] === ' ') this.indent += source.length;
              break;
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
              if (this.atNewLine) this.indent += source.length;
              break;
            case 'doc-mode':
            case 'flow-error-end':
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0) yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source,
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
          while (this.stack.length > 0) yield* this.pop();
          this.stack.push({
            type: 'doc-end',
            offset: this.offset,
            source: this.source,
          });
          return;
        }
        if (!top) return yield* this.stream();
        switch (top.type) {
          case 'document':
            return yield* this.document(top);
          case 'alias':
          case 'scalar':
          case 'single-quoted-scalar':
          case 'double-quoted-scalar':
            return yield* this.scalar(top);
          case 'block-scalar':
            return yield* this.blockScalar(top);
          case 'block-map':
            return yield* this.blockMap(top);
          case 'block-seq':
            return yield* this.blockSequence(top);
          case 'flow-collection':
            return yield* this.flowCollection(top);
          case 'doc-end':
            return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
          const message = 'Tried to pop an empty stack';
          yield { type: 'error', offset: this.offset, source: '', message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === 'block-scalar') {
            // Block scalars use their parent rather than header indent
            token.indent = 'indent' in top ? top.indent : 0;
          } else if (token.type === 'flow-collection' && top.type === 'document') {
            // Ignore all indent for top-level flow collections
            token.indent = 0;
          }
          if (token.type === 'flow-collection') fixFlowSeqItems(token);
          switch (top.type) {
            case 'document':
              top.value = token;
              break;
            case 'block-scalar':
              top.props.push(token); // error
              break;
            case 'block-map': {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case 'block-seq': {
              const it = top.items[top.items.length - 1];
              if (it.value) top.items.push({ start: [], value: token });
              else it.value = token;
              break;
            }
            case 'flow-collection': {
              const it = top.items[top.items.length - 1];
              if (!it || it.value) top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep) it.value = token;
              else Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if (
            (top.type === 'document' || top.type === 'block-map' || top.type === 'block-seq') &&
            (token.type === 'block-map' || token.type === 'block-seq')
          ) {
            const last = token.items[token.items.length - 1];
            if (
              last &&
              !last.sep &&
              !last.value &&
              last.start.length > 0 &&
              findNonEmptyIndex(last.start) === -1 &&
              (token.indent === 0 || last.start.every(st => st.type !== 'comment' || st.indent < token.indent))
            ) {
              if (top.type === 'document') top.end = last.start;
              else top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case 'directive-line':
            yield { type: 'directive', offset: this.offset, source: this.source };
            return;
          case 'byte-order-mark':
          case 'space':
          case 'comment':
          case 'newline':
            yield this.sourceToken;
            return;
          case 'doc-mode':
          case 'doc-start': {
            const doc = {
              type: 'document',
              offset: this.offset,
              start: [],
            };
            if (this.type === 'doc-start') doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: 'error',
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source,
        };
      }
      *document(doc) {
        if (doc.value) return yield* this.lineEnd(doc);
        switch (this.type) {
          case 'doc-start': {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else doc.start.push(this.sourceToken);
            return;
          }
          case 'anchor':
          case 'tag':
          case 'space':
          case 'comment':
          case 'newline':
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv) this.stack.push(bv);
        else {
          yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source,
          };
        }
      }
      *scalar(scalar) {
        if (this.type === 'map-value-ind') {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else sep = [this.sourceToken];
          const map = {
            type: 'block-map',
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }],
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case 'space':
          case 'comment':
          case 'newline':
            scalar.props.push(this.sourceToken);
            return;
          case 'scalar':
            scalar.source = this.source;
            // block-scalar source includes trailing newline
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf('\n') + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
          case 'newline':
            this.onKeyLine = false;
            if (it.value) {
              const end = 'end' in it.value ? it.value.end : undefined;
              const last = Array.isArray(end) ? end[end.length - 1] : undefined;
              if (last?.type === 'comment') end?.push(this.sourceToken);
              else map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case 'space':
          case 'comment':
            if (it.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== 'seq-item-ind';
          // For empty nodes, assign newline-separated not indented empty tokens to following node
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case 'newline':
                  nl.push(i);
                  break;
                case 'space':
                  break;
                case 'comment':
                  if (st.indent > map.indent) nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2) start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case 'anchor':
            case 'tag':
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case 'explicit-key-ind':
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: 'block-map',
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }],
                });
              }
              this.onKeyLine = true;
              return;
            case 'map-value-ind':
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, 'newline')) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: 'block-map',
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start, key: null, sep: [this.sourceToken] }],
                    });
                  }
                } else if (it.value) {
                  map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, 'map-value-ind')) {
                  this.stack.push({
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }],
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, 'newline')) {
                  const start = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  // @ts-expect-error type guard is wrong here
                  delete it.key;
                  // @ts-expect-error type guard is wrong here
                  delete it.sep;
                  this.stack.push({
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key, sep }],
                  });
                } else if (start.length > 0) {
                  // Not actually at next item
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else if (!it.sep) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else if (it.value || atNextItem) {
                map.items.push({ start, key: null, sep: [this.sourceToken] });
              } else if (includesToken(it.sep, 'map-value-ind')) {
                this.stack.push({
                  type: 'block-map',
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [], key: null, sep: [this.sourceToken] }],
                });
              } else {
                it.sep.push(this.sourceToken);
              }
              this.onKeyLine = true;
              return;
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar': {
              const fs = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start, key: fs, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs);
              } else {
                Object.assign(it, { key: fs, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (bv.type === 'block-seq') {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, 'newline')) {
                    yield* this.pop({
                      type: 'error',
                      offset: this.offset,
                      message: 'Unexpected block-seq-ind on same line with key',
                      source: this.source,
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case 'newline':
            if (it.value) {
              const end = 'end' in it.value ? it.value.end : undefined;
              const last = Array.isArray(end) ? end[end.length - 1] : undefined;
              if (last?.type === 'comment') end?.push(this.sourceToken);
              else seq.items.push({ start: [this.sourceToken] });
            } else it.start.push(this.sourceToken);
            return;
          case 'space':
          case 'comment':
            if (it.value) seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case 'anchor':
          case 'tag':
            if (it.value || this.indent <= seq.indent) break;
            it.start.push(this.sourceToken);
            return;
          case 'seq-item-ind':
            if (this.indent !== seq.indent) break;
            if (it.value || includesToken(it.start, 'seq-item-ind')) seq.items.push({ start: [this.sourceToken] });
            else it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === 'flow-collection');
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case 'comma':
            case 'explicit-key-ind':
              if (!it || it.sep) fc.items.push({ start: [this.sourceToken] });
              else it.start.push(this.sourceToken);
              return;
            case 'map-value-ind':
              if (!it || it.value) fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep) it.sep.push(this.sourceToken);
              else Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case 'space':
            case 'comment':
            case 'newline':
            case 'anchor':
            case 'tag':
              if (!it || it.value) fc.items.push({ start: [this.sourceToken] });
              else if (it.sep) it.sep.push(this.sourceToken);
              else it.start.push(this.sourceToken);
              return;
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar': {
              const fs = this.flowScalar(this.type);
              if (!it || it.value) fc.items.push({ start: [], key: fs, sep: [] });
              else if (it.sep) this.stack.push(fs);
              else Object.assign(it, { key: fs, sep: [] });
              return;
            }
            case 'flow-map-end':
            case 'flow-seq-end':
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          /* istanbul ignore else should not happen */
          if (bv) this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (
            parent.type === 'block-map' &&
            ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
              (this.type === 'newline' && !parent.items[parent.items.length - 1].sep))
          ) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === 'map-value-ind' && parent.type !== 'flow-collection') {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map = {
              type: 'block-map',
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }],
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf('\n') + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf('\n', nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source,
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case 'alias':
          case 'scalar':
          case 'single-quoted-scalar':
          case 'double-quoted-scalar':
            return this.flowScalar(this.type);
          case 'block-scalar-header':
            return {
              type: 'block-scalar',
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: '',
            };
          case 'flow-map-start':
          case 'flow-seq-start':
            return {
              type: 'flow-collection',
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: [],
            };
          case 'seq-item-ind':
            return {
              type: 'block-seq',
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }],
            };
          case 'explicit-key-ind': {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: 'block-map',
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }],
            };
          }
          case 'map-value-ind': {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: 'block-map',
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }],
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== 'comment') return false;
        if (this.indent <= indent) return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
      }
      *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
          if (docEnd.end) docEnd.end.push(this.sourceToken);
          else docEnd.end = [this.sourceToken];
          if (this.type === 'newline') yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case 'comma':
          case 'doc-start':
          case 'doc-end':
          case 'flow-seq-end':
          case 'flow-map-end':
          case 'map-value-ind':
            yield* this.pop();
            yield* this.step();
            break;
          case 'newline':
            this.onKeyLine = false;
          // fallthrough
          case 'space':
          case 'comment':
          default:
            // all other values are errors
            if (token.end) token.end.push(this.sourceToken);
            else token.end = [this.sourceToken];
            if (this.type === 'newline') yield* this.pop();
        }
      }
    }

    exports.Parser = Parser;

    /***/
  },

  /***/ 4045: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const node_process = __webpack_require__(932);
    const directives = __webpack_require__(7923);
    const Document = __webpack_require__(7404);
    const errors = __webpack_require__(6101);
    const identity = __webpack_require__(7182);
    const composeDoc = __webpack_require__(4948);
    const resolveEnd = __webpack_require__(191);

    function getErrorPos(src) {
      if (typeof src === 'number') return [src, src + 1];
      if (Array.isArray(src)) return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === 'string' ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = '';
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case '#':
            comment += (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') + (source.substring(1) || ' ');
            atComment = true;
            afterEmptyLine = false;
            break;
          case '%':
            if (prelude[i + 1]?.[0] !== '#') i += 1;
            atComment = false;
            break;
          default:
            // This may be wrong after doc-end, but in that case it doesn't matter
            if (!atComment) afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    /**
     * Compose a stream of CST nodes into a stream of YAML Documents.
     *
     * ```ts
     * import { Composer, Parser } from 'yaml'
     *
     * const src: string = ...
     * const tokens = new Parser().parse(src)
     * const docs = new Composer().compose(tokens)
     * ```
     */
    class Composer {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning) this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new directives.Directives({ version: options.version || '1.2' });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it)) it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}\n${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings,
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens) yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM) console.dir(token, { depth: null });
        switch (token.type) {
          case 'directive':
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, 'BAD_DIRECTIVE', message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case 'document': {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
            this.decorate(doc, false);
            if (this.doc) yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case 'byte-order-mark':
          case 'space':
            break;
          case 'comment':
          case 'newline':
            this.prelude.push(token.source);
            break;
          case 'error': {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
            if (this.atDirectives || !this.doc) this.errors.push(error);
            else this.doc.errors.push(error);
            break;
          }
          case 'doc-end': {
            if (!this.doc) {
              const msg = 'Unexpected doc-end without preceding document';
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(
              token.end,
              token.offset + token.source.length,
              this.doc.options.strict,
              this.onError,
            );
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(
              new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`),
            );
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(undefined, opts);
          if (this.atDirectives) this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    }

    exports.Composer = Composer;

    /***/
  },

  /***/ 4058: /***/ (__unused_webpack_module, exports) => {
    /*!
     * cookie
     * Copyright(c) 2012-2014 Roman Shtylman
     * Copyright(c) 2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module exports.
     * @public
     */

    exports.parse = parse;
    exports.serialize = serialize;

    /**
     * Module variables.
     * @private
     */

    const __toString = Object.prototype.toString;
    const __hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * RegExp to match cookie-name in RFC 6265 sec 4.1.1
     * This refers out to the obsoleted definition of token in RFC 2616 sec 2.2
     * which has been replaced by the token definition in RFC 7230 appendix B.
     *
     * cookie-name       = token
     * token             = 1*tchar
     * tchar             = "!" / "#" / "$" / "%" / "&" / "'" /
     *                     "*" / "+" / "-" / "." / "^" / "_" /
     *                     "`" / "|" / "~" / DIGIT / ALPHA
     */

    const cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

    /**
     * RegExp to match cookie-value in RFC 6265 sec 4.1.1
     *
     * cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE )
     * cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E
     *                     ; US-ASCII characters excluding CTLs,
     *                     ; whitespace DQUOTE, comma, semicolon,
     *                     ; and backslash
     */

    const cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/;

    /**
     * RegExp to match domain-value in RFC 6265 sec 4.1.1
     *
     * domain-value      = <subdomain>
     *                     ; defined in [RFC1034], Section 3.5, as
     *                     ; enhanced by [RFC1123], Section 2.1
     * <subdomain>       = <label> | <subdomain> "." <label>
     * <label>           = <let-dig> [ [ <ldh-str> ] <let-dig> ]
     *                     Labels must be 63 characters or less.
     *                     'let-dig' not 'letter' in the first char, per RFC1123
     * <ldh-str>         = <let-dig-hyp> | <let-dig-hyp> <ldh-str>
     * <let-dig-hyp>     = <let-dig> | "-"
     * <let-dig>         = <letter> | <digit>
     * <letter>          = any one of the 52 alphabetic characters A through Z in
     *                     upper case and a through z in lower case
     * <digit>           = any one of the ten digits 0 through 9
     *
     * Keep support for leading dot: https://github.com/jshttp/cookie/issues/173
     *
     * > (Note that a leading %x2E ("."), if present, is ignored even though that
     * character is not permitted, but a trailing %x2E ("."), if present, will
     * cause the user agent to ignore the attribute.)
     */

    const domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;

    /**
     * RegExp to match path-value in RFC 6265 sec 4.1.1
     *
     * path-value        = <any CHAR except CTLs or ";">
     * CHAR              = %x01-7F
     *                     ; defined in RFC 5234 appendix B.1
     */

    const pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;

    /**
     * Parse a cookie header.
     *
     * Parse the given cookie header string into an object
     * The object has the various cookies as keys(names) => values
     *
     * @param {string} str
     * @param {object} [opt]
     * @return {object}
     * @public
     */

    function parse(str, opt) {
      if (typeof str !== 'string') {
        throw new TypeError('argument str must be a string');
      }

      const obj = {};
      const len = str.length;
      // RFC 6265 sec 4.1.1, RFC 2616 2.2 defines a cookie name consists of one char minimum, plus '='.
      if (len < 2) return obj;

      const dec = (opt && opt.decode) || decode;
      let index = 0;
      let eqIdx = 0;
      let endIdx = 0;

      do {
        eqIdx = str.indexOf('=', index);
        if (eqIdx === -1) break; // No more cookie pairs.

        endIdx = str.indexOf(';', index);

        if (endIdx === -1) {
          endIdx = len;
        } else if (eqIdx > endIdx) {
          // backtrack on prior semicolon
          index = str.lastIndexOf(';', eqIdx - 1) + 1;
          continue;
        }

        const keyStartIdx = startIndex(str, index, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key = str.slice(keyStartIdx, keyEndIdx);

        // only assign once
        if (!__hasOwnProperty.call(obj, key)) {
          let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
          let valEndIdx = endIndex(str, endIdx, valStartIdx);

          if (str.charCodeAt(valStartIdx) === 0x22 /* " */ && str.charCodeAt(valEndIdx - 1) === 0x22 /* " */) {
            valStartIdx++;
            valEndIdx--;
          }

          const val = str.slice(valStartIdx, valEndIdx);
          obj[key] = tryDecode(val, dec);
        }

        index = endIdx + 1;
      } while (index < len);

      return obj;
    }

    function startIndex(str, index, max) {
      do {
        const code = str.charCodeAt(index);
        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index;
      } while (++index < max);
      return max;
    }

    function endIndex(str, index, min) {
      while (index > min) {
        const code = str.charCodeAt(--index);
        if (code !== 0x20 /*   */ && code !== 0x09 /* \t */) return index + 1;
      }
      return min;
    }

    /**
     * Serialize data into a cookie header.
     *
     * Serialize a name value pair into a cookie string suitable for
     * http headers. An optional options object specifies cookie parameters.
     *
     * serialize('foo', 'bar', { httpOnly: true })
     *   => "foo=bar; httpOnly"
     *
     * @param {string} name
     * @param {string} val
     * @param {object} [opt]
     * @return {string}
     * @public
     */

    function serialize(name, val, opt) {
      const enc = (opt && opt.encode) || encodeURIComponent;

      if (typeof enc !== 'function') {
        throw new TypeError('option encode is invalid');
      }

      if (!cookieNameRegExp.test(name)) {
        throw new TypeError('argument name is invalid');
      }

      const value = enc(val);

      if (!cookieValueRegExp.test(value)) {
        throw new TypeError('argument val is invalid');
      }

      let str = name + '=' + value;
      if (!opt) return str;

      if (opt.maxAge != null) {
        const maxAge = Math.floor(opt.maxAge);

        if (!isFinite(maxAge)) {
          throw new TypeError('option maxAge is invalid');
        }

        str += '; Max-Age=' + maxAge;
      }

      if (opt.domain) {
        if (!domainValueRegExp.test(opt.domain)) {
          throw new TypeError('option domain is invalid');
        }

        str += '; Domain=' + opt.domain;
      }

      if (opt.path) {
        if (!pathValueRegExp.test(opt.path)) {
          throw new TypeError('option path is invalid');
        }

        str += '; Path=' + opt.path;
      }

      if (opt.expires) {
        const expires = opt.expires;

        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError('option expires is invalid');
        }

        str += '; Expires=' + expires.toUTCString();
      }

      if (opt.httpOnly) {
        str += '; HttpOnly';
      }

      if (opt.secure) {
        str += '; Secure';
      }

      if (opt.partitioned) {
        str += '; Partitioned';
      }

      if (opt.priority) {
        const priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;

        switch (priority) {
          case 'low':
            str += '; Priority=Low';
            break;
          case 'medium':
            str += '; Priority=Medium';
            break;
          case 'high':
            str += '; Priority=High';
            break;
          default:
            throw new TypeError('option priority is invalid');
        }
      }

      if (opt.sameSite) {
        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;

        switch (sameSite) {
          case true:
            str += '; SameSite=Strict';
            break;
          case 'lax':
            str += '; SameSite=Lax';
            break;
          case 'strict':
            str += '; SameSite=Strict';
            break;
          case 'none':
            str += '; SameSite=None';
            break;
          default:
            throw new TypeError('option sameSite is invalid');
        }
      }

      return str;
    }

    /**
     * URL-decode string value. Optimized to skip native call when no %.
     *
     * @param {string} str
     * @returns {string}
     */

    function decode(str) {
      return str.indexOf('%') !== -1 ? decodeURIComponent(str) : str;
    }

    /**
     * Determine if value is a Date.
     *
     * @param {*} val
     * @private
     */

    function isDate(val) {
      return __toString.call(val) === '[object Date]';
    }

    /**
     * Try decoding a string using a decoding function.
     *
     * @param {string} str
     * @param {function} decode
     * @private
     */

    function tryDecode(str, decode) {
      try {
        return decode(str);
      } catch (e) {
        return str;
      }
    }

    /***/
  },

  /***/ 4059: /***/ module => {
    /*
object-assign
(c) Sindre Sorhus
@license MIT
*/

    /* eslint-disable no-unused-vars */
    const getOwnPropertySymbols = Object.getOwnPropertySymbols;
    const hasOwnProperty = Object.prototype.hasOwnProperty;
    const propIsEnumerable = Object.prototype.propertyIsEnumerable;

    function toObject(val) {
      if (val === null || val === undefined) {
        throw new TypeError('Object.assign cannot be called with null or undefined');
      }

      return Object(val);
    }

    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }

        // Detect buggy property enumeration order in older V8 versions.

        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
        const test1 = new String('abc');
        test1[5] = 'de';
        if (Object.getOwnPropertyNames(test1)[0] === '5') {
          return false;
        }

        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        const test2 = {};
        for (let i = 0; i < 10; i++) {
          test2['_' + String.fromCharCode(i)] = i;
        }
        const order2 = Object.getOwnPropertyNames(test2).map(function (n) {
          return test2[n];
        });
        if (order2.join('') !== '0123456789') {
          return false;
        }

        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
        const test3 = {};
        'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
          return false;
        }

        return true;
      } catch (err) {
        // We don't expect any of the above to throw, but better to be safe.
        return false;
      }
    }

    module.exports = shouldUseNative()
      ? Object.assign
      : function (target, source) {
          let from;
          const to = toObject(target);
          let symbols;

          for (let s = 1; s < arguments.length; s++) {
            from = Object(arguments[s]);

            for (const key in from) {
              if (hasOwnProperty.call(from, key)) {
                to[key] = from[key];
              }
            }

            if (getOwnPropertySymbols) {
              symbols = getOwnPropertySymbols(from);
              for (let i = 0; i < symbols.length; i++) {
                if (propIsEnumerable.call(from, symbols[i])) {
                  to[symbols[i]] = from[symbols[i]];
                }
              }
            }
          }

          return to;
        };

    /***/
  },

  /***/ 4078: /***/ (__unused_webpack_module, exports) => {
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case 'space':
            case 'comment':
            case 'newline':
              offset -= st.source.length;
              continue;
          }
          // Technically, an empty scalar is immediately after the last non-empty
          // node, but it's more useful to place it after any whitespace.
          st = before[++i];
          while (st?.type === 'space') {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }

    exports.emptyScalarPosition = emptyScalarPosition;

    /***/
  },

  /***/ 4176: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const applyReviver = __webpack_require__(5996);
    const identity = __webpack_require__(7182);
    const toJS = __webpack_require__(9126);

    class NodeBase {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc)) throw new TypeError('A document argument is required');
        const ctx = {
          anchors: new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,
        };
        const res = toJS.toJS(this, '', ctx);
        if (typeof onAnchor === 'function') for (const { count, res } of ctx.anchors.values()) onAnchor(res, count);
        return typeof reviver === 'function' ? applyReviver.applyReviver(reviver, { '': res }, '', res) : res;
      }
    }

    exports.NodeBase = NodeBase;

    /***/
  },

  /***/ 4200: /***/ (module, exports, __webpack_require__) => {
    /**
     * Module dependencies.
     */

    const tty = __webpack_require__(2018);
    const util = __webpack_require__(9023);

    /**
     * This is the Node.js implementation of `debug()`.
     */

    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(
      () => {},
      'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
    );

    /**
     * Colors.
     */

    exports.colors = [6, 2, 3, 4, 5, 1];

    try {
      // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
      // eslint-disable-next-line import/no-extraneous-dependencies
      const supportsColor = __webpack_require__(9478);

      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80,
          81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169,
          170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
          214, 215, 220, 221,
        ];
      }
    } catch (error) {
      // Swallow - we only care if `supports-color` is available; it doesn't have to be.
    }

    /**
     * Build up the default `inspectOpts` object from the environment variables.
     *
     *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
     */

    exports.inspectOpts = Object.keys(process.env)
      .filter(key => {
        return /^debug_/i.test(key);
      })
      .reduce((obj, key) => {
        // Camel-case
        const prop = key
          .substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (_, k) => {
            return k.toUpperCase();
          });

        // Coerce string value into JS value
        let val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === 'null') {
          val = null;
        } else {
          val = Number(val);
        }

        obj[prop] = val;
        return obj;
      }, {});

    /**
     * Is stdout a TTY? Colored output is enabled when `true`.
     */

    function useColors() {
      return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }

    /**
     * Adds ANSI color escape codes if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      const { namespace: name, useColors } = this;

      if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;

        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
      } else {
        args[0] = getDate() + name + ' ' + args[0];
      }
    }

    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return '';
      }
      return new Date().toISOString() + ' ';
    }

    /**
     * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
     */

    function log(...args) {
      return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
      }
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      return process.env.DEBUG;
    }

    /**
     * Init logic for `debug` instances.
     *
     * Create a new `inspectOpts` object in case `useColors` is set
     * differently for a particular `debug` instance.
     */

    function init(debug) {
      debug.inspectOpts = {};

      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }

    module.exports = __webpack_require__(7709)(exports);

    const { formatters } = module.exports;

    /**
     * Map %o to `util.inspect()`, all on a single line.
     */

    formatters.o = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util
        .inspect(v, this.inspectOpts)
        .split('\n')
        .map(str => str.trim())
        .join(' ');
    };

    /**
     * Map %O to `util.inspect()`, allowing multiple lines if needed.
     */

    formatters.O = function (v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };

    /***/
  },

  /***/ 4229: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const zlib = __webpack_require__(3106);

    const bufferUtil = __webpack_require__(8732);
    const Limiter = __webpack_require__(8773);
    const { kStatusCode } = __webpack_require__(8936);

    const FastBuffer = Buffer[Symbol.species];
    const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
    const kPerMessageDeflate = Symbol('permessage-deflate');
    const kTotalLength = Symbol('total-length');
    const kCallback = Symbol('callback');
    const kBuffers = Symbol('buffers');
    const kError = Symbol('error');

    //
    // We limit zlib concurrency, which prevents severe memory fragmentation
    // as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
    // and https://github.com/websockets/ws/issues/1202
    //
    // Intentionally global; it's the global thread pool that's an issue.
    //
    let zlibLimiter;

    /**
     * permessage-deflate implementation.
     */
    class PerMessageDeflate {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;

        this.params = null;

        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }

      /**
       * @type {String}
       */
      static get extensionName() {
        return 'permessage-deflate';
      }

      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};

        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }

        return params;
      }

      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);

        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);

        return this.params;
      }

      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }

        if (this._deflate) {
          const callback = this._deflate[kCallback];

          this._deflate.close();
          this._deflate = null;

          if (callback) {
            callback(new Error('The deflate stream was closed while data was being processed'));
          }
        }
      }

      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find(params => {
          if (
            (opts.serverNoContextTakeover === false && params.server_no_context_takeover) ||
            (params.server_max_window_bits &&
              (opts.serverMaxWindowBits === false ||
                (typeof opts.serverMaxWindowBits === 'number' &&
                  opts.serverMaxWindowBits > params.server_max_window_bits))) ||
            (typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits)
          ) {
            return false;
          }

          return true;
        });

        if (!accepted) {
          throw new Error('None of the extension offers can be accepted');
        }

        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === 'number') {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === 'number') {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }

        return accepted;
      }

      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];

        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }

        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === 'number') {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (
          this._options.clientMaxWindowBits === false ||
          (typeof this._options.clientMaxWindowBits === 'number' &&
            params.client_max_window_bits > this._options.clientMaxWindowBits)
        ) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }

        return params;
      }

      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach(params => {
          Object.keys(params).forEach(key => {
            let value = params[key];

            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }

            value = value[0];

            if (key === 'client_max_window_bits') {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === 'server_max_window_bits') {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }

            params[key] = value;
          });
        });

        return configurations;
      }

      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add(done => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }

      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add(done => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }

      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? 'client' : 'server';

        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];

          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits,
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on('error', inflateOnError);
          this._inflate.on('data', inflateOnData);
        }

        this._inflate[kCallback] = callback;

        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);

        this._inflate.flush(() => {
          const err = this._inflate[kError];

          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }

          const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);

          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];

            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }

          callback(null, data);
        });
      }

      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? 'server' : 'client';

        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];

          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits,
          });

          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];

          this._deflate.on('data', deflateOnData);
        }

        this._deflate[kCallback] = callback;

        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            //
            // The deflate stream was closed while data was being processed.
            //
            return;
          }

          let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);

          if (fin) {
            data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
          }

          //
          // Ensure that the callback will not be called again in
          // `PerMessageDeflate#cleanup()`.
          //
          this._deflate[kCallback] = null;

          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];

          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }

          callback(null, data);
        });
      }
    }

    module.exports = PerMessageDeflate;

    /**
     * The listener of the `zlib.DeflateRaw` stream `'data'` event.
     *
     * @param {Buffer} chunk A chunk of data
     * @private
     */
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }

    /**
     * The listener of the `zlib.InflateRaw` stream `'data'` event.
     *
     * @param {Buffer} chunk A chunk of data
     * @private
     */
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;

      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }

      this[kError] = new RangeError('Max payload size exceeded');
      this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
      this[kError][kStatusCode] = 1009;
      this.removeListener('data', inflateOnData);
      this.reset();
    }

    /**
     * The listener of the `zlib.InflateRaw` stream `'error'` event.
     *
     * @param {Error} err The emitted error
     * @private
     */
    function inflateOnError(err) {
      //
      // There is no need to call `Zlib#close()` as the handle is automatically
      // closed when an error is emitted.
      //
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }

    /***/
  },

  /***/ 4240: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    /* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */

    const EventEmitter = __webpack_require__(4434);
    const http = __webpack_require__(8611);
    const { Duplex } = __webpack_require__(2203);
    const { createHash } = __webpack_require__(6982);

    const extension = __webpack_require__(5824);
    const PerMessageDeflate = __webpack_require__(4229);
    const subprotocol = __webpack_require__(5651);
    const WebSocket = __webpack_require__(7926);
    const { GUID, kWebSocket } = __webpack_require__(8936);

    const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

    const RUNNING = 0;
    const CLOSING = 1;
    const CLOSED = 2;

    /**
     * Class representing a WebSocket server.
     *
     * @extends EventEmitter
     */
    class WebSocketServer extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();

        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null, // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket,
          ...options,
        };

        if (
          (options.port == null && !options.server && !options.noServer) ||
          (options.port != null && (options.server || options.noServer)) ||
          (options.server && options.noServer)
        ) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + 'must be specified');
        }

        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];

            res.writeHead(426, {
              'Content-Length': body.length,
              'Content-Type': 'text/plain',
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }

        if (this._server) {
          const emitConnection = this.emit.bind(this, 'connection');

          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, 'listening'),
            error: this.emit.bind(this, 'error'),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            },
          });
        }

        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = new Set();
          this._shouldEmitClose = false;
        }

        this.options = options;
        this._state = RUNNING;
      }

      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }

        if (!this._server) return null;
        return this._server.address();
      }

      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once('close', () => {
              cb(new Error('The server is not running'));
            });
          }

          process.nextTick(emitClose, this);
          return;
        }

        if (cb) this.once('close', cb);

        if (this._state === CLOSING) return;
        this._state = CLOSING;

        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }

          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;

          this._removeListeners();
          this._removeListeners = this._server = null;

          //
          // The HTTP/S server was created internally. Close it, and rely on its
          // `'close'` event.
          //
          server.close(() => {
            emitClose(this);
          });
        }
      }

      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf('?');
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

          if (pathname !== this.options.path) return false;
        }

        return true;
      }

      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on('error', socketOnError);

        const key = req.headers['sec-websocket-key'];
        const upgrade = req.headers.upgrade;
        const version = +req.headers['sec-websocket-version'];

        if (req.method !== 'GET') {
          const message = 'Invalid HTTP method';
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }

        if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
          const message = 'Invalid Upgrade header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }

        if (key === undefined || !keyRegex.test(key)) {
          const message = 'Missing or invalid Sec-WebSocket-Key header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }

        if (version !== 8 && version !== 13) {
          const message = 'Missing or invalid Sec-WebSocket-Version header';
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }

        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }

        const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
        let protocols = new Set();

        if (secWebSocketProtocol !== undefined) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = 'Invalid Sec-WebSocket-Protocol header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }

        const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
        const extensions = {};

        if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload,
          );

          try {
            const offers = extension.parse(secWebSocketExtensions);

            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = 'Invalid or unacceptable Sec-WebSocket-Extensions header';
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }

        //
        // Optionally call external client verification handler.
        //
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req,
          };

          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }

              this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            });
            return;
          }

          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }

        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }

      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        //
        // Destroy the socket if the client has already sent a FIN packet.
        //
        if (!socket.readable || !socket.writable) return socket.destroy();

        if (socket[kWebSocket]) {
          throw new Error(
            'server.handleUpgrade() was called more than once with the same ' +
              'socket, possibly due to a misconfiguration',
          );
        }

        if (this._state > RUNNING) return abortHandshake(socket, 503);

        const digest = createHash('sha1')
          .update(key + GUID)
          .digest('base64');

        const headers = [
          'HTTP/1.1 101 Switching Protocols',
          'Upgrade: websocket',
          'Connection: Upgrade',
          `Sec-WebSocket-Accept: ${digest}`,
        ];

        const ws = new this.options.WebSocket(null, undefined, this.options);

        if (protocols.size) {
          //
          // Optionally call external protocol selection handler.
          //
          const protocol = this.options.handleProtocols
            ? this.options.handleProtocols(protocols, req)
            : protocols.values().next().value;

          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }

        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params],
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }

        //
        // Allow external modification/inspection of handshake headers.
        //
        this.emit('headers', headers, req);

        socket.write(headers.concat('\r\n').join('\r\n'));
        socket.removeListener('error', socketOnError);

        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation,
        });

        if (this.clients) {
          this.clients.add(ws);
          ws.on('close', () => {
            this.clients.delete(ws);

            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }

        cb(ws, req);
      }
    }

    module.exports = WebSocketServer;

    /**
     * Add event listeners on an `EventEmitter` using a map of <event, listener>
     * pairs.
     *
     * @param {EventEmitter} server The event emitter
     * @param {Object.<String, Function>} map The listeners to add
     * @return {Function} A function that will remove the added listeners when
     *     called
     * @private
     */
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);

      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }

    /**
     * Emit a `'close'` event on an `EventEmitter`.
     *
     * @param {EventEmitter} server The event emitter
     * @private
     */
    function emitClose(server) {
      server._state = CLOSED;
      server.emit('close');
    }

    /**
     * Handle socket errors.
     *
     * @private
     */
    function socketOnError() {
      this.destroy();
    }

    /**
     * Close the connection when preconditions are not fulfilled.
     *
     * @param {Duplex} socket The socket of the upgrade request
     * @param {Number} code The HTTP response status code
     * @param {String} [message] The HTTP response body
     * @param {Object} [headers] Additional HTTP response headers
     * @private
     */
    function abortHandshake(socket, code, message, headers) {
      //
      // The socket is writable unless the user destroyed or ended it before calling
      // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
      // error. Handling this does not make much sense as the worst that can happen
      // is that some of the data written by the user might be discarded due to the
      // call to `socket.end()` below, which triggers an `'error'` event that in
      // turn causes the socket to be destroyed.
      //
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: 'close',
        'Content-Type': 'text/html',
        'Content-Length': Buffer.byteLength(message),
        ...headers,
      };

      socket.once('finish', socket.destroy);

      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
          Object.keys(headers)
            .map(h => `${h}: ${headers[h]}`)
            .join('\r\n') +
          '\r\n\r\n' +
          message,
      );
    }

    /**
     * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
     * one listener for it, otherwise call `abortHandshake()`.
     *
     * @param {WebSocketServer} server The WebSocket server
     * @param {http.IncomingMessage} req The request object
     * @param {Duplex} socket The socket of the upgrade request
     * @param {Number} code The HTTP response status code
     * @param {String} message The HTTP response body
     * @private
     */
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount('wsClientError')) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

        server.emit('wsClientError', err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }

    /***/
  },

  /***/ 4304: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const identity = __webpack_require__(7182);
    const YAMLMap = __webpack_require__(8741);

    const map = {
      collection: 'map',
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: 'tag:yaml.org,2002:map',
      resolve(map, onError) {
        if (!identity.isMap(map)) onError('Expected a mapping for this tag');
        return map;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx),
    };

    exports.map = map;

    /***/
  },

  /***/ 4321: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const fs = __webpack_require__(9896);
    const path = __webpack_require__(6928);
    const os = __webpack_require__(857);

    // Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'
    var runtimeRequire = true ? __WEBPACK_EXTERNAL_createRequire(import.meta.url) : 0; // eslint-disable-line

    const vars = (process.config && process.config.variables) || {};
    const prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    const abi = process.versions.modules; // TODO: support old node where this is undef
    const runtime = isElectron() ? 'electron' : isNwjs() ? 'node-webkit' : 'node';

    const arch = process.env.npm_config_arch || os.arch();
    const platform = process.env.npm_config_platform || os.platform();
    const libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc');
    const armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || '';
    const uv = (process.versions.uv || '').split('.')[0];

    module.exports = load;

    function load(dir) {
      return runtimeRequire(load.resolve(dir));
    }

    load.resolve = load.path = function (dir) {
      dir = path.resolve(dir || '.');

      try {
        const name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
        if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
      } catch (err) {}

      if (!prebuildsOnly) {
        const release = getFirst(path.join(dir, 'build/Release'), matchBuild);
        if (release) return release;

        const debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
        if (debug) return debug;
      }

      const prebuild = resolve(dir);
      if (prebuild) return prebuild;

      const nearby = resolve(path.dirname(process.execPath));
      if (nearby) return nearby;

      const target = [
        'platform=' + platform,
        'arch=' + arch,
        'runtime=' + runtime,
        'abi=' + abi,
        'uv=' + uv,
        armv ? 'armv=' + armv : '',
        'libc=' + libc,
        'node=' + process.versions.node,
        process.versions.electron ? 'electron=' + process.versions.electron : '',
        true ? 'webpack=true' : 0, // eslint-disable-line
      ]
        .filter(Boolean)
        .join(' ');

      throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n');

      function resolve(dir) {
        // Find matching "prebuilds/<platform>-<arch>" directory
        const tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple);
        const tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple) return;

        // Find most specific flavor first
        const prebuilds = path.join(dir, 'prebuilds', tuple.name);
        const parsed = readdirSync(prebuilds).map(parseTags);
        const candidates = parsed.filter(matchTags(runtime, abi));
        const winner = candidates.sort(compareTags(runtime))[0];
        if (winner) return path.join(prebuilds, winner.file);
      }
    };

    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }

    function getFirst(dir, filter) {
      const files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }

    function matchBuild(name) {
      return /\.node$/.test(name);
    }

    function parseTuple(name) {
      // Example: darwin-x64+arm64
      const arr = name.split('-');
      if (arr.length !== 2) return;

      const platform = arr[0];
      const architectures = arr[1].split('+');

      if (!platform) return;
      if (!architectures.length) return;
      if (!architectures.every(Boolean)) return;

      return { name, platform, architectures };
    }

    function matchTuple(platform, arch) {
      return function (tuple) {
        if (tuple == null) return false;
        if (tuple.platform !== platform) return false;
        return tuple.architectures.includes(arch);
      };
    }

    function compareTuples(a, b) {
      // Prefer single-arch prebuilds over multi-arch
      return a.architectures.length - b.architectures.length;
    }

    function parseTags(file) {
      const arr = file.split('.');
      const extension = arr.pop();
      const tags = { file: file, specificity: 0 };

      if (extension !== 'node') return;

      for (let i = 0; i < arr.length; i++) {
        const tag = arr[i];

        if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
          tags.runtime = tag;
        } else if (tag === 'napi') {
          tags.napi = true;
        } else if (tag.slice(0, 3) === 'abi') {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === 'uv') {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === 'armv') {
          tags.armv = tag.slice(4);
        } else if (tag === 'glibc' || tag === 'musl') {
          tags.libc = tag;
        } else {
          continue;
        }

        tags.specificity++;
      }

      return tags;
    }

    function matchTags(runtime, abi) {
      return function (tags) {
        if (tags == null) return false;
        if (tags.runtime && tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
        if (tags.abi && tags.abi !== abi && !tags.napi) return false;
        if (tags.uv && tags.uv !== uv) return false;
        if (tags.armv && tags.armv !== armv) return false;
        if (tags.libc && tags.libc !== libc) return false;

        return true;
      };
    }

    function runtimeAgnostic(tags) {
      return tags.runtime === 'node' && tags.napi;
    }

    function compareTags(runtime) {
      // Precedence: non-agnostic runtime, abi over napi, then by specificity.
      return function (a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }

    function isNwjs() {
      return !!(process.versions && process.versions.nw);
    }

    function isElectron() {
      if (process.versions && process.versions.electron) return true;
      if (process.env.ELECTRON_RUN_AS_NODE) return true;
      return typeof window !== 'undefined' && window.process && window.process.type === 'renderer';
    }

    function isAlpine(platform) {
      return platform === 'linux' && fs.existsSync('/etc/alpine-release');
    }

    // Exposed for unit tests
    // TODO: move to lib
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;

    /***/
  },

  /***/ 4371: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const { kForOnEventAttribute, kListener } = __webpack_require__(8936);

    const kCode = Symbol('kCode');
    const kData = Symbol('kData');
    const kError = Symbol('kError');
    const kMessage = Symbol('kMessage');
    const kReason = Symbol('kReason');
    const kTarget = Symbol('kTarget');
    const kType = Symbol('kType');
    const kWasClean = Symbol('kWasClean');

    /**
     * Class representing an event.
     */
    class Event {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }

      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }

      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    }

    Object.defineProperty(Event.prototype, 'target', { enumerable: true });
    Object.defineProperty(Event.prototype, 'type', { enumerable: true });

    /**
     * Class representing a close event.
     *
     * @extends Event
     */
    class CloseEvent extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);

        this[kCode] = options.code === undefined ? 0 : options.code;
        this[kReason] = options.reason === undefined ? '' : options.reason;
        this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
      }

      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }

      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }

      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    }

    Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

    /**
     * Class representing an error event.
     *
     * @extends Event
     */
    class ErrorEvent extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);

        this[kError] = options.error === undefined ? null : options.error;
        this[kMessage] = options.message === undefined ? '' : options.message;
      }

      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }

      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    }

    Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

    /**
     * Class representing a message event.
     *
     * @extends Event
     */
    class MessageEvent extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);

        this[kData] = options.data === undefined ? null : options.data;
      }

      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    }

    Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

    /**
     * This provides methods for emulating the `EventTarget` interface. It's not
     * meant to be used directly.
     *
     * @mixin
     */
    const EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }

        let wrapper;

        if (type === 'message') {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent('message', {
              data: isBinary ? data : data.toString(),
            });

            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === 'close') {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent('close', {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent,
            });

            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === 'error') {
          wrapper = function onError(error) {
            const event = new ErrorEvent('error', {
              error,
              message: error.message,
            });

            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === 'open') {
          wrapper = function onOpen() {
            const event = new Event('open');

            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }

        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;

        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },

      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      },
    };

    module.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent,
    };

    /**
     * Call an event listener
     *
     * @param {(Function|Object)} listener The listener to call
     * @param {*} thisArg The value to use as `this`` when calling the listener
     * @param {Event} event The event to pass to the listener
     * @private
     */
    function callListener(listener, thisArg, event) {
      if (typeof listener === 'object' && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }

    /***/
  },

  /***/ 4401: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const stringifyString = __webpack_require__(9850);

    const string = {
      identify: value => typeof value === 'string',
      default: true,
      tag: 'tag:yaml.org,2002:str',
      resolve: str => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      },
    };

    exports.string = string;

    /***/
  },

  /***/ 4434: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('events');

    /***/
  },

  /***/ 4681: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const __dirname = __webpack_fileURLToPath__(import.meta.url + '/..').slice(0, -1);

    try {
      module.exports = __webpack_require__(5173)(__dirname);
    } catch (e) {
      module.exports = __webpack_require__(2822);
    }

    /***/
  },

  /***/ 4710: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const identity = __webpack_require__(7182);
    const Pair = __webpack_require__(6544);
    const Scalar = __webpack_require__(6364);
    const YAMLSeq = __webpack_require__(2016);

    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item)) continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1) onError('Each pair must have its own sequence indicator');
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore
                ? `${item.commentBefore}\n${pair.key.commentBefore}`
                : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}\n${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else onError('Expected a sequence for this tag');
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs = new YAMLSeq.YAMLSeq(schema);
      pairs.tag = 'tag:yaml.org,2002:pairs';
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === 'function') it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
            }
          } else {
            key = it;
          }
          pairs.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs;
    }
    const pairs = {
      collection: 'seq',
      default: false,
      tag: 'tag:yaml.org,2002:pairs',
      resolve: resolvePairs,
      createNode: createPairs,
    };

    exports.createPairs = createPairs;
    exports.pairs = pairs;
    exports.resolvePairs = resolvePairs;

    /***/
  },

  /***/ 4752: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const identity = __webpack_require__(7182);

    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false) return false;
      const isEqual =
        typeof uniqueKeys === 'function'
          ? uniqueKeys
          : (a, b) => a === b || (identity.isScalar(a) && identity.isScalar(b) && a.value === b.value);
      return items.some(pair => isEqual(pair.key, search));
    }

    exports.mapIncludes = mapIncludes;

    /***/
  },

  /***/ 4756: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('tls');

    /***/
  },

  /***/ 4795: /***/ module => {
    /*!
     * vary
     * Copyright(c) 2014-2017 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module exports.
     */

    module.exports = vary;
    module.exports.append = append;

    /**
     * RegExp to match field-name in RFC 7230 sec 3.2
     *
     * field-name    = token
     * token         = 1*tchar
     * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
     *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
     *               / DIGIT / ALPHA
     *               ; any VCHAR, except delimiters
     */

    const FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;

    /**
     * Append a field to a vary header.
     *
     * @param {String} header
     * @param {String|Array} field
     * @return {String}
     * @public
     */

    function append(header, field) {
      if (typeof header !== 'string') {
        throw new TypeError('header argument is required');
      }

      if (!field) {
        throw new TypeError('field argument is required');
      }

      // get fields array
      const fields = !Array.isArray(field) ? parse(String(field)) : field;

      // assert on invalid field names
      for (let j = 0; j < fields.length; j++) {
        if (!FIELD_NAME_REGEXP.test(fields[j])) {
          throw new TypeError('field argument contains an invalid header name');
        }
      }

      // existing, unspecified vary
      if (header === '*') {
        return header;
      }

      // enumerate current values
      let val = header;
      const vals = parse(header.toLowerCase());

      // unspecified vary
      if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
        return '*';
      }

      for (let i = 0; i < fields.length; i++) {
        const fld = fields[i].toLowerCase();

        // append value (case-preserving)
        if (vals.indexOf(fld) === -1) {
          vals.push(fld);
          val = val ? val + ', ' + fields[i] : fields[i];
        }
      }

      return val;
    }

    /**
     * Parse a vary header into an array.
     *
     * @param {String} header
     * @return {Array}
     * @private
     */

    function parse(header) {
      let end = 0;
      const list = [];
      let start = 0;

      // gather tokens
      for (let i = 0, len = header.length; i < len; i++) {
        switch (header.charCodeAt(i)) {
          case 0x20 /*   */:
            if (start === end) {
              start = end = i + 1;
            }
            break;
          case 0x2c /* , */:
            list.push(header.substring(start, end));
            start = end = i + 1;
            break;
          default:
            end = i + 1;
            break;
        }
      }

      // final token
      list.push(header.substring(start, end));

      return list;
    }

    /**
     * Mark that a request is varied on a header field.
     *
     * @param {Object} res
     * @param {String|Array} field
     * @public
     */

    function vary(res, field) {
      if (!res || !res.getHeader || !res.setHeader) {
        // quack quack
        throw new TypeError('res argument is required');
      }

      // get existing header
      let val = res.getHeader('Vary') || '';
      const header = Array.isArray(val) ? val.join(', ') : String(val);

      // set new header
      if ((val = append(header, field))) {
        res.setHeader('Vary', val);
      }
    }

    /***/
  },

  /***/ 4898: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Polling = void 0;
    const transport_1 = __webpack_require__(2879);
    const zlib_1 = __webpack_require__(3106);
    const accepts = __webpack_require__(9);
    const debug_1 = __webpack_require__(1106);
    const debug = (0, debug_1.default)('engine:polling');
    const compressionMethods = {
      gzip: zlib_1.createGzip,
      deflate: zlib_1.createDeflate,
    };
    class Polling extends transport_1.Transport {
      /**
       * HTTP polling constructor.
       */
      constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1000;
      }
      /**
       * Transport name
       */
      get name() {
        return 'polling';
      }
      /**
       * Overrides onRequest.
       *
       * @param req
       *
       * @private
       */
      onRequest(req) {
        const res = req.res;
        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)
        req.res = null;
        if (req.getMethod() === 'get') {
          this.onPollRequest(req, res);
        } else if (req.getMethod() === 'post') {
          this.onDataRequest(req, res);
        } else {
          res.writeStatus('500 Internal Server Error');
          res.end();
        }
      }
      /**
       * The client sends a request awaiting for us to send data.
       *
       * @private
       */
      onPollRequest(req, res) {
        if (this.req) {
          debug('request overlap');
          // assert: this.res, '.req and .res should be (un)set together'
          this.onError('overlap from client');
          res.writeStatus('500 Internal Server Error');
          res.end();
          return;
        }
        debug('setting request');
        this.req = req;
        this.res = res;
        const onClose = () => {
          this.writable = false;
          this.onError('poll connection closed prematurely');
        };
        const cleanup = () => {
          this.req = this.res = null;
        };
        req.cleanup = cleanup;
        res.onAborted(onClose);
        this.writable = true;
        this.emit('ready');
        // if we're still writable but had a pending close, trigger an empty send
        if (this.writable && this.shouldClose) {
          debug('triggering empty send to append close packet');
          this.send([{ type: 'noop' }]);
        }
      }
      /**
       * The client sends a request with data.
       *
       * @private
       */
      onDataRequest(req, res) {
        if (this.dataReq) {
          // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
          this.onError('data request overlap from client');
          res.writeStatus('500 Internal Server Error');
          res.end();
          return;
        }
        const expectedContentLength = Number(req.headers['content-length']);
        if (!expectedContentLength) {
          this.onError('content-length header required');
          res.writeStatus('411 Length Required').end();
          return;
        }
        if (expectedContentLength > this.maxHttpBufferSize) {
          this.onError('payload too large');
          res.writeStatus('413 Payload Too Large').end();
          return;
        }
        const isBinary = req.headers['content-type'] === 'application/octet-stream';
        if (isBinary && this.protocol === 4) {
          return this.onError('invalid content');
        }
        this.dataReq = req;
        this.dataRes = res;
        let buffer;
        let offset = 0;
        const headers = {
          // text/html is required instead of text/plain to avoid an
          // unwanted download dialog on certain user-agents (GH-43)
          'Content-Type': 'text/html',
        };
        this.headers(req, headers);
        for (const key in headers) {
          res.writeHeader(key, String(headers[key]));
        }
        const onEnd = buffer => {
          this.onData(buffer.toString());
          this.onDataRequestCleanup();
          res.cork(() => {
            res.end('ok');
          });
        };
        res.onAborted(() => {
          this.onDataRequestCleanup();
          this.onError('data request connection closed prematurely');
        });
        res.onData((arrayBuffer, isLast) => {
          const totalLength = offset + arrayBuffer.byteLength;
          if (totalLength > expectedContentLength) {
            this.onError('content-length mismatch');
            res.close(); // calls onAborted
            return;
          }
          if (!buffer) {
            if (isLast) {
              onEnd(Buffer.from(arrayBuffer));
              return;
            }
            buffer = Buffer.allocUnsafe(expectedContentLength);
          }
          Buffer.from(arrayBuffer).copy(buffer, offset);
          if (isLast) {
            if (totalLength != expectedContentLength) {
              this.onError('content-length mismatch');
              res.writeStatus('400 Content-Length Mismatch').end();
              this.onDataRequestCleanup();
              return;
            }
            onEnd(buffer);
            return;
          }
          offset = totalLength;
        });
      }
      /**
       * Cleanup request.
       *
       * @private
       */
      onDataRequestCleanup() {
        this.dataReq = this.dataRes = null;
      }
      /**
       * Processes the incoming data payload.
       *
       * @param {String} encoded payload
       * @private
       */
      onData(data) {
        debug('received "%s"', data);
        const callback = packet => {
          if (packet.type === 'close') {
            debug('got xhr close packet');
            this.onClose();
            return false;
          }
          this.onPacket(packet);
        };
        if (this.protocol === 3) {
          this.parser.decodePayload(data, callback);
        } else {
          this.parser.decodePayload(data).forEach(callback);
        }
      }
      /**
       * Overrides onClose.
       *
       * @private
       */
      onClose() {
        if (this.writable) {
          // close pending poll request
          this.send([{ type: 'noop' }]);
        }
        super.onClose();
      }
      /**
       * Writes a packet payload.
       *
       * @param {Object} packet
       * @private
       */
      send(packets) {
        this.writable = false;
        if (this.shouldClose) {
          debug('appending close packet to payload');
          packets.push({ type: 'close' });
          this.shouldClose();
          this.shouldClose = null;
        }
        const doWrite = data => {
          const compress = packets.some(packet => {
            return packet.options && packet.options.compress;
          });
          this.write(data, { compress });
        };
        if (this.protocol === 3) {
          this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        } else {
          this.parser.encodePayload(packets, doWrite);
        }
      }
      /**
       * Writes data as response to poll request.
       *
       * @param {String} data
       * @param {Object} options
       * @private
       */
      write(data, options) {
        debug('writing "%s"', data);
        this.doWrite(data, options, () => {
          this.req.cleanup();
          this.emit('drain');
        });
      }
      /**
       * Performs the write.
       *
       * @private
       */
      doWrite(data, options, callback) {
        // explicit UTF-8 is required for pages not served under utf
        const isString = typeof data === 'string';
        const contentType = isString ? 'text/plain; charset=UTF-8' : 'application/octet-stream';
        const headers = {
          'Content-Type': contentType,
        };
        const respond = data => {
          this.headers(this.req, headers);
          this.res.cork(() => {
            Object.keys(headers).forEach(key => {
              this.res.writeHeader(key, String(headers[key]));
            });
            this.res.end(data);
          });
          callback();
        };
        if (!this.httpCompression || !options.compress) {
          respond(data);
          return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len < this.httpCompression.threshold) {
          respond(data);
          return;
        }
        const encoding = accepts(this.req).encodings(['gzip', 'deflate']);
        if (!encoding) {
          respond(data);
          return;
        }
        this.compress(data, encoding, (err, data) => {
          if (err) {
            this.res.writeStatus('500 Internal Server Error');
            this.res.end();
            callback(err);
            return;
          }
          headers['Content-Encoding'] = encoding;
          respond(data);
        });
      }
      /**
       * Compresses data.
       *
       * @private
       */
      compress(data, encoding, callback) {
        debug('compressing');
        const buffers = [];
        let nread = 0;
        compressionMethods[encoding](this.httpCompression)
          .on('error', callback)
          .on('data', function (chunk) {
            buffers.push(chunk);
            nread += chunk.length;
          })
          .on('end', function () {
            callback(null, Buffer.concat(buffers, nread));
          })
          .end(data);
      }
      /**
       * Closes the transport.
       *
       * @private
       */
      doClose(fn) {
        debug('closing');
        let closeTimeoutTimer;
        const onClose = () => {
          clearTimeout(closeTimeoutTimer);
          fn();
          this.onClose();
        };
        if (this.writable) {
          debug('transport writable - closing right away');
          this.send([{ type: 'close' }]);
          onClose();
        } else if (this.discarded) {
          debug('transport discarded - closing right away');
          onClose();
        } else {
          debug('transport not writable - buffering orderly close');
          this.shouldClose = onClose;
          closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
      }
      /**
       * Returns headers for a response.
       *
       * @param req - request
       * @param {Object} extra headers
       * @private
       */
      headers(req, headers) {
        headers = headers || {};
        // prevent XSS warnings on IE
        // https://github.com/LearnBoost/socket.io/pull/1333
        const ua = req.headers['user-agent'];
        if (ua && (~ua.indexOf(';MSIE') || ~ua.indexOf('Trident/'))) {
          headers['X-XSS-Protection'] = '0';
        }
        headers['cache-control'] = 'no-store';
        this.emit('headers', headers, req);
        return headers;
      }
    }
    exports.Polling = Polling;

    /***/
  },

  /***/ 4948: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Document = __webpack_require__(7404);
    const composeNode = __webpack_require__(2576);
    const resolveEnd = __webpack_require__(191);
    const resolveProps = __webpack_require__(5300);

    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(undefined, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema,
      };
      const props = resolveProps.resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true,
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === 'block-map' || value.type === 'block-seq') && !props.hasNewline)
          onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
      }
      // @ts-expect-error If Contents is set, let's trust the user
      doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment) doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }

    exports.composeDoc = composeDoc;

    /***/
  },

  /***/ 4985: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const Scalar = __webpack_require__(6364);

    const nullTag = {
      identify: value => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: 'tag:yaml.org,2002:null',
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) =>
        typeof source === 'string' && nullTag.test.test(source) ? source : ctx.options.nullStr,
    };

    exports.nullTag = nullTag;

    /***/
  },

  /***/ 5076: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    // imported from https://github.com/socketio/engine.io-parser/tree/2.2.x
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.packets = exports.protocol = void 0;
    exports.encodePacket = encodePacket;
    exports.encodeBase64Packet = encodeBase64Packet;
    exports.decodePacket = decodePacket;
    exports.decodeBase64Packet = decodeBase64Packet;
    exports.encodePayload = encodePayload;
    exports.decodePayload = decodePayload;
    exports.encodePayloadAsBinary = encodePayloadAsBinary;
    exports.decodePayloadAsBinary = decodePayloadAsBinary;
    /**
     * Module dependencies.
     */
    const utf8 = __webpack_require__(2313);
    /**
     * Current protocol version.
     */
    exports.protocol = 3;
    const hasBinary = packets => {
      for (const packet of packets) {
        if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
          return true;
        }
      }
      return false;
    };
    /**
     * Packet types.
     */
    exports.packets = {
      open: 0, // non-ws
      close: 1, // non-ws
      ping: 2,
      pong: 3,
      message: 4,
      upgrade: 5,
      noop: 6,
    };
    const packetslist = Object.keys(exports.packets);
    /**
     * Premade error packet.
     */
    const err = { type: 'error', data: 'parser error' };
    const EMPTY_BUFFER = Buffer.concat([]);
    /**
     * Encodes a packet.
     *
     *     <packet type id> [ <data> ]
     *
     * Example:
     *
     *     5hello world
     *     3
     *     4
     *
     * Binary is encoded in an identical principle
     *
     * @api private
     */
    function encodePacket(packet, supportsBinary, utf8encode, callback) {
      if (typeof supportsBinary === 'function') {
        callback = supportsBinary;
        supportsBinary = null;
      }
      if (typeof utf8encode === 'function') {
        callback = utf8encode;
        utf8encode = null;
      }
      if (Buffer.isBuffer(packet.data)) {
        return encodeBuffer(packet, supportsBinary, callback);
      } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
        return encodeBuffer({ type: packet.type, data: arrayBufferToBuffer(packet.data) }, supportsBinary, callback);
      }
      // Sending data as a utf-8 string
      let encoded = exports.packets[packet.type];
      // data fragment is optional
      if (undefined !== packet.data) {
        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
      }
      return callback('' + encoded);
    }
    /**
     * Encode Buffer data
     */
    function encodeBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return encodeBase64Packet(packet, callback);
      }
      const data = packet.data;
      const typeBuffer = Buffer.allocUnsafe(1);
      typeBuffer[0] = exports.packets[packet.type];
      return callback(Buffer.concat([typeBuffer, data]));
    }
    /**
     * Encodes a packet with binary data in a base64 string
     *
     * @param {Object} packet, has `type` and `data`
     * @return {String} base64 encoded message
     */
    function encodeBase64Packet(packet, callback) {
      const data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
      let message = 'b' + exports.packets[packet.type];
      message += data.toString('base64');
      return callback(message);
    }
    /**
     * Decodes a packet. Data also available as an ArrayBuffer if requested.
     *
     * @return {Object} with `type` and `data` (if any)
     * @api private
     */
    function decodePacket(data, binaryType, utf8decode) {
      if (data === undefined) {
        return err;
      }
      let type;
      // String data
      if (typeof data === 'string') {
        type = data.charAt(0);
        if (type === 'b') {
          return decodeBase64Packet(data.slice(1), binaryType);
        }
        if (utf8decode) {
          data = tryDecode(data);
          if (data === false) {
            return err;
          }
        }
        if (Number(type) != type || !packetslist[type]) {
          return err;
        }
        if (data.length > 1) {
          return { type: packetslist[type], data: data.slice(1) };
        } else {
          return { type: packetslist[type] };
        }
      }
      // Binary data
      if (binaryType === 'arraybuffer') {
        // wrap Buffer/ArrayBuffer data into an Uint8Array
        const intArray = new Uint8Array(data);
        type = intArray[0];
        return { type: packetslist[type], data: intArray.buffer.slice(1) };
      }
      if (data instanceof ArrayBuffer) {
        data = arrayBufferToBuffer(data);
      }
      type = data[0];
      return { type: packetslist[type], data: data.slice(1) };
    }
    function tryDecode(data) {
      try {
        data = utf8.decode(data, { strict: false });
      } catch (e) {
        return false;
      }
      return data;
    }
    /**
     * Decodes a packet encoded in a base64 string.
     *
     * @param {String} base64 encoded message
     * @return {Object} with `type` and `data` (if any)
     */
    function decodeBase64Packet(msg, binaryType) {
      const type = packetslist[msg.charAt(0)];
      let data = Buffer.from(msg.slice(1), 'base64');
      if (binaryType === 'arraybuffer') {
        const abv = new Uint8Array(data.length);
        for (let i = 0; i < abv.length; i++) {
          abv[i] = data[i];
        }
        // @ts-ignore
        data = abv.buffer;
      }
      return { type: type, data: data };
    }
    /**
     * Encodes multiple messages (payload).
     *
     *     <length>:data
     *
     * Example:
     *
     *     11:hello world2:hi
     *
     * If any contents are binary, they will be encoded as base64 strings. Base64
     * encoded strings are marked with a b before the length specifier
     *
     * @param {Array} packets
     * @api private
     */
    function encodePayload(packets, supportsBinary, callback) {
      if (typeof supportsBinary === 'function') {
        callback = supportsBinary;
        supportsBinary = null;
      }
      if (supportsBinary && hasBinary(packets)) {
        return encodePayloadAsBinary(packets, callback);
      }
      if (!packets.length) {
        return callback('0:');
      }
      function encodeOne(packet, doneCallback) {
        encodePacket(packet, supportsBinary, false, function (message) {
          doneCallback(null, setLengthHeader(message));
        });
      }
      map(packets, encodeOne, function (err, results) {
        return callback(results.join(''));
      });
    }
    function setLengthHeader(message) {
      return message.length + ':' + message;
    }
    /**
     * Async array map using after
     */
    function map(ary, each, done) {
      const results = new Array(ary.length);
      let count = 0;
      for (let i = 0; i < ary.length; i++) {
        each(ary[i], (error, msg) => {
          results[i] = msg;
          if (++count === ary.length) {
            done(null, results);
          }
        });
      }
    }
    /*
     * Decodes data when a payload is maybe expected. Possible binary contents are
     * decoded from their base64 representation
     *
     * @param {String} data, callback method
     * @api public
     */
    function decodePayload(data, binaryType, callback) {
      if (typeof data !== 'string') {
        return decodePayloadAsBinary(data, binaryType, callback);
      }
      if (typeof binaryType === 'function') {
        callback = binaryType;
        binaryType = null;
      }
      if (data === '') {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }
      let length = '',
        n,
        msg,
        packet;
      for (let i = 0, l = data.length; i < l; i++) {
        const chr = data.charAt(i);
        if (chr !== ':') {
          length += chr;
          continue;
        }
        // @ts-ignore
        if (length === '' || length != (n = Number(length))) {
          // parser error - ignoring payload
          return callback(err, 0, 1);
        }
        msg = data.slice(i + 1, i + 1 + n);
        if (length != msg.length) {
          // parser error - ignoring payload
          return callback(err, 0, 1);
        }
        if (msg.length) {
          packet = decodePacket(msg, binaryType, false);
          if (err.type === packet.type && err.data === packet.data) {
            // parser error in individual packet - ignoring payload
            return callback(err, 0, 1);
          }
          const more = callback(packet, i + n, l);
          if (more === false) return;
        }
        // advance cursor
        i += n;
        length = '';
      }
      if (length !== '') {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }
    }
    /**
     *
     * Converts a buffer to a utf8.js encoded string
     *
     * @api private
     */
    function bufferToString(buffer) {
      let str = '';
      for (let i = 0, l = buffer.length; i < l; i++) {
        str += String.fromCharCode(buffer[i]);
      }
      return str;
    }
    /**
     *
     * Converts a utf8.js encoded string to a buffer
     *
     * @api private
     */
    function stringToBuffer(string) {
      const buf = Buffer.allocUnsafe(string.length);
      for (let i = 0, l = string.length; i < l; i++) {
        buf.writeUInt8(string.charCodeAt(i), i);
      }
      return buf;
    }
    /**
     *
     * Converts an ArrayBuffer to a Buffer
     *
     * @api private
     */
    function arrayBufferToBuffer(data) {
      // data is either an ArrayBuffer or ArrayBufferView.
      const length = data.byteLength || data.length;
      const offset = data.byteOffset || 0;
      return Buffer.from(data.buffer || data, offset, length);
    }
    /**
     * Encodes multiple messages (payload) as binary.
     *
     * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
     * 255><data>
     *
     * Example:
     * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
     *
     * @param {Array} packets
     * @return {Buffer} encoded payload
     * @api private
     */
    function encodePayloadAsBinary(packets, callback) {
      if (!packets.length) {
        return callback(EMPTY_BUFFER);
      }
      map(packets, encodeOneBinaryPacket, function (err, results) {
        return callback(Buffer.concat(results));
      });
    }
    function encodeOneBinaryPacket(p, doneCallback) {
      function onBinaryPacketEncode(packet) {
        const encodingLength = '' + packet.length;
        let sizeBuffer;
        if (typeof packet === 'string') {
          sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
          sizeBuffer[0] = 0; // is a string (not true binary = 0)
          for (var i = 0; i < encodingLength.length; i++) {
            sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
          }
          sizeBuffer[sizeBuffer.length - 1] = 255;
          return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
        }
        sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
        sizeBuffer[0] = 1; // is binary (true binary = 1)
        for (var i = 0; i < encodingLength.length; i++) {
          sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
        }
        sizeBuffer[sizeBuffer.length - 1] = 255;
        doneCallback(null, Buffer.concat([sizeBuffer, packet]));
      }
      encodePacket(p, true, true, onBinaryPacketEncode);
    }
    /*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary

 * @param {Buffer} data, callback method
 * @api public
 */
    function decodePayloadAsBinary(data, binaryType, callback) {
      if (typeof binaryType === 'function') {
        callback = binaryType;
        binaryType = null;
      }
      let bufferTail = data;
      const buffers = [];
      let i;
      while (bufferTail.length > 0) {
        let strLen = '';
        const isString = bufferTail[0] === 0;
        for (i = 1; ; i++) {
          if (bufferTail[i] === 255) break;
          // 310 = char length of Number.MAX_VALUE
          if (strLen.length > 310) {
            return callback(err, 0, 1);
          }
          strLen += '' + bufferTail[i];
        }
        bufferTail = bufferTail.slice(strLen.length + 1);
        const msgLength = parseInt(strLen, 10);
        let msg = bufferTail.slice(1, msgLength + 1);
        if (isString) msg = bufferToString(msg);
        buffers.push(msg);
        bufferTail = bufferTail.slice(msgLength + 1);
      }
      const total = buffers.length;
      for (i = 0; i < total; i++) {
        const buffer = buffers[i];
        callback(decodePacket(buffer, binaryType, true), i, total);
      }
    }

    /***/
  },

  /***/ 5173: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const runtimeRequire = true ? __WEBPACK_EXTERNAL_createRequire(import.meta.url) : 0; // eslint-disable-line
    if (typeof runtimeRequire.addon === 'function') {
      // if the platform supports native resolving prefer that
      module.exports = runtimeRequire.addon.bind(runtimeRequire);
    } else {
      // else use the runtime version here
      module.exports = __webpack_require__(4321);
    }

    /***/
  },

  /***/ 5263: /***/ function (module, exports, __webpack_require__) {
    const __dirname = __webpack_fileURLToPath__(import.meta.url + '/..').slice(0, -1);

    const __createBinding =
      (this && this.__createBinding) ||
      (Object.create
        ? function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            let desc = Object.getOwnPropertyDescriptor(m, k);
            if (!desc || ('get' in desc ? !m.__esModule : desc.writable || desc.configurable)) {
              desc = {
                enumerable: true,
                get: function () {
                  return m[k];
                },
              };
            }
            Object.defineProperty(o, k2, desc);
          }
        : function (o, m, k, k2) {
            if (k2 === undefined) k2 = k;
            o[k2] = m[k];
          });
    const __setModuleDefault =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (o, v) {
            Object.defineProperty(o, 'default', { enumerable: true, value: v });
          }
        : function (o, v) {
            o['default'] = v;
          });
    const __importStar =
      (this && this.__importStar) ||
      function (mod) {
        if (mod && mod.__esModule) return mod;
        const result = {};
        if (mod != null)
          for (const k in mod)
            if (k !== 'default' && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
      };
    const __importDefault =
      (this && this.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Namespace = exports.Socket = exports.Server = void 0;
    const http = __webpack_require__(8611);
    const fs_1 = __webpack_require__(9896);
    const zlib_1 = __webpack_require__(3106);
    const accepts = __webpack_require__(9);
    const stream_1 = __webpack_require__(2203);
    const path = __webpack_require__(6928);
    const engine_io_1 = __webpack_require__(5838);
    const client_1 = __webpack_require__(184);
    const events_1 = __webpack_require__(4434);
    const namespace_1 = __webpack_require__(616);
    Object.defineProperty(exports, 'Namespace', {
      enumerable: true,
      get: function () {
        return namespace_1.Namespace;
      },
    });
    const parent_namespace_1 = __webpack_require__(777);
    const socket_io_adapter_1 = __webpack_require__(8723);
    const parser = __importStar(__webpack_require__(9834));
    const debug_1 = __importDefault(__webpack_require__(1106));
    const socket_1 = __webpack_require__(414);
    Object.defineProperty(exports, 'Socket', {
      enumerable: true,
      get: function () {
        return socket_1.Socket;
      },
    });
    const typed_events_1 = __webpack_require__(21);
    const uws_1 = __webpack_require__(9318);
    const cors_1 = __importDefault(__webpack_require__(6388));
    const debug = (0, debug_1.default)('socket.io:server');
    const clientVersion = __webpack_require__(902) /* .version */.rE;
    const dotMapRegex = /\.map/;
    /**
     * Represents a Socket.IO server.
     *
     * @example
     * import { Server } from "socket.io";
     *
     * const io = new Server();
     *
     * io.on("connection", (socket) => {
     *   console.log(`socket ${socket.id} connected`);
     *
     *   // send an event to the client
     *   socket.emit("foo", "bar");
     *
     *   socket.on("foobar", () => {
     *     // an event was received from the client
     *   });
     *
     *   // upon disconnection
     *   socket.on("disconnect", (reason) => {
     *     console.log(`socket ${socket.id} disconnected due to ${reason}`);
     *   });
     * });
     *
     * io.listen(3000);
     */
    class Server extends typed_events_1.StrictEventEmitter {
      constructor(srv, opts = {}) {
        super();
        /**
         * @private
         */
        this._nsps = new Map();
        this.parentNsps = new Map();
        /**
         * A subset of the {@link parentNsps} map, only containing {@link ParentNamespace} which are based on a regular
         * expression.
         *
         * @private
         */
        this.parentNamespacesFromRegExp = new Map();
        if (typeof srv === 'object' && srv instanceof Object && !srv.listen) {
          opts = srv;
          srv = undefined;
        }
        this.path(opts.path || '/socket.io');
        this.connectTimeout(opts.connectTimeout || 45000);
        this.serveClient(opts.serveClient !== false);
        this._parser = opts.parser || parser;
        this.encoder = new this._parser.Encoder();
        this.opts = opts;
        if (opts.connectionStateRecovery) {
          opts.connectionStateRecovery = Object.assign(
            {
              maxDisconnectionDuration: 2 * 60 * 1000,
              skipMiddlewares: true,
            },
            opts.connectionStateRecovery,
          );
          this.adapter(opts.adapter || socket_io_adapter_1.SessionAwareAdapter);
        } else {
          this.adapter(opts.adapter || socket_io_adapter_1.Adapter);
        }
        opts.cleanupEmptyChildNamespaces = !!opts.cleanupEmptyChildNamespaces;
        this.sockets = this.of('/');
        if (srv || typeof srv == 'number') this.attach(srv);
        if (this.opts.cors) {
          this._corsMiddleware = (0, cors_1.default)(this.opts.cors);
        }
      }
      get _opts() {
        return this.opts;
      }
      serveClient(v) {
        if (!arguments.length) return this._serveClient;
        this._serveClient = v;
        return this;
      }
      /**
       * Executes the middleware for an incoming namespace not already created on the server.
       *
       * @param name - name of incoming namespace
       * @param auth - the auth parameters
       * @param fn - callback
       *
       * @private
       */
      _checkNamespace(name, auth, fn) {
        if (this.parentNsps.size === 0) return fn(false);
        const keysIterator = this.parentNsps.keys();
        const run = () => {
          const nextFn = keysIterator.next();
          if (nextFn.done) {
            return fn(false);
          }
          nextFn.value(name, auth, (err, allow) => {
            if (err || !allow) {
              return run();
            }
            if (this._nsps.has(name)) {
              // the namespace was created in the meantime
              debug('dynamic namespace %s already exists', name);
              return fn(this._nsps.get(name));
            }
            const namespace = this.parentNsps.get(nextFn.value).createChild(name);
            debug('dynamic namespace %s was created', name);
            fn(namespace);
          });
        };
        run();
      }
      path(v) {
        if (!arguments.length) return this._path;
        this._path = v.replace(/\/$/, '');
        const escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        this.clientPathRegex = new RegExp(
          '^' + escapedPath + '/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)',
        );
        return this;
      }
      connectTimeout(v) {
        if (v === undefined) return this._connectTimeout;
        this._connectTimeout = v;
        return this;
      }
      adapter(v) {
        if (!arguments.length) return this._adapter;
        this._adapter = v;
        for (const nsp of this._nsps.values()) {
          nsp._initAdapter();
        }
        return this;
      }
      /**
       * Attaches socket.io to a server or port.
       *
       * @param srv - server or port
       * @param opts - options passed to engine.io
       * @return self
       */
      listen(srv, opts = {}) {
        return this.attach(srv, opts);
      }
      /**
       * Attaches socket.io to a server or port.
       *
       * @param srv - server or port
       * @param opts - options passed to engine.io
       * @return self
       */
      attach(srv, opts = {}) {
        if (typeof srv == 'function') {
          const msg =
            'You are trying to attach socket.io to an express ' +
            'request handler function. Please pass a http.Server instance.';
          throw new Error(msg);
        }
        // handle a port as a string
        if (Number(srv) == srv) {
          srv = Number(srv);
        }
        if (typeof srv == 'number') {
          debug('creating http server and binding to %d', srv);
          const port = srv;
          srv = http.createServer((req, res) => {
            res.writeHead(404);
            res.end();
          });
          srv.listen(port);
        }
        // merge the options passed to the Socket.IO server
        Object.assign(opts, this.opts);
        // set engine.io path to `/socket.io`
        opts.path = opts.path || this._path;
        this.initEngine(srv, opts);
        return this;
      }
      attachApp(app /*: TemplatedApp */, opts = {}) {
        // merge the options passed to the Socket.IO server
        Object.assign(opts, this.opts);
        // set engine.io path to `/socket.io`
        opts.path = opts.path || this._path;
        // initialize engine
        debug('creating uWebSockets.js-based engine with opts %j', opts);
        const engine = new engine_io_1.uServer(opts);
        engine.attach(app, opts);
        // bind to engine events
        this.bind(engine);
        if (this._serveClient) {
          // attach static file serving
          app.get(`${this._path}/*`, (res, req) => {
            if (!this.clientPathRegex.test(req.getUrl())) {
              req.setYield(true);
              return;
            }
            const filename = req.getUrl().replace(this._path, '').replace(/\?.*$/, '').replace(/^\//, '');
            const isMap = dotMapRegex.test(filename);
            const type = isMap ? 'map' : 'source';
            // Per the standard, ETags must be quoted:
            // https://tools.ietf.org/html/rfc7232#section-2.3
            const expectedEtag = '"' + clientVersion + '"';
            const weakEtag = 'W/' + expectedEtag;
            const etag = req.getHeader('if-none-match');
            if (etag) {
              if (expectedEtag === etag || weakEtag === etag) {
                debug('serve client %s 304', type);
                res.writeStatus('304 Not Modified');
                res.end();
                return;
              }
            }
            debug('serve client %s', type);
            res.writeHeader('cache-control', 'public, max-age=0');
            res.writeHeader('content-type', 'application/' + (isMap ? 'json' : 'javascript') + '; charset=utf-8');
            res.writeHeader('etag', expectedEtag);
            const filepath = path.join(__dirname, '../client-dist/', filename);
            (0, uws_1.serveFile)(res, filepath);
          });
        }
        (0, uws_1.patchAdapter)(app);
      }
      /**
       * Initialize engine
       *
       * @param srv - the server to attach to
       * @param opts - options passed to engine.io
       * @private
       */
      initEngine(srv, opts) {
        // initialize engine
        debug('creating engine.io instance with opts %j', opts);
        this.eio = (0, engine_io_1.attach)(srv, opts);
        // attach static file serving
        if (this._serveClient) this.attachServe(srv);
        // Export http server
        this.httpServer = srv;
        // bind to engine events
        this.bind(this.eio);
      }
      /**
       * Attaches the static file serving.
       *
       * @param srv http server
       * @private
       */
      attachServe(srv) {
        debug('attaching client serving req handler');
        const evs = srv.listeners('request').slice(0);
        srv.removeAllListeners('request');
        srv.on('request', (req, res) => {
          if (this.clientPathRegex.test(req.url)) {
            if (this._corsMiddleware) {
              this._corsMiddleware(req, res, () => {
                this.serve(req, res);
              });
            } else {
              this.serve(req, res);
            }
          } else {
            for (let i = 0; i < evs.length; i++) {
              evs[i].call(srv, req, res);
            }
          }
        });
      }
      /**
       * Handles a request serving of client source and map
       *
       * @param req
       * @param res
       * @private
       */
      serve(req, res) {
        const filename = req.url.replace(this._path, '').replace(/\?.*$/, '');
        const isMap = dotMapRegex.test(filename);
        const type = isMap ? 'map' : 'source';
        // Per the standard, ETags must be quoted:
        // https://tools.ietf.org/html/rfc7232#section-2.3
        const expectedEtag = '"' + clientVersion + '"';
        const weakEtag = 'W/' + expectedEtag;
        const etag = req.headers['if-none-match'];
        if (etag) {
          if (expectedEtag === etag || weakEtag === etag) {
            debug('serve client %s 304', type);
            res.writeHead(304);
            res.end();
            return;
          }
        }
        debug('serve client %s', type);
        res.setHeader('Cache-Control', 'public, max-age=0');
        res.setHeader('Content-Type', 'application/' + (isMap ? 'json' : 'javascript') + '; charset=utf-8');
        res.setHeader('ETag', expectedEtag);
        Server.sendFile(filename, req, res);
      }
      /**
       * @param filename
       * @param req
       * @param res
       * @private
       */
      static sendFile(filename, req, res) {
        const readStream = (0, fs_1.createReadStream)(path.join(__dirname, '../client-dist/', filename));
        const encoding = accepts(req).encodings(['br', 'gzip', 'deflate']);
        const onError = err => {
          if (err) {
            res.end();
          }
        };
        switch (encoding) {
          case 'br':
            res.writeHead(200, { 'content-encoding': 'br' });
            (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
            break;
          case 'gzip':
            res.writeHead(200, { 'content-encoding': 'gzip' });
            (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
            break;
          case 'deflate':
            res.writeHead(200, { 'content-encoding': 'deflate' });
            (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
            break;
          default:
            res.writeHead(200);
            (0, stream_1.pipeline)(readStream, res, onError);
        }
      }
      /**
       * Binds socket.io to an engine.io instance.
       *
       * @param engine engine.io (or compatible) server
       * @return self
       */
      bind(engine) {
        // TODO apply strict types to the engine: "connection" event, `close()` and a method to serve static content
        //  this would allow to provide any custom engine, like one based on Deno or Bun built-in HTTP server
        this.engine = engine;
        this.engine.on('connection', this.onconnection.bind(this));
        return this;
      }
      /**
       * Called with each incoming transport connection.
       *
       * @param {engine.Socket} conn
       * @return self
       * @private
       */
      onconnection(conn) {
        debug('incoming connection with id %s', conn.id);
        const client = new client_1.Client(this, conn);
        if (conn.protocol === 3) {
          // @ts-ignore
          client.connect('/');
        }
        return this;
      }
      /**
       * Looks up a namespace.
       *
       * @example
       * // with a simple string
       * const myNamespace = io.of("/my-namespace");
       *
       * // with a regex
       * const dynamicNsp = io.of(/^\/dynamic-\d+$/).on("connection", (socket) => {
       *   const namespace = socket.nsp; // newNamespace.name === "/dynamic-101"
       *
       *   // broadcast to all clients in the given sub-namespace
       *   namespace.emit("hello");
       * });
       *
       * @param name - nsp name
       * @param fn optional, nsp `connection` ev handler
       */
      of(name, fn) {
        if (typeof name === 'function' || name instanceof RegExp) {
          const parentNsp = new parent_namespace_1.ParentNamespace(this);
          debug('initializing parent namespace %s', parentNsp.name);
          if (typeof name === 'function') {
            this.parentNsps.set(name, parentNsp);
          } else {
            this.parentNsps.set((nsp, conn, next) => next(null, name.test(nsp)), parentNsp);
            this.parentNamespacesFromRegExp.set(name, parentNsp);
          }
          if (fn) {
            // @ts-ignore
            parentNsp.on('connect', fn);
          }
          return parentNsp;
        }
        if (String(name)[0] !== '/') name = '/' + name;
        let nsp = this._nsps.get(name);
        if (!nsp) {
          for (const [regex, parentNamespace] of this.parentNamespacesFromRegExp) {
            if (regex.test(name)) {
              debug('attaching namespace %s to parent namespace %s', name, regex);
              return parentNamespace.createChild(name);
            }
          }
          debug('initializing namespace %s', name);
          nsp = new namespace_1.Namespace(this, name);
          this._nsps.set(name, nsp);
          if (name !== '/') {
            // @ts-ignore
            this.sockets.emitReserved('new_namespace', nsp);
          }
        }
        if (fn) nsp.on('connect', fn);
        return nsp;
      }
      /**
       * Closes server connection
       *
       * @param [fn] optional, called as `fn([err])` on error OR all conns closed
       */
      async close(fn) {
        await Promise.allSettled(
          [...this._nsps.values()].map(async nsp => {
            nsp.sockets.forEach(socket => {
              socket._onclose('server shutting down');
            });
            await nsp.adapter.close();
          }),
        );
        this.engine.close();
        // restore the Adapter prototype, when the Socket.IO server was attached to a uWebSockets.js server
        (0, uws_1.restoreAdapter)();
        if (this.httpServer) {
          this.httpServer.close(fn);
        } else {
          fn && fn();
        }
      }
      /**
       * Registers a middleware, which is a function that gets executed for every incoming {@link Socket}.
       *
       * @example
       * io.use((socket, next) => {
       *   // ...
       *   next();
       * });
       *
       * @param fn - the middleware function
       */
      use(fn) {
        this.sockets.use(fn);
        return this;
      }
      /**
       * Targets a room when emitting.
       *
       * @example
       * // the “foo” event will be broadcast to all connected clients in the “room-101” room
       * io.to("room-101").emit("foo", "bar");
       *
       * // with an array of rooms (a client will be notified at most once)
       * io.to(["room-101", "room-102"]).emit("foo", "bar");
       *
       * // with multiple chained calls
       * io.to("room-101").to("room-102").emit("foo", "bar");
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      to(room) {
        return this.sockets.to(room);
      }
      /**
       * Targets a room when emitting. Similar to `to()`, but might feel clearer in some cases:
       *
       * @example
       * // disconnect all clients in the "room-101" room
       * io.in("room-101").disconnectSockets();
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      in(room) {
        return this.sockets.in(room);
      }
      /**
       * Excludes a room when emitting.
       *
       * @example
       * // the "foo" event will be broadcast to all connected clients, except the ones that are in the "room-101" room
       * io.except("room-101").emit("foo", "bar");
       *
       * // with an array of rooms
       * io.except(["room-101", "room-102"]).emit("foo", "bar");
       *
       * // with multiple chained calls
       * io.except("room-101").except("room-102").emit("foo", "bar");
       *
       * @param room - a room, or an array of rooms
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      except(room) {
        return this.sockets.except(room);
      }
      /**
       * Sends a `message` event to all clients.
       *
       * This method mimics the WebSocket.send() method.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
       *
       * @example
       * io.send("hello");
       *
       * // this is equivalent to
       * io.emit("message", "hello");
       *
       * @return self
       */
      send(...args) {
        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.sockets.emit('message', ...args);
        return this;
      }
      /**
       * Sends a `message` event to all clients. Alias of {@link send}.
       *
       * @return self
       */
      write(...args) {
        // This type-cast is needed because EmitEvents likely doesn't have `message` as a key.
        // if you specify the EmitEvents, the type of args will be never.
        this.sockets.emit('message', ...args);
        return this;
      }
      /**
       * Sends a message to the other Socket.IO servers of the cluster.
       *
       * @example
       * io.serverSideEmit("hello", "world");
       *
       * io.on("hello", (arg1) => {
       *   console.log(arg1); // prints "world"
       * });
       *
       * // acknowledgements (without binary content) are supported too:
       * io.serverSideEmit("ping", (err, responses) => {
       *  if (err) {
       *     // some servers did not acknowledge the event in the given delay
       *   } else {
       *     console.log(responses); // one response per server (except the current one)
       *   }
       * });
       *
       * io.on("ping", (cb) => {
       *   cb("pong");
       * });
       *
       * @param ev - the event name
       * @param args - an array of arguments, which may include an acknowledgement callback at the end
       */
      serverSideEmit(ev, ...args) {
        return this.sockets.serverSideEmit(ev, ...args);
      }
      /**
       * Sends a message and expect an acknowledgement from the other Socket.IO servers of the cluster.
       *
       * @example
       * try {
       *   const responses = await io.serverSideEmitWithAck("ping");
       *   console.log(responses); // one response per server (except the current one)
       * } catch (e) {
       *   // some servers did not acknowledge the event in the given delay
       * }
       *
       * @param ev - the event name
       * @param args - an array of arguments
       *
       * @return a Promise that will be fulfilled when all servers have acknowledged the event
       */
      serverSideEmitWithAck(ev, ...args) {
        return this.sockets.serverSideEmitWithAck(ev, ...args);
      }
      /**
       * Gets a list of socket ids.
       *
       * @deprecated this method will be removed in the next major release, please use {@link Server#serverSideEmit} or
       * {@link Server#fetchSockets} instead.
       */
      allSockets() {
        return this.sockets.allSockets();
      }
      /**
       * Sets the compress flag.
       *
       * @example
       * io.compress(false).emit("hello");
       *
       * @param compress - if `true`, compresses the sending data
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      compress(compress) {
        return this.sockets.compress(compress);
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
       * receive messages (because of network slowness or other issues, or because they’re connected through long polling
       * and is in the middle of a request-response cycle).
       *
       * @example
       * io.volatile.emit("hello"); // the clients may or may not receive it
       *
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      get volatile() {
        return this.sockets.volatile;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
       *
       * @example
       * // the “foo” event will be broadcast to all connected clients on this node
       * io.local.emit("foo", "bar");
       *
       * @return a new {@link BroadcastOperator} instance for chaining
       */
      get local() {
        return this.sockets.local;
      }
      /**
       * Adds a timeout in milliseconds for the next operation.
       *
       * @example
       * io.timeout(1000).emit("some-event", (err, responses) => {
       *   if (err) {
       *     // some clients did not acknowledge the event in the given delay
       *   } else {
       *     console.log(responses); // one response per client
       *   }
       * });
       *
       * @param timeout
       */
      timeout(timeout) {
        return this.sockets.timeout(timeout);
      }
      /**
       * Returns the matching socket instances.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * // return all Socket instances
       * const sockets = await io.fetchSockets();
       *
       * // return all Socket instances in the "room1" room
       * const sockets = await io.in("room1").fetchSockets();
       *
       * for (const socket of sockets) {
       *   console.log(socket.id);
       *   console.log(socket.handshake);
       *   console.log(socket.rooms);
       *   console.log(socket.data);
       *
       *   socket.emit("hello");
       *   socket.join("room1");
       *   socket.leave("room2");
       *   socket.disconnect();
       * }
       */
      fetchSockets() {
        return this.sockets.fetchSockets();
      }
      /**
       * Makes the matching socket instances join the specified rooms.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       *
       * // make all socket instances join the "room1" room
       * io.socketsJoin("room1");
       *
       * // make all socket instances in the "room1" room join the "room2" and "room3" rooms
       * io.in("room1").socketsJoin(["room2", "room3"]);
       *
       * @param room - a room, or an array of rooms
       */
      socketsJoin(room) {
        return this.sockets.socketsJoin(room);
      }
      /**
       * Makes the matching socket instances leave the specified rooms.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * // make all socket instances leave the "room1" room
       * io.socketsLeave("room1");
       *
       * // make all socket instances in the "room1" room leave the "room2" and "room3" rooms
       * io.in("room1").socketsLeave(["room2", "room3"]);
       *
       * @param room - a room, or an array of rooms
       */
      socketsLeave(room) {
        return this.sockets.socketsLeave(room);
      }
      /**
       * Makes the matching socket instances disconnect.
       *
       * Note: this method also works within a cluster of multiple Socket.IO servers, with a compatible {@link Adapter}.
       *
       * @example
       * // make all socket instances disconnect (the connections might be kept alive for other namespaces)
       * io.disconnectSockets();
       *
       * // make all socket instances in the "room1" room disconnect and close the underlying connections
       * io.in("room1").disconnectSockets(true);
       *
       * @param close - whether to close the underlying connection
       */
      disconnectSockets(close = false) {
        return this.sockets.disconnectSockets(close);
      }
    }
    exports.Server = Server;
    /**
     * Expose main namespace (/).
     */
    const emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {
      return typeof events_1.EventEmitter.prototype[key] === 'function';
    });
    emitterMethods.forEach(function (fn) {
      Server.prototype[fn] = function () {
        return this.sockets[fn].apply(this.sockets, arguments);
      };
    });
    module.exports = (srv, opts) => new Server(srv, opts);
    module.exports.Server = Server;
    module.exports.Namespace = namespace_1.Namespace;
    module.exports.Socket = socket_1.Socket;

    /***/
  },

  /***/ 5287: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Server = exports.BaseServer = void 0;
    const qs = __webpack_require__(3480);
    const url_1 = __webpack_require__(7016);
    const base64id = __webpack_require__(6821);
    const transports_1 = __webpack_require__(8873);
    const events_1 = __webpack_require__(4434);
    const socket_1 = __webpack_require__(7773);
    const debug_1 = __webpack_require__(1106);
    const cookie_1 = __webpack_require__(4058);
    const ws_1 = __webpack_require__(3001);
    const webtransport_1 = __webpack_require__(9218);
    const engine_io_parser_1 = __webpack_require__(2680);
    const debug = (0, debug_1.default)('engine');
    const kResponseHeaders = Symbol('responseHeaders');
    function parseSessionId(data) {
      try {
        const parsed = JSON.parse(data);
        if (typeof parsed.sid === 'string') {
          return parsed.sid;
        }
      } catch (e) {}
    }
    class BaseServer extends events_1.EventEmitter {
      /**
       * Server constructor.
       *
       * @param {Object} opts - options
       */
      constructor(opts = {}) {
        super();
        this.middlewares = [];
        this.clients = {};
        this.clientsCount = 0;
        this.opts = Object.assign(
          {
            wsEngine: ws_1.Server,
            pingTimeout: 20000,
            pingInterval: 25000,
            upgradeTimeout: 10000,
            maxHttpBufferSize: 1e6,
            transports: ['polling', 'websocket'], // WebTransport is disabled by default
            allowUpgrades: true,
            httpCompression: {
              threshold: 1024,
            },
            cors: false,
            allowEIO3: false,
          },
          opts,
        );
        if (opts.cookie) {
          this.opts.cookie = Object.assign(
            {
              name: 'io',
              path: '/',
              // @ts-ignore
              httpOnly: opts.cookie.path !== false,
              sameSite: 'lax',
            },
            opts.cookie,
          );
        }
        if (this.opts.cors) {
          this.use(__webpack_require__(6388)(this.opts.cors));
        }
        if (opts.perMessageDeflate) {
          this.opts.perMessageDeflate = Object.assign(
            {
              threshold: 1024,
            },
            opts.perMessageDeflate,
          );
        }
        this.init();
      }
      /**
       * Compute the pathname of the requests that are handled by the server
       * @param options
       * @protected
       */
      _computePath(options) {
        let path = (options.path || '/engine.io').replace(/\/$/, '');
        if (options.addTrailingSlash !== false) {
          // normalize path
          path += '/';
        }
        return path;
      }
      /**
       * Returns a list of available transports for upgrade given a certain transport.
       *
       * @return {Array}
       */
      upgrades(transport) {
        if (!this.opts.allowUpgrades) return [];
        return transports_1.default[transport].upgradesTo || [];
      }
      /**
       * Verifies a request.
       *
       * @param {EngineRequest} req
       * @param upgrade - whether it's an upgrade request
       * @param fn
       * @protected
       */
      verify(req, upgrade, fn) {
        // transport check
        const transport = req._query.transport;
        // WebTransport does not go through the verify() method, see the onWebTransportSession() method
        if (!~this.opts.transports.indexOf(transport) || transport === 'webtransport') {
          debug('unknown transport "%s"', transport);
          return fn(Server.errors.UNKNOWN_TRANSPORT, { transport });
        }
        // 'Origin' header check
        const isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);
        if (isOriginInvalid) {
          const origin = req.headers.origin;
          req.headers.origin = null;
          debug('origin header invalid');
          return fn(Server.errors.BAD_REQUEST, {
            name: 'INVALID_ORIGIN',
            origin,
          });
        }
        // sid check
        const sid = req._query.sid;
        if (sid) {
          if (!this.clients.hasOwnProperty(sid)) {
            debug('unknown sid "%s"', sid);
            return fn(Server.errors.UNKNOWN_SID, {
              sid,
            });
          }
          const previousTransport = this.clients[sid].transport.name;
          if (!upgrade && previousTransport !== transport) {
            debug('bad request: unexpected transport without upgrade');
            return fn(Server.errors.BAD_REQUEST, {
              name: 'TRANSPORT_MISMATCH',
              transport,
              previousTransport,
            });
          }
        } else {
          // handshake is GET only
          if (req.method !== 'GET') {
            return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
              method: req.method,
            });
          }
          if (transport === 'websocket' && !upgrade) {
            debug('invalid transport upgrade');
            return fn(Server.errors.BAD_REQUEST, {
              name: 'TRANSPORT_HANDSHAKE_ERROR',
            });
          }
          if (!this.opts.allowRequest) return fn();
          return this.opts.allowRequest(req, (message, success) => {
            if (!success) {
              return fn(Server.errors.FORBIDDEN, {
                message,
              });
            }
            fn();
          });
        }
        fn();
      }
      /**
       * Adds a new middleware.
       *
       * @example
       * import helmet from "helmet";
       *
       * engine.use(helmet());
       *
       * @param fn
       */
      use(fn) {
        this.middlewares.push(fn);
      }
      /**
       * Apply the middlewares to the request.
       *
       * @param req
       * @param res
       * @param callback
       * @protected
       */
      _applyMiddlewares(req, res, callback) {
        if (this.middlewares.length === 0) {
          debug('no middleware to apply, skipping');
          return callback();
        }
        const apply = i => {
          debug('applying middleware n°%d', i + 1);
          this.middlewares[i](req, res, err => {
            if (err) {
              return callback(err);
            }
            if (i + 1 < this.middlewares.length) {
              apply(i + 1);
            } else {
              callback();
            }
          });
        };
        apply(0);
      }
      /**
       * Closes all clients.
       */
      close() {
        debug('closing all open clients');
        for (const i in this.clients) {
          if (this.clients.hasOwnProperty(i)) {
            this.clients[i].close(true);
          }
        }
        this.cleanup();
        return this;
      }
      /**
       * generate a socket id.
       * Overwrite this method to generate your custom socket id
       *
       * @param {IncomingMessage} req - the request object
       */
      generateId(req) {
        return base64id.generateId();
      }
      /**
       * Handshakes a new client.
       *
       * @param {String} transportName
       * @param {Object} req - the request object
       * @param {Function} closeConnection
       *
       * @protected
       */
      async handshake(transportName, req, closeConnection) {
        const protocol = req._query.EIO === '4' ? 4 : 3; // 3rd revision by default
        if (protocol === 3 && !this.opts.allowEIO3) {
          debug('unsupported protocol version');
          this.emit('connection_error', {
            req,
            code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
            message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
            context: {
              protocol,
            },
          });
          closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
          return;
        }
        let id;
        try {
          id = await this.generateId(req);
        } catch (e) {
          debug('error while generating an id');
          this.emit('connection_error', {
            req,
            code: Server.errors.BAD_REQUEST,
            message: Server.errorMessages[Server.errors.BAD_REQUEST],
            context: {
              name: 'ID_GENERATION_ERROR',
              error: e,
            },
          });
          closeConnection(Server.errors.BAD_REQUEST);
          return;
        }
        debug('handshaking client "%s"', id);
        try {
          var transport = this.createTransport(transportName, req);
          if (transportName === 'polling') {
            transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
            transport.httpCompression = this.opts.httpCompression;
          } else if (transportName === 'websocket') {
            transport.perMessageDeflate = this.opts.perMessageDeflate;
          }
        } catch (e) {
          debug('error handshaking to transport "%s"', transportName);
          this.emit('connection_error', {
            req,
            code: Server.errors.BAD_REQUEST,
            message: Server.errorMessages[Server.errors.BAD_REQUEST],
            context: {
              name: 'TRANSPORT_HANDSHAKE_ERROR',
              error: e,
            },
          });
          closeConnection(Server.errors.BAD_REQUEST);
          return;
        }
        const socket = new socket_1.Socket(id, this, transport, req, protocol);
        transport.on('headers', (headers, req) => {
          const isInitialRequest = !req._query.sid;
          if (isInitialRequest) {
            if (this.opts.cookie) {
              headers['Set-Cookie'] = [
                // @ts-ignore
                (0, cookie_1.serialize)(this.opts.cookie.name, id, this.opts.cookie),
              ];
            }
            this.emit('initial_headers', headers, req);
          }
          this.emit('headers', headers, req);
        });
        transport.onRequest(req);
        this.clients[id] = socket;
        this.clientsCount++;
        socket.once('close', () => {
          delete this.clients[id];
          this.clientsCount--;
        });
        this.emit('connection', socket);
        return transport;
      }
      async onWebTransportSession(session) {
        const timeout = setTimeout(() => {
          debug('the client failed to establish a bidirectional stream in the given period');
          session.close();
        }, this.opts.upgradeTimeout);
        const streamReader = session.incomingBidirectionalStreams.getReader();
        const result = await streamReader.read();
        if (result.done) {
          debug('session is closed');
          return;
        }
        const stream = result.value;
        const transformStream = (0, engine_io_parser_1.createPacketDecoderStream)(
          this.opts.maxHttpBufferSize,
          'nodebuffer',
        );
        const reader = stream.readable.pipeThrough(transformStream).getReader();
        // reading the first packet of the stream
        const { value, done } = await reader.read();
        if (done) {
          debug('stream is closed');
          return;
        }
        clearTimeout(timeout);
        if (value.type !== 'open') {
          debug('invalid WebTransport handshake');
          return session.close();
        }
        if (value.data === undefined) {
          const transport = new webtransport_1.WebTransport(session, stream, reader);
          // note: we cannot use "this.generateId()", because there is no "req" argument
          const id = base64id.generateId();
          debug('handshaking client "%s" (WebTransport)', id);
          const socket = new socket_1.Socket(id, this, transport, null, 4);
          this.clients[id] = socket;
          this.clientsCount++;
          socket.once('close', () => {
            delete this.clients[id];
            this.clientsCount--;
          });
          this.emit('connection', socket);
          return;
        }
        const sid = parseSessionId(value.data);
        if (!sid) {
          debug('invalid WebTransport handshake');
          return session.close();
        }
        const client = this.clients[sid];
        if (!client) {
          debug('upgrade attempt for closed client');
          session.close();
        } else if (client.upgrading) {
          debug('transport has already been trying to upgrade');
          session.close();
        } else if (client.upgraded) {
          debug('transport had already been upgraded');
          session.close();
        } else {
          debug('upgrading existing transport');
          const transport = new webtransport_1.WebTransport(session, stream, reader);
          client._maybeUpgrade(transport);
        }
      }
    }
    exports.BaseServer = BaseServer;
    /**
     * Protocol errors mappings.
     */
    BaseServer.errors = {
      UNKNOWN_TRANSPORT: 0,
      UNKNOWN_SID: 1,
      BAD_HANDSHAKE_METHOD: 2,
      BAD_REQUEST: 3,
      FORBIDDEN: 4,
      UNSUPPORTED_PROTOCOL_VERSION: 5,
    };
    BaseServer.errorMessages = {
      0: 'Transport unknown',
      1: 'Session ID unknown',
      2: 'Bad handshake method',
      3: 'Bad request',
      4: 'Forbidden',
      5: 'Unsupported protocol version',
    };
    /**
     * Exposes a subset of the http.ServerResponse interface, in order to be able to apply the middlewares to an upgrade
     * request.
     *
     * @see https://nodejs.org/api/http.html#class-httpserverresponse
     */
    class WebSocketResponse {
      constructor(req, socket) {
        this.req = req;
        this.socket = socket;
        // temporarily store the response headers on the req object (see the "headers" event)
        req[kResponseHeaders] = {};
      }
      setHeader(name, value) {
        this.req[kResponseHeaders][name] = value;
      }
      getHeader(name) {
        return this.req[kResponseHeaders][name];
      }
      removeHeader(name) {
        delete this.req[kResponseHeaders][name];
      }
      write() {}
      writeHead() {}
      end() {
        // we could return a proper error code, but the WebSocket client will emit an "error" event anyway.
        this.socket.destroy();
      }
    }
    /**
     * An Engine.IO server based on Node.js built-in HTTP server and the `ws` package for WebSocket connections.
     */
    class Server extends BaseServer {
      /**
       * Initialize websocket server
       *
       * @protected
       */
      init() {
        if (!~this.opts.transports.indexOf('websocket')) return;
        if (this.ws) this.ws.close();
        this.ws = new this.opts.wsEngine({
          noServer: true,
          clientTracking: false,
          perMessageDeflate: this.opts.perMessageDeflate,
          maxPayload: this.opts.maxHttpBufferSize,
        });
        if (typeof this.ws.on === 'function') {
          this.ws.on('headers', (headersArray, req) => {
            // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)
            // we could also try to parse the array and then sync the values, but that will be error-prone
            const additionalHeaders = req[kResponseHeaders] || {};
            delete req[kResponseHeaders];
            const isInitialRequest = !req._query.sid;
            if (isInitialRequest) {
              this.emit('initial_headers', additionalHeaders, req);
            }
            this.emit('headers', additionalHeaders, req);
            debug('writing headers: %j', additionalHeaders);
            Object.keys(additionalHeaders).forEach(key => {
              headersArray.push(`${key}: ${additionalHeaders[key]}`);
            });
          });
        }
      }
      cleanup() {
        if (this.ws) {
          debug('closing webSocketServer');
          this.ws.close();
          // don't delete this.ws because it can be used again if the http server starts listening again
        }
      }
      /**
       * Prepares a request by processing the query string.
       *
       * @private
       */
      prepare(req) {
        // try to leverage pre-existing `req._query` (e.g: from connect)
        if (!req._query) {
          req._query = ~req.url.indexOf('?') ? qs.parse((0, url_1.parse)(req.url).query) : {};
        }
      }
      createTransport(transportName, req) {
        return new transports_1.default[transportName](req);
      }
      /**
       * Handles an Engine.IO HTTP request.
       *
       * @param {EngineRequest} req
       * @param {ServerResponse} res
       */
      handleRequest(req, res) {
        debug('handling "%s" http request "%s"', req.method, req.url);
        this.prepare(req);
        req.res = res;
        const callback = (errorCode, errorContext) => {
          if (errorCode !== undefined) {
            this.emit('connection_error', {
              req,
              code: errorCode,
              message: Server.errorMessages[errorCode],
              context: errorContext,
            });
            abortRequest(res, errorCode, errorContext);
            return;
          }
          if (req._query.sid) {
            debug('setting new request for existing client');
            this.clients[req._query.sid].transport.onRequest(req);
          } else {
            const closeConnection = (errorCode, errorContext) => abortRequest(res, errorCode, errorContext);
            this.handshake(req._query.transport, req, closeConnection);
          }
        };
        this._applyMiddlewares(req, res, err => {
          if (err) {
            callback(Server.errors.BAD_REQUEST, { name: 'MIDDLEWARE_FAILURE' });
          } else {
            this.verify(req, false, callback);
          }
        });
      }
      /**
       * Handles an Engine.IO HTTP Upgrade.
       */
      handleUpgrade(req, socket, upgradeHead) {
        this.prepare(req);
        const res = new WebSocketResponse(req, socket);
        const callback = (errorCode, errorContext) => {
          if (errorCode !== undefined) {
            this.emit('connection_error', {
              req,
              code: errorCode,
              message: Server.errorMessages[errorCode],
              context: errorContext,
            });
            abortUpgrade(socket, errorCode, errorContext);
            return;
          }
          const head = Buffer.from(upgradeHead);
          upgradeHead = null;
          // some middlewares (like express-session) wait for the writeHead() call to flush their headers
          // see https://github.com/expressjs/session/blob/1010fadc2f071ddf2add94235d72224cf65159c6/index.js#L220-L244
          res.writeHead();
          // delegate to ws
          this.ws.handleUpgrade(req, socket, head, websocket => {
            this.onWebSocket(req, socket, websocket);
          });
        };
        this._applyMiddlewares(req, res, err => {
          if (err) {
            callback(Server.errors.BAD_REQUEST, { name: 'MIDDLEWARE_FAILURE' });
          } else {
            this.verify(req, true, callback);
          }
        });
      }
      /**
       * Called upon a ws.io connection.
       *
       * @param {ws.Socket} websocket
       * @private
       */
      onWebSocket(req, socket, websocket) {
        websocket.on('error', onUpgradeError);
        if (
          transports_1.default[req._query.transport] !== undefined &&
          !transports_1.default[req._query.transport].prototype.handlesUpgrades
        ) {
          debug('transport doesnt handle upgraded requests');
          websocket.close();
          return;
        }
        // get client id
        const id = req._query.sid;
        // keep a reference to the ws.Socket
        req.websocket = websocket;
        if (id) {
          const client = this.clients[id];
          if (!client) {
            debug('upgrade attempt for closed client');
            websocket.close();
          } else if (client.upgrading) {
            debug('transport has already been trying to upgrade');
            websocket.close();
          } else if (client.upgraded) {
            debug('transport had already been upgraded');
            websocket.close();
          } else {
            debug('upgrading existing transport');
            // transport error handling takes over
            websocket.removeListener('error', onUpgradeError);
            const transport = this.createTransport(req._query.transport, req);
            transport.perMessageDeflate = this.opts.perMessageDeflate;
            client._maybeUpgrade(transport);
          }
        } else {
          const closeConnection = (errorCode, errorContext) => abortUpgrade(socket, errorCode, errorContext);
          this.handshake(req._query.transport, req, closeConnection);
        }
        function onUpgradeError() {
          debug('websocket error before upgrade');
          // websocket.close() not needed
        }
      }
      /**
       * Captures upgrade requests for a http.Server.
       *
       * @param {http.Server} server
       * @param {Object} options
       */
      attach(server, options = {}) {
        const path = this._computePath(options);
        const destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000;
        function check(req) {
          // TODO use `path === new URL(...).pathname` in the next major release (ref: https://nodejs.org/api/url.html)
          return path === req.url.slice(0, path.length);
        }
        // cache and clean up listeners
        const listeners = server.listeners('request').slice(0);
        server.removeAllListeners('request');
        server.on('close', this.close.bind(this));
        server.on('listening', this.init.bind(this));
        // add request handler
        server.on('request', (req, res) => {
          if (check(req)) {
            debug('intercepting request for path "%s"', path);
            this.handleRequest(req, res);
          } else {
            let i = 0;
            const l = listeners.length;
            for (; i < l; i++) {
              listeners[i].call(server, req, res);
            }
          }
        });
        if (~this.opts.transports.indexOf('websocket')) {
          server.on('upgrade', (req, socket, head) => {
            if (check(req)) {
              this.handleUpgrade(req, socket, head);
            } else if (options.destroyUpgrade !== false) {
              // default node behavior is to disconnect when no handlers
              // but by adding a handler, we prevent that
              // and if no eio thing handles the upgrade
              // then the socket needs to die!
              setTimeout(function () {
                // @ts-ignore
                if (socket.writable && socket.bytesWritten <= 0) {
                  socket.on('error', e => {
                    debug('error while destroying upgrade: %s', e.message);
                  });
                  return socket.end();
                }
              }, destroyUpgradeTimeout);
            }
          });
        }
      }
    }
    exports.Server = Server;
    /**
     * Close the HTTP long-polling request
     *
     * @param res - the response object
     * @param errorCode - the error code
     * @param errorContext - additional error context
     *
     * @private
     */
    function abortRequest(res, errorCode, errorContext) {
      const statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
      const message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
      res.writeHead(statusCode, { 'Content-Type': 'application/json' });
      res.end(
        JSON.stringify({
          code: errorCode,
          message,
        }),
      );
    }
    /**
     * Close the WebSocket connection
     *
     * @param {net.Socket} socket
     * @param {string} errorCode - the error code
     * @param {object} errorContext - additional error context
     */
    function abortUpgrade(socket, errorCode, errorContext = {}) {
      socket.on('error', () => {
        debug('ignoring error from closed connection');
      });
      if (socket.writable) {
        const message = errorContext.message || Server.errorMessages[errorCode];
        const length = Buffer.byteLength(message);
        socket.write(
          'HTTP/1.1 400 Bad Request\r\n' +
            'Connection: close\r\n' +
            'Content-type: text/html\r\n' +
            'Content-Length: ' +
            length +
            '\r\n' +
            '\r\n' +
            message,
        );
      }
      socket.destroy();
    }
    /* eslint-disable */
    /**
     * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354
     *
     * True if val contains an invalid field-vchar
     *  field-value    = *( field-content / obs-fold )
     *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     *  field-vchar    = VCHAR / obs-text
     *
     * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
     * so take care when making changes to the implementation so that the source
     * code size does not exceed v8's default max_inlined_source_size setting.
     **/
    // prettier-ignore
    const validHdrChars = [
    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, // 0 - 15
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 32 - 47
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 48 - 63
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 80 - 95
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, // 112 - 127
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 128 ...
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255
];
    function checkInvalidHeaderChar(val) {
      val += '';
      if (val.length < 1) return false;
      if (!validHdrChars[val.charCodeAt(0)]) {
        debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
        return true;
      }
      if (val.length < 2) return false;
      if (!validHdrChars[val.charCodeAt(1)]) {
        debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
        return true;
      }
      if (val.length < 3) return false;
      if (!validHdrChars[val.charCodeAt(2)]) {
        debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
        return true;
      }
      if (val.length < 4) return false;
      if (!validHdrChars[val.charCodeAt(3)]) {
        debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
        return true;
      }
      for (let i = 4; i < val.length; ++i) {
        if (!validHdrChars[val.charCodeAt(i)]) {
          debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
          return true;
        }
      }
      return false;
    }

    /***/
  },

  /***/ 5300: /***/ (__unused_webpack_module, exports) => {
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = '';
      let commentSep = '';
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== 'space' && token.type !== 'newline' && token.type !== 'comma')
            onError(
              token.offset,
              'MISSING_CHAR',
              'Tags and anchors must be separated from the next token by white space',
            );
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== 'comment' && token.type !== 'newline') {
            onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
          }
          tab = null;
        }
        switch (token.type) {
          case 'space':
            // At the doc level, tabs at line start may be parsed
            // as leading white space rather than indentation.
            // In a flow collection, only the parser handles indent.
            if (
              !flow &&
              (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&
              token.source.includes('\t')
            ) {
              tab = token;
            }
            hasSpace = true;
            break;
          case 'comment': {
            if (!hasSpace)
              onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
            const cb = token.source.substring(1) || ' ';
            if (!comment) comment = cb;
            else comment += commentSep + cb;
            commentSep = '';
            atNewline = false;
            break;
          }
          case 'newline':
            if (atNewline) {
              if (comment) comment += token.source;
              else if (!found || indicator !== 'seq-item-ind') spaceBefore = true;
            } else commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag) newlineAfterProp = token;
            hasSpace = true;
            break;
          case 'anchor':
            if (anchor) onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
            if (token.source.endsWith(':'))
              onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
            anchor = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case 'tag': {
            if (tag) onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
            tag = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            // Could here handle preceding comments differently
            if (anchor || tag)
              onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
            if (found) onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
            found = token;
            atNewline = indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';
            hasSpace = false;
            break;
          case 'comma':
            if (flow) {
              if (comma) onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (
        reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== '')
      ) {
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
      }
      if (
        tab &&
        ((atNewline && tab.indent <= parentIndent) || next?.type === 'block-map' || next?.type === 'block-seq')
      )
        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end,
      };
    }

    exports.resolveProps = resolveProps;

    /***/
  },

  /***/ 5359: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var Pair = __webpack_require__(6544);
    var YAMLMap = __webpack_require__(8741);

    class YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key)) pair = key;
        else if (key && typeof key === 'object' && 'key' in key && 'value' in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev) this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? (identity.isScalar(pair.key) ? pair.key.value : pair.key) : pair;
      }
      set(key, value) {
        if (typeof value !== 'boolean')
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else throw new Error('Set items must all have null values');
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === 'function') value = replacer.call(iterable, value, value);
            set.items.push(Pair.createPair(value, null, ctx));
          }
        return set;
      }
    }
    YAMLSet.tag = 'tag:yaml.org,2002:set';
    const set = {
      collection: 'map',
      identify: value => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: 'tag:yaml.org,2002:set',
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map, onError) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(true)) return Object.assign(new YAMLSet(), map);
          else onError('Set items must all have null values');
        } else onError('Expected a mapping for this tag');
        return map;
      },
    };

    exports.YAMLSet = YAMLSet;
    exports.set = set;

    /***/
  },

  /***/ 5434: /***/ module => {
    /**
     * negotiator
     * Copyright(c) 2012 Isaac Z. Schlueter
     * Copyright(c) 2014 Federico Romero
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module exports.
     * @public
     */

    module.exports = preferredMediaTypes;
    module.exports.preferredMediaTypes = preferredMediaTypes;

    /**
     * Module variables.
     * @private
     */

    var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;

    /**
     * Parse the Accept header.
     * @private
     */

    function parseAccept(accept) {
      var accepts = splitMediaTypes(accept);

      for (var i = 0, j = 0; i < accepts.length; i++) {
        var mediaType = parseMediaType(accepts[i].trim(), i);

        if (mediaType) {
          accepts[j++] = mediaType;
        }
      }

      // trim accepts
      accepts.length = j;

      return accepts;
    }

    /**
     * Parse a media type from the Accept header.
     * @private
     */

    function parseMediaType(str, i) {
      var match = simpleMediaTypeRegExp.exec(str);
      if (!match) return null;

      var params = Object.create(null);
      var q = 1;
      var subtype = match[2];
      var type = match[1];

      if (match[3]) {
        var kvps = splitParameters(match[3]).map(splitKeyValuePair);

        for (var j = 0; j < kvps.length; j++) {
          var pair = kvps[j];
          var key = pair[0].toLowerCase();
          var val = pair[1];

          // get the value, unwrapping quotes
          var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;

          if (key === 'q') {
            q = parseFloat(value);
            break;
          }

          // store parameter
          params[key] = value;
        }
      }

      return {
        type: type,
        subtype: subtype,
        params: params,
        q: q,
        i: i,
      };
    }

    /**
     * Get the priority of a media type.
     * @private
     */

    function getMediaTypePriority(type, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };

      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(type, accepted[i], index);

        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }

      return priority;
    }

    /**
     * Get the specificity of the media type.
     * @private
     */

    function specify(type, spec, index) {
      var p = parseMediaType(type);
      var s = 0;

      if (!p) {
        return null;
      }

      if (spec.type.toLowerCase() == p.type.toLowerCase()) {
        s |= 4;
      } else if (spec.type != '*') {
        return null;
      }

      if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
        s |= 2;
      } else if (spec.subtype != '*') {
        return null;
      }

      var keys = Object.keys(spec.params);
      if (keys.length > 0) {
        if (
          keys.every(function (k) {
            return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
          })
        ) {
          s |= 1;
        } else {
          return null;
        }
      }

      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s,
      };
    }

    /**
     * Get the preferred media types from an Accept header.
     * @public
     */

    function preferredMediaTypes(accept, provided) {
      // RFC 2616 sec 14.2: no header = */*
      var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

      if (!provided) {
        // sorted list of all types
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
      }

      var priorities = provided.map(function getPriority(type, index) {
        return getMediaTypePriority(type, accepts, index);
      });

      // sorted list of accepted types
      return priorities
        .filter(isQuality)
        .sort(compareSpecs)
        .map(function getType(priority) {
          return provided[priorities.indexOf(priority)];
        });
    }

    /**
     * Compare two specs.
     * @private
     */

    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }

    /**
     * Get full type string.
     * @private
     */

    function getFullType(spec) {
      return spec.type + '/' + spec.subtype;
    }

    /**
     * Check if a spec has any quality.
     * @private
     */

    function isQuality(spec) {
      return spec.q > 0;
    }

    /**
     * Count the number of quotes in a string.
     * @private
     */

    function quoteCount(string) {
      var count = 0;
      var index = 0;

      while ((index = string.indexOf('"', index)) !== -1) {
        count++;
        index++;
      }

      return count;
    }

    /**
     * Split a key value pair.
     * @private
     */

    function splitKeyValuePair(str) {
      var index = str.indexOf('=');
      var key;
      var val;

      if (index === -1) {
        key = str;
      } else {
        key = str.substr(0, index);
        val = str.substr(index + 1);
      }

      return [key, val];
    }

    /**
     * Split an Accept header into media types.
     * @private
     */

    function splitMediaTypes(accept) {
      var accepts = accept.split(',');

      for (var i = 1, j = 0; i < accepts.length; i++) {
        if (quoteCount(accepts[j]) % 2 == 0) {
          accepts[++j] = accepts[i];
        } else {
          accepts[j] += ',' + accepts[i];
        }
      }

      // trim accepts
      accepts.length = j + 1;

      return accepts;
    }

    /**
     * Split a string of parameters.
     * @private
     */

    function splitParameters(str) {
      var parameters = str.split(';');

      for (var i = 1, j = 0; i < parameters.length; i++) {
        if (quoteCount(parameters[j]) % 2 == 0) {
          parameters[++j] = parameters[i];
        } else {
          parameters[j] += ';' + parameters[i];
        }
      }

      // trim parameters
      parameters.length = j + 1;

      for (var i = 0; i < parameters.length; i++) {
        parameters[i] = parameters[i].trim();
      }

      return parameters;
    }

    /***/
  },

  /***/ 5552: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.decodePacket = void 0;
    const commons_js_1 = __webpack_require__(7758);
    const decodePacket = (encodedPacket, binaryType) => {
      if (typeof encodedPacket !== 'string') {
        return {
          type: 'message',
          data: mapBinary(encodedPacket, binaryType),
        };
      }
      const type = encodedPacket.charAt(0);
      if (type === 'b') {
        const buffer = Buffer.from(encodedPacket.substring(1), 'base64');
        return {
          type: 'message',
          data: mapBinary(buffer, binaryType),
        };
      }
      if (!commons_js_1.PACKET_TYPES_REVERSE[type]) {
        return commons_js_1.ERROR_PACKET;
      }
      return encodedPacket.length > 1
        ? {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
            data: encodedPacket.substring(1),
          }
        : {
            type: commons_js_1.PACKET_TYPES_REVERSE[type],
          };
    };
    exports.decodePacket = decodePacket;
    const mapBinary = (data, binaryType) => {
      switch (binaryType) {
        case 'arraybuffer':
          if (data instanceof ArrayBuffer) {
            // from WebSocket & binaryType "arraybuffer"
            return data;
          } else if (Buffer.isBuffer(data)) {
            // from HTTP long-polling
            return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
          } else {
            // from WebTransport (Uint8Array)
            return data.buffer;
          }
        case 'nodebuffer':
        default:
          if (Buffer.isBuffer(data)) {
            // from HTTP long-polling or WebSocket & binaryType "nodebuffer" (default)
            return data;
          } else {
            // from WebTransport (Uint8Array)
            return Buffer.from(data);
          }
      }
    };

    /***/
  },

  /***/ 5651: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const { tokenChars } = __webpack_require__(1610);

    /**
     * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
     *
     * @param {String} header The field value of the header
     * @return {Set} The subprotocol names
     * @public
     */
    function parse(header) {
      const protocols = new Set();
      let start = -1;
      let end = -1;
      let i = 0;

      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);

        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 0x2c /* ',' */) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }

          if (end === -1) end = i;

          const protocol = header.slice(start, end);

          if (protocols.has(protocol)) {
            throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
          }

          protocols.add(protocol);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }

      if (start === -1 || end !== -1) {
        throw new SyntaxError('Unexpected end of input');
      }

      const protocol = header.slice(start, i);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      return protocols;
    }

    module.exports = { parse };

    /***/
  },

  /***/ 5692: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('https');

    /***/
  },

  /***/ 5718: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Polling = void 0;
    const transport_1 = __webpack_require__(2879);
    const zlib_1 = __webpack_require__(3106);
    const accepts = __webpack_require__(9);
    const debug_1 = __webpack_require__(1106);
    const debug = (0, debug_1.default)('engine:polling');
    const compressionMethods = {
      gzip: zlib_1.createGzip,
      deflate: zlib_1.createDeflate,
    };
    class Polling extends transport_1.Transport {
      /**
       * HTTP polling constructor.
       */
      constructor(req) {
        super(req);
        this.closeTimeout = 30 * 1000;
      }
      /**
       * Transport name
       */
      get name() {
        return 'polling';
      }
      /**
       * Overrides onRequest.
       *
       * @param {EngineRequest} req
       * @package
       */
      onRequest(req) {
        const res = req.res;
        // remove the reference to the ServerResponse object (as the first request of the session is kept in memory by default)
        req.res = null;
        if ('GET' === req.method) {
          this.onPollRequest(req, res);
        } else if ('POST' === req.method) {
          this.onDataRequest(req, res);
        } else {
          res.writeHead(500);
          res.end();
        }
      }
      /**
       * The client sends a request awaiting for us to send data.
       *
       * @private
       */
      onPollRequest(req, res) {
        if (this.req) {
          debug('request overlap');
          // assert: this.res, '.req and .res should be (un)set together'
          this.onError('overlap from client');
          res.writeHead(400);
          res.end();
          return;
        }
        debug('setting request');
        this.req = req;
        this.res = res;
        const onClose = () => {
          this.onError('poll connection closed prematurely');
        };
        const cleanup = () => {
          req.removeListener('close', onClose);
          this.req = this.res = null;
        };
        req.cleanup = cleanup;
        req.on('close', onClose);
        this.writable = true;
        this.emit('ready');
        // if we're still writable but had a pending close, trigger an empty send
        if (this.writable && this.shouldClose) {
          debug('triggering empty send to append close packet');
          this.send([{ type: 'noop' }]);
        }
      }
      /**
       * The client sends a request with data.
       *
       * @private
       */
      onDataRequest(req, res) {
        if (this.dataReq) {
          // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
          this.onError('data request overlap from client');
          res.writeHead(400);
          res.end();
          return;
        }
        const isBinary = 'application/octet-stream' === req.headers['content-type'];
        if (isBinary && this.protocol === 4) {
          return this.onError('invalid content');
        }
        this.dataReq = req;
        this.dataRes = res;
        let chunks = isBinary ? Buffer.concat([]) : '';
        const cleanup = () => {
          req.removeListener('data', onData);
          req.removeListener('end', onEnd);
          req.removeListener('close', onClose);
          this.dataReq = this.dataRes = chunks = null;
        };
        const onClose = () => {
          cleanup();
          this.onError('data request connection closed prematurely');
        };
        const onData = data => {
          let contentLength;
          if (isBinary) {
            chunks = Buffer.concat([chunks, data]);
            contentLength = chunks.length;
          } else {
            chunks += data;
            contentLength = Buffer.byteLength(chunks);
          }
          if (contentLength > this.maxHttpBufferSize) {
            res.writeHead(413).end();
            cleanup();
          }
        };
        const onEnd = () => {
          this.onData(chunks);
          const headers = {
            // text/html is required instead of text/plain to avoid an
            // unwanted download dialog on certain user-agents (GH-43)
            'Content-Type': 'text/html',
            'Content-Length': '2',
          };
          res.writeHead(200, this.headers(req, headers));
          res.end('ok');
          cleanup();
        };
        req.on('close', onClose);
        if (!isBinary) req.setEncoding('utf8');
        req.on('data', onData);
        req.on('end', onEnd);
      }
      /**
       * Processes the incoming data payload.
       *
       * @param data - encoded payload
       * @protected
       */
      onData(data) {
        debug('received "%s"', data);
        const callback = packet => {
          if ('close' === packet.type) {
            debug('got xhr close packet');
            this.onClose();
            return false;
          }
          this.onPacket(packet);
        };
        if (this.protocol === 3) {
          this.parser.decodePayload(data, callback);
        } else {
          this.parser.decodePayload(data).forEach(callback);
        }
      }
      /**
       * Overrides onClose.
       *
       * @private
       */
      onClose() {
        if (this.writable) {
          // close pending poll request
          this.send([{ type: 'noop' }]);
        }
        super.onClose();
      }
      send(packets) {
        this.writable = false;
        if (this.shouldClose) {
          debug('appending close packet to payload');
          packets.push({ type: 'close' });
          this.shouldClose();
          this.shouldClose = null;
        }
        const doWrite = data => {
          const compress = packets.some(packet => {
            return packet.options && packet.options.compress;
          });
          this.write(data, { compress });
        };
        if (this.protocol === 3) {
          this.parser.encodePayload(packets, this.supportsBinary, doWrite);
        } else {
          this.parser.encodePayload(packets, doWrite);
        }
      }
      /**
       * Writes data as response to poll request.
       *
       * @param {String} data
       * @param {Object} options
       * @private
       */
      write(data, options) {
        debug('writing "%s"', data);
        this.doWrite(data, options, () => {
          this.req.cleanup();
          this.emit('drain');
        });
      }
      /**
       * Performs the write.
       *
       * @protected
       */
      doWrite(data, options, callback) {
        // explicit UTF-8 is required for pages not served under utf
        const isString = typeof data === 'string';
        const contentType = isString ? 'text/plain; charset=UTF-8' : 'application/octet-stream';
        const headers = {
          'Content-Type': contentType,
        };
        const respond = data => {
          headers['Content-Length'] = 'string' === typeof data ? Buffer.byteLength(data) : data.length;
          this.res.writeHead(200, this.headers(this.req, headers));
          this.res.end(data);
          callback();
        };
        if (!this.httpCompression || !options.compress) {
          respond(data);
          return;
        }
        const len = isString ? Buffer.byteLength(data) : data.length;
        if (len < this.httpCompression.threshold) {
          respond(data);
          return;
        }
        const encoding = accepts(this.req).encodings(['gzip', 'deflate']);
        if (!encoding) {
          respond(data);
          return;
        }
        this.compress(data, encoding, (err, data) => {
          if (err) {
            this.res.writeHead(500);
            this.res.end();
            callback(err);
            return;
          }
          headers['Content-Encoding'] = encoding;
          respond(data);
        });
      }
      /**
       * Compresses data.
       *
       * @private
       */
      compress(data, encoding, callback) {
        debug('compressing');
        const buffers = [];
        let nread = 0;
        compressionMethods[encoding](this.httpCompression)
          .on('error', callback)
          .on('data', function (chunk) {
            buffers.push(chunk);
            nread += chunk.length;
          })
          .on('end', function () {
            callback(null, Buffer.concat(buffers, nread));
          })
          .end(data);
      }
      /**
       * Closes the transport.
       *
       * @private
       */
      doClose(fn) {
        debug('closing');
        let closeTimeoutTimer;
        if (this.dataReq) {
          debug('aborting ongoing data request');
          this.dataReq.destroy();
        }
        const onClose = () => {
          clearTimeout(closeTimeoutTimer);
          fn();
          this.onClose();
        };
        if (this.writable) {
          debug('transport writable - closing right away');
          this.send([{ type: 'close' }]);
          onClose();
        } else if (this.discarded) {
          debug('transport discarded - closing right away');
          onClose();
        } else {
          debug('transport not writable - buffering orderly close');
          this.shouldClose = onClose;
          closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
        }
      }
      /**
       * Returns headers for a response.
       *
       * @param {http.IncomingMessage} req
       * @param {Object} headers - extra headers
       * @private
       */
      headers(req, headers = {}) {
        // prevent XSS warnings on IE
        // https://github.com/LearnBoost/socket.io/pull/1333
        const ua = req.headers['user-agent'];
        if (ua && (~ua.indexOf(';MSIE') || ~ua.indexOf('Trident/'))) {
          headers['X-XSS-Protection'] = '0';
        }
        headers['cache-control'] = 'no-store';
        this.emit('headers', headers, req);
        return headers;
      }
    }
    exports.Polling = Polling;

    /***/
  },

  /***/ 5824: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const { tokenChars } = __webpack_require__(1610);

    /**
     * Adds an offer to the map of extension offers or a parameter to the map of
     * parameters.
     *
     * @param {Object} dest The map of extension offers or parameters
     * @param {String} name The extension or parameter name
     * @param {(Object|Boolean|String)} elem The extension parameters or the
     *     parameter value
     * @private
     */
    function push(dest, name, elem) {
      if (dest[name] === undefined) dest[name] = [elem];
      else dest[name].push(elem);
    }

    /**
     * Parses the `Sec-WebSocket-Extensions` header into an object.
     *
     * @param {String} header The field value of the header
     * @return {Object} The parsed object
     * @public
     */
    function parse(header) {
      const offers = Object.create(null);
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;

      for (; i < header.length; i++) {
        code = header.charCodeAt(i);

        if (extensionName === undefined) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }

            if (end === -1) end = i;
            const name = header.slice(start, end);
            if (code === 0x2c) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }

            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === undefined) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 0x20 || code === 0x09) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 0x3b || code === 0x2c) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }

            if (end === -1) end = i;
            push(params, header.slice(start, end), true);
            if (code === 0x2c) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = undefined;
            }

            start = end = -1;
          } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          //
          // The value of a quoted-string after unescaping must conform to the
          // token ABNF, so only token characters are valid.
          // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
          //
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 0x22 /* '"' */ && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 0x5c /* '\' */) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
            if (end === -1) end = i;
          } else if (code === 0x3b || code === 0x2c) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }

            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, '');
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 0x2c) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = undefined;
            }

            paramName = undefined;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }

      if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
        throw new SyntaxError('Unexpected end of input');
      }

      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === undefined) {
        push(offers, token, params);
      } else {
        if (paramName === undefined) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ''));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }

      return offers;
    }

    /**
     * Builds the `Sec-WebSocket-Extensions` header field value.
     *
     * @param {Object} extensions The map of extensions and parameters to format
     * @return {String} A string representing the given object
     * @public
     */
    function format(extensions) {
      return Object.keys(extensions)
        .map(extension => {
          let configurations = extensions[extension];
          if (!Array.isArray(configurations)) configurations = [configurations];
          return configurations
            .map(params => {
              return [extension]
                .concat(
                  Object.keys(params).map(k => {
                    let values = params[k];
                    if (!Array.isArray(values)) values = [values];
                    return values.map(v => (v === true ? k : `${k}=${v}`)).join('; ');
                  }),
                )
                .join('; ');
            })
            .join(', ');
        })
        .join(', ');
    }

    module.exports = { format, parse };

    /***/
  },

  /***/ 5838: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.protocol =
      exports.Transport =
      exports.Socket =
      exports.uServer =
      exports.parser =
      exports.transports =
      exports.Server =
        void 0;
    exports.listen = listen;
    exports.attach = attach;
    const http_1 = __webpack_require__(8611);
    const server_1 = __webpack_require__(5287);
    Object.defineProperty(exports, 'Server', {
      enumerable: true,
      get: function () {
        return server_1.Server;
      },
    });
    const index_1 = __webpack_require__(8873);
    exports.transports = index_1.default;
    const parser = __webpack_require__(2680);
    exports.parser = parser;
    var userver_1 = __webpack_require__(2350);
    Object.defineProperty(exports, 'uServer', {
      enumerable: true,
      get: function () {
        return userver_1.uServer;
      },
    });
    var socket_1 = __webpack_require__(7773);
    Object.defineProperty(exports, 'Socket', {
      enumerable: true,
      get: function () {
        return socket_1.Socket;
      },
    });
    var transport_1 = __webpack_require__(2879);
    Object.defineProperty(exports, 'Transport', {
      enumerable: true,
      get: function () {
        return transport_1.Transport;
      },
    });
    exports.protocol = parser.protocol;
    /**
     * Creates an http.Server exclusively used for WS upgrades.
     *
     * @param {Number} port
     * @param {Function} callback
     * @param {Object} options
     * @return {Server} websocket.io server
     */
    function listen(port, options, fn) {
      if ('function' === typeof options) {
        fn = options;
        options = {};
      }
      const server = (0, http_1.createServer)(function (req, res) {
        res.writeHead(501);
        res.end('Not Implemented');
      });
      // create engine server
      const engine = attach(server, options);
      engine.httpServer = server;
      server.listen(port, fn);
      return engine;
    }
    /**
     * Captures upgrade requests for a http.Server.
     *
     * @param {http.Server} server
     * @param {Object} options
     * @return {Server} engine server
     */
    function attach(server, options) {
      const engine = new server_1.Server(options);
      engine.attach(server, options);
      return engine;
    }

    /***/
  },

  /***/ 5920: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var createNode = __webpack_require__(6421);
    var identity = __webpack_require__(7182);
    var Node = __webpack_require__(4176);

    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map(),
      });
    }
    // Type guard is intentionally a little wrong so as to be more useful,
    // as it does not cover untypable empty non-string iterables (e.g. []).
    const isEmptyPath = path => path == null || (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
    class Collection extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true,
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema) copy.schema = schema;
        copy.items = copy.items.map(it => (identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it));
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path)) this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (identity.isCollection(node)) node.addIn(rest, value);
          else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0) return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node)) return node.deleteIn(rest);
        else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0) return !keepScalar && identity.isScalar(node) ? node.value : node;
        else return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every(node => {
          if (!identity.isPair(node)) return false;
          const n = node.value;
          return (
            n == null ||
            (allowScalar && identity.isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag)
          );
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0) return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node)) node.setIn(rest, value);
          else if (node === undefined && this.schema) this.set(key, collectionFromPath(this.schema, rest, value));
          else throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    }

    exports.Collection = Collection;
    exports.collectionFromPath = collectionFromPath;
    exports.isEmptyPath = isEmptyPath;

    /***/
  },

  /***/ 5985: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var Pair = __webpack_require__(6544);
    var YAMLMap = __webpack_require__(8741);
    var YAMLSeq = __webpack_require__(2016);
    var resolveEnd = __webpack_require__(191);
    var resolveProps = __webpack_require__(5300);
    var utilContainsNewline = __webpack_require__(1120);
    var utilMapIncludes = __webpack_require__(4752);

    const blockMsg = 'Block collections are not allowed within flow collections';
    const isBlock = token => token && (token.type === 'block-map' || token.type === 'block-seq');
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === '{';
      const fcName = isMap ? 'flow map' : 'flow sequence';
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot) ctx.atRoot = false;
      if (ctx.atKey) ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: 'explicit-key-ind',
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false,
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i === 0 && props.comma) onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment) coll.comment += '\n' + props.comment;
              else coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key, // checked by containsNewline()
              'MULTILINE_IMPLICIT_KEY',
              'Implicit keys of flow sequence pairs need to be on a single line',
            );
        }
        if (i === 0) {
          if (props.comma) onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma) onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = '';
            loop: for (const st of start) {
              switch (st.type) {
                case 'comma':
                case 'space':
                  break;
                case 'comment':
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev)) prev = prev.value ?? prev.key;
              if (prev.comment) prev.comment += '\n' + prevItemComment;
              else prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep && !props.found) {
          // item is a value in a seq
          // → key & sep are empty, start does not include ? or :
          const valueNode = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value)) onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        } else {
          // item is a key+value pair
          // key value
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key
            ? composeNode(ctx, key, props, onError)
            : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key)) onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
          ctx.atKey = false;
          // value properties
          const valueProps = resolveProps.resolveProps(sep ?? [], {
            flow: fcName,
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false,
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found) break;
                  if (st.type === 'newline') {
                    onError(
                      st,
                      'MULTILINE_IMPLICIT_KEY',
                      'Implicit keys of flow sequence pairs need to be on a single line',
                    );
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(
                  valueProps.found,
                  'KEY_OVER_1024_CHARS',
                  'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key',
                );
            }
          } else if (value) {
            if ('source' in value && value.source && value.source[0] === ':')
              onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
            else onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
          }
          // value value
          const valueNode = value
            ? composeNode(ctx, value, valueProps, onError)
            : valueProps.found
              ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
              : null;
          if (valueNode) {
            if (isBlock(value)) onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment) keyNode.comment += '\n' + valueProps.comment;
            else keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens) pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? '}' : ']';
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce && ce.source === expectedEnd) cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
          ? `${name} must end with a ${expectedEnd}`
          : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1) ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment) coll.comment += '\n' + end.comment;
          else coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }

    exports.resolveFlowCollection = resolveFlowCollection;

    /***/
  },

  /***/ 5991: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var stringifyNumber = __webpack_require__(2490);

    /** Internal types handle bigint as number, because TS can't figure it out. */
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
      const num = n => (asBigInt ? BigInt(n) : Number(n));
      const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
      return sign === '-' ? num(-1) * res : res;
    }
    /**
     * hhhh:mm:ss.sss
     *
     * Internal types handle bigint as number, because TS can't figure it out.
     */
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = n => n;
      if (typeof value === 'bigint') num = n => BigInt(n);
      else if (isNaN(value) || !isFinite(value)) return stringifyNumber.stringifyNumber(node);
      let sign = '';
      if (value < 0) {
        sign = '-';
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60]; // seconds, including ms
      if (value < 60) {
        parts.unshift(0); // at least one : is required
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value); // hours
        }
      }
      return (
        sign +
        parts
          .map(n => String(n).padStart(2, '0'))
          .join(':')
          .replace(/000000\d*$/, '') // % 60 may introduce error
      );
    }
    const intTime = {
      identify: value => typeof value === 'bigint' || Number.isInteger(value),
      default: true,
      tag: 'tag:yaml.org,2002:int',
      format: 'TIME',
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal,
    };
    const floatTime = {
      identify: value => typeof value === 'number',
      default: true,
      tag: 'tag:yaml.org,2002:float',
      format: 'TIME',
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: str => parseSexagesimal(str, false),
      stringify: stringifySexagesimal,
    };
    const timestamp = {
      identify: value => value instanceof Date,
      default: true,
      tag: 'tag:yaml.org,2002:timestamp',
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp(
        '^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
          '(?:' + // time is optional
          '(?:t|T|[ \\t]+)' + // t | T | whitespace
          '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
          '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
          ')?$',
      ),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match) throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30) d *= 60;
          date -= 60000 * d;
        }
        return new Date(date);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, '') ?? '',
    };

    exports.floatTime = floatTime;
    exports.intTime = intTime;
    exports.timestamp = timestamp;

    /***/
  },

  /***/ 5996: /***/ (__unused_webpack_module, exports) => {
    /**
     * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
     * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
     * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
     *
     * Includes extensions for handling Map and Set objects.
     */
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            // eslint-disable-next-line @typescript-eslint/no-array-delete
            if (v1 === undefined) delete val[i];
            else if (v1 !== v0) val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === undefined) val.delete(k);
            else if (v1 !== v0) val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === undefined) val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === undefined) delete val[k];
            else if (v1 !== v0) val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }

    exports.applyReviver = applyReviver;

    /***/
  },

  /***/ 6101: /***/ (__unused_webpack_module, exports) => {
    class YAMLError extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    }
    class YAMLParseError extends YAMLError {
      constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
      }
    }
    class YAMLWarning extends YAMLError {
      constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
      }
    }
    const prettifyError = (src, lc) => error => {
      if (error.pos[0] === -1) return;
      error.linePos = error.pos.map(pos => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, '');
      // Trim to max 80 chars, keeping col position near the middle
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '…' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80) lineStr = lineStr.substring(0, 79) + '…';
      // Include previous line in context if pointing at line start
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80) prev = prev.substring(0, 79) + '…\n';
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
      }
    };

    exports.YAMLError = YAMLError;
    exports.YAMLParseError = YAMLParseError;
    exports.YAMLWarning = YAMLWarning;
    exports.prettifyError = prettifyError;

    /***/
  },

  /***/ 6364: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var Node = __webpack_require__(4176);
    var toJS = __webpack_require__(9126);

    const isScalarValue = value => !value || (typeof value !== 'function' && typeof value !== 'object');
    class Scalar extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    }
    Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
    Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
    Scalar.PLAIN = 'PLAIN';
    Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
    Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

    exports.Scalar = Scalar;
    exports.isScalarValue = isScalarValue;

    /***/
  },

  /***/ 6388: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    (function () {
      'use strict';

      var assign = __webpack_require__(4059);
      var vary = __webpack_require__(4795);

      var defaults = {
        origin: '*',
        methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
        preflightContinue: false,
        optionsSuccessStatus: 204,
      };

      function isString(s) {
        return typeof s === 'string' || s instanceof String;
      }

      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }

      function configureOrigin(options, req) {
        var requestOrigin = req.headers.origin,
          headers = [],
          isAllowed;

        if (!options.origin || options.origin === '*') {
          // allow any origin
          headers.push([
            {
              key: 'Access-Control-Allow-Origin',
              value: '*',
            },
          ]);
        } else if (isString(options.origin)) {
          // fixed origin
          headers.push([
            {
              key: 'Access-Control-Allow-Origin',
              value: options.origin,
            },
          ]);
          headers.push([
            {
              key: 'Vary',
              value: 'Origin',
            },
          ]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options.origin);
          // reflect origin
          headers.push([
            {
              key: 'Access-Control-Allow-Origin',
              value: isAllowed ? requestOrigin : false,
            },
          ]);
          headers.push([
            {
              key: 'Vary',
              value: 'Origin',
            },
          ]);
        }

        return headers;
      }

      function configureMethods(options) {
        var methods = options.methods;
        if (methods.join) {
          methods = options.methods.join(','); // .methods is an array, so turn it into a string
        }
        return {
          key: 'Access-Control-Allow-Methods',
          value: methods,
        };
      }

      function configureCredentials(options) {
        if (options.credentials === true) {
          return {
            key: 'Access-Control-Allow-Credentials',
            value: 'true',
          };
        }
        return null;
      }

      function configureAllowedHeaders(options, req) {
        var allowedHeaders = options.allowedHeaders || options.headers;
        var headers = [];

        if (!allowedHeaders) {
          allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers
          headers.push([
            {
              key: 'Vary',
              value: 'Access-Control-Request-Headers',
            },
          ]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([
            {
              key: 'Access-Control-Allow-Headers',
              value: allowedHeaders,
            },
          ]);
        }

        return headers;
      }

      function configureExposedHeaders(options) {
        var headers = options.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(','); // .headers is an array, so turn it into a string
        }
        if (headers && headers.length) {
          return {
            key: 'Access-Control-Expose-Headers',
            value: headers,
          };
        }
        return null;
      }

      function configureMaxAge(options) {
        var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: 'Access-Control-Max-Age',
            value: maxAge,
          };
        }
        return null;
      }

      function applyHeaders(headers, res) {
        for (var i = 0, n = headers.length; i < n; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === 'Vary' && header.value) {
              vary(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }

      function cors(options, req, res, next) {
        var headers = [],
          method = req.method && req.method.toUpperCase && req.method.toUpperCase();

        if (method === 'OPTIONS') {
          // preflight
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureMethods(options, req));
          headers.push(configureAllowedHeaders(options, req));
          headers.push(configureMaxAge(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);

          if (options.preflightContinue) {
            next();
          } else {
            // Safari (and potentially other browsers) need content-length 0,
            //   for 204 or they just hang waiting for a body
            res.statusCode = options.optionsSuccessStatus;
            res.setHeader('Content-Length', '0');
            res.end();
          }
        } else {
          // actual response
          headers.push(configureOrigin(options, req));
          headers.push(configureCredentials(options, req));
          headers.push(configureExposedHeaders(options, req));
          applyHeaders(headers, res);
          next();
        }
      }

      function middlewareWrapper(o) {
        // if options are static (either via defaults or custom options passed in), wrap in a function
        var optionsCallback = null;
        if (typeof o === 'function') {
          optionsCallback = o;
        } else {
          optionsCallback = function (req, cb) {
            cb(null, o);
          };
        }

        return function corsMiddleware(req, res, next) {
          optionsCallback(req, function (err, options) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults, options);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === 'function') {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function (origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }

              if (originCallback) {
                originCallback(req.headers.origin, function (err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }

      // can pass either an options hash, an options delegate, or nothing
      module.exports = middlewareWrapper;
    })();

    /***/
  },

  /***/ 6421: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var Alias = __webpack_require__(9814);
    var identity = __webpack_require__(7182);
    var Scalar = __webpack_require__(6364);

    const defaultTagPrefix = 'tag:yaml.org,2002:';
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj) throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find(t => t.identify?.(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value)) value = value.contents;
      if (identity.isNode(value)) return value;
      if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
      }
      if (
        value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
      ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      // Detect duplicate references to the same object & use Alias nodes for all
      // after first. The `ref` wrapper allows for circular references to resolve.
      let ref = undefined;
      if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
          ref.anchor ?? (ref.anchor = onAnchor(value));
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith('!!')) tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
          // eslint-disable-next-line @typescript-eslint/no-unsafe-call
          value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
          const node = new Scalar.Scalar(value);
          if (ref) ref.node = node;
          return node;
        }
        tagObj =
          value instanceof Map
            ? schema[identity.MAP]
            : Symbol.iterator in Object(value)
              ? schema[identity.SEQ]
              : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
          ? tagObj.nodeClass.from(ctx.schema, value, ctx)
          : new Scalar.Scalar(value);
      if (tagName) node.tag = tagName;
      else if (!tagObj.default) node.tag = tagObj.tag;
      if (ref) ref.node = node;
      return node;
    }

    exports.createNode = createNode;

    /***/
  },

  /***/ 6544: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var createNode = __webpack_require__(6421);
    var stringifyPair = __webpack_require__(1307);
    var addPairToJSMap = __webpack_require__(7825);
    var identity = __webpack_require__(7182);

    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, undefined, ctx);
      const v = createNode.createNode(value, undefined, ctx);
      return new Pair(k, v);
    }
    class Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key)) key = key.clone(schema);
        if (identity.isNode(value)) value = value.clone(schema);
        return new Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    }

    exports.Pair = Pair;
    exports.createPair = createPair;

    /***/
  },

  /***/ 6695: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);

    const BREAK = Symbol('break visit');
    const SKIP = Symbol('skip children');
    const REMOVE = Symbol('remove node');
    /**
     * Apply a visitor to an AST node or document.
     *
     * Walks through the tree (depth-first) starting from `node`, calling a
     * `visitor` function with three arguments:
     *   - `key`: For sequence values and map `Pair`, the node's index in the
     *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
     *     `null` for the root node.
     *   - `node`: The current node.
     *   - `path`: The ancestry of the current node.
     *
     * The return value of the visitor may be used to control the traversal:
     *   - `undefined` (default): Do nothing and continue
     *   - `visit.SKIP`: Do not visit the children of this node, continue with next
     *     sibling
     *   - `visit.BREAK`: Terminate traversal completely
     *   - `visit.REMOVE`: Remove the current node, then continue with the next one
     *   - `Node`: Replace the current node, then continue by visiting it
     *   - `number`: While iterating the items of a sequence or map, set the index
     *     of the next step. This is useful especially if the index of the current
     *     node has changed.
     *
     * If `visitor` is a single function, it will be called with all values
     * encountered in the tree, including e.g. `null` values. Alternatively,
     * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
     * `Alias` and `Scalar` node. To define the same visitor function for more than
     * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
     * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
     * specific defined one will be used for each node.
     */
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE) node.contents = null;
      } else visit_(null, node, visitor_, Object.freeze([]));
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */
    visit.BREAK = BREAK;
    /** Do not visit the children of the current node */
    visit.SKIP = SKIP;
    /** Remove the current node */
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path) {
      const ctrl = callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path);
            if (typeof ci === 'number') i = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = visit_('key', node.key, visitor, path);
          if (ck === BREAK) return BREAK;
          else if (ck === REMOVE) node.key = null;
          const cv = visit_('value', node.value, visitor, path);
          if (cv === BREAK) return BREAK;
          else if (cv === REMOVE) node.value = null;
        }
      }
      return ctrl;
    }
    /**
     * Apply an async visitor to an AST node or document.
     *
     * Walks through the tree (depth-first) starting from `node`, calling a
     * `visitor` function with three arguments:
     *   - `key`: For sequence values and map `Pair`, the node's index in the
     *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
     *     `null` for the root node.
     *   - `node`: The current node.
     *   - `path`: The ancestry of the current node.
     *
     * The return value of the visitor may be used to control the traversal:
     *   - `Promise`: Must resolve to one of the following values
     *   - `undefined` (default): Do nothing and continue
     *   - `visit.SKIP`: Do not visit the children of this node, continue with next
     *     sibling
     *   - `visit.BREAK`: Terminate traversal completely
     *   - `visit.REMOVE`: Remove the current node, then continue with the next one
     *   - `Node`: Replace the current node, then continue by visiting it
     *   - `number`: While iterating the items of a sequence or map, set the index
     *     of the next step. This is useful especially if the index of the current
     *     node has changed.
     *
     * If `visitor` is a single function, it will be called with all values
     * encountered in the tree, including e.g. `null` values. Alternatively,
     * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
     * `Alias` and `Scalar` node. To define the same visitor function for more than
     * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
     * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
     * specific defined one will be used for each node.
     */
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE) node.contents = null;
      } else await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    // Without the `as symbol` casts, TS declares these in the `visit`
    // namespace using `var`, but then complains about that because
    // `unique symbol` must be `const`.
    /** Terminate visit traversal completely */
    visitAsync.BREAK = BREAK;
    /** Do not visit the children of the current node */
    visitAsync.SKIP = SKIP;
    /** Remove the current node */
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path) {
      const ctrl = await callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path);
            if (typeof ci === 'number') i = ci - 1;
            else if (ci === BREAK) return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = await visitAsync_('key', node.key, visitor, path);
          if (ck === BREAK) return BREAK;
          else if (ck === REMOVE) node.key = null;
          const cv = await visitAsync_('value', node.value, visitor, path);
          if (cv === BREAK) return BREAK;
          else if (cv === REMOVE) node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === 'object' && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign(
          {
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node,
          },
          visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value,
          },
          visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection,
          },
          visitor,
        );
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path) {
      if (typeof visitor === 'function') return visitor(key, node, path);
      if (identity.isMap(node)) return visitor.Map?.(key, node, path);
      if (identity.isSeq(node)) return visitor.Seq?.(key, node, path);
      if (identity.isPair(node)) return visitor.Pair?.(key, node, path);
      if (identity.isScalar(node)) return visitor.Scalar?.(key, node, path);
      if (identity.isAlias(node)) return visitor.Alias?.(key, node, path);
      return undefined;
    }
    function replaceNode(key, path, node) {
      const parent = path[path.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === 'key') parent.key = node;
        else parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }

    exports.visit = visit;
    exports.visitAsync = visitAsync;

    /***/
  },

  /***/ 6713: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    /*!
     * mime-db
     * Copyright(c) 2014 Jonathan Ong
     * Copyright(c) 2015-2022 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module exports.
     */

    module.exports = __webpack_require__(7080);

    /***/
  },

  /***/ 6729: /***/ (__unused_webpack_module, exports) => {
    /**
     * CommanderError class
     */
    class CommanderError extends Error {
      /**
       * Constructs the CommanderError class
       * @param {number} exitCode suggested exit code which could be used with process.exit
       * @param {string} code an id string representing the error
       * @param {string} message human-readable description of the error
       */
      constructor(exitCode, code, message) {
        super(message);
        // properly capture stack trace in Node.js
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = undefined;
      }
    }

    /**
     * InvalidArgumentError class
     */
    class InvalidArgumentError extends CommanderError {
      /**
       * Constructs the InvalidArgumentError class
       * @param {string} [message] explanation of why argument is invalid
       */
      constructor(message) {
        super(1, 'commander.invalidArgument', message);
        // properly capture stack trace in Node.js
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    }

    exports.CommanderError = CommanderError;
    exports.InvalidArgumentError = InvalidArgumentError;

    /***/
  },

  /***/ 6760: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('node:path');

    /***/
  },

  /***/ 6821: /***/ (module, exports, __webpack_require__) => {
    /*!
     * base64id v0.1.0
     */

    /**
     * Module dependencies
     */

    var crypto = __webpack_require__(6982);

    /**
     * Constructor
     */

    var Base64Id = function () {};

    /**
     * Get random bytes
     *
     * Uses a buffer if available, falls back to crypto.randomBytes
     */

    Base64Id.prototype.getRandomBytes = function (bytes) {
      var BUFFER_SIZE = 4096;
      var self = this;

      bytes = bytes || 12;

      if (bytes > BUFFER_SIZE) {
        return crypto.randomBytes(bytes);
      }

      var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);
      var threshold = parseInt(bytesInBuffer * 0.85);

      if (!threshold) {
        return crypto.randomBytes(bytes);
      }

      if (this.bytesBufferIndex == null) {
        this.bytesBufferIndex = -1;
      }

      if (this.bytesBufferIndex == bytesInBuffer) {
        this.bytesBuffer = null;
        this.bytesBufferIndex = -1;
      }

      // No buffered bytes available or index above threshold
      if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
        if (!this.isGeneratingBytes) {
          this.isGeneratingBytes = true;
          crypto.randomBytes(BUFFER_SIZE, function (err, bytes) {
            self.bytesBuffer = bytes;
            self.bytesBufferIndex = 0;
            self.isGeneratingBytes = false;
          });
        }

        // Fall back to sync call when no buffered bytes are available
        if (this.bytesBufferIndex == -1) {
          return crypto.randomBytes(bytes);
        }
      }

      var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));
      this.bytesBufferIndex++;

      return result;
    };

    /**
     * Generates a base64 id
     *
     * (Original version from socket.io <http://socket.io>)
     */

    Base64Id.prototype.generateId = function () {
      var rand = Buffer.alloc(15); // multiple of 3 for base64
      if (!rand.writeInt32BE) {
        return (
          Math.abs((Math.random() * Math.random() * Date.now()) | 0).toString() +
          Math.abs((Math.random() * Math.random() * Date.now()) | 0).toString()
        );
      }
      this.sequenceNumber = (this.sequenceNumber + 1) | 0;
      rand.writeInt32BE(this.sequenceNumber, 11);
      if (crypto.randomBytes) {
        this.getRandomBytes(12).copy(rand);
      } else {
        // not secure for node 0.4
        [0, 4, 8].forEach(function (i) {
          rand.writeInt32BE((Math.random() * Math.pow(2, 32)) | 0, i);
        });
      }
      return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
    };

    /**
     * Export
     */

    exports = module.exports = new Base64Id();

    /***/
  },

  /***/ 6858: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var stringify = __webpack_require__(8767);
    var stringifyComment = __webpack_require__(3774);

    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart) hasDirectives = true;
      }
      if (hasDirectives) lines.push('---');
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1) lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ''));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives) lines.push('');
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ''));
          }
          // top-level block scalars need to be indented if followed by a comment
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment) body += stringifyComment.lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') && lines[lines.length - 1] === '---') {
          // Top-level block scalars with a preceding doc marker ought to use the
          // same line for their header.
          lines[lines.length - 1] = `--- ${body}`;
        } else lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes('\n')) {
            lines.push('...');
            lines.push(stringifyComment.indentComment(cs, ''));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push('...');
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep) dc = dc.replace(/^\n+/, '');
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');
          lines.push(stringifyComment.indentComment(commentString(dc), ''));
        }
      }
      return lines.join('\n') + '\n';
    }

    exports.stringifyDocument = stringifyDocument;

    /***/
  },

  /***/ 6928: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('path');

    /***/
  },

  /***/ 6936: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var map = __webpack_require__(4304);
    var _null = __webpack_require__(4985);
    var seq = __webpack_require__(581);
    var string = __webpack_require__(4401);
    var binary = __webpack_require__(8166);
    var bool = __webpack_require__(7551);
    var float = __webpack_require__(397);
    var int = __webpack_require__(1402);
    var merge = __webpack_require__(7459);
    var omap = __webpack_require__(90);
    var pairs = __webpack_require__(4710);
    var set = __webpack_require__(5359);
    var timestamp = __webpack_require__(5991);

    const schema = [
      map.map,
      seq.seq,
      string.string,
      _null.nullTag,
      bool.trueTag,
      bool.falseTag,
      int.intBin,
      int.intOct,
      int.int,
      int.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp,
    ];

    exports.schema = schema;

    /***/
  },

  /***/ 6982: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('crypto');

    /***/
  },

  /***/ 7013: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const { Duplex } = __webpack_require__(2203);

    /**
     * Emits the `'close'` event on a stream.
     *
     * @param {Duplex} stream The stream.
     * @private
     */
    function emitClose(stream) {
      stream.emit('close');
    }

    /**
     * The listener of the `'end'` event.
     *
     * @private
     */
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }

    /**
     * The listener of the `'error'` event.
     *
     * @param {Error} err The error
     * @private
     */
    function duplexOnError(err) {
      this.removeListener('error', duplexOnError);
      this.destroy();
      if (this.listenerCount('error') === 0) {
        // Do not suppress the throwing behavior.
        this.emit('error', err);
      }
    }

    /**
     * Wraps a `WebSocket` in a duplex stream.
     *
     * @param {WebSocket} ws The `WebSocket` to wrap
     * @param {Object} [options] The options for the `Duplex` constructor
     * @return {Duplex} The duplex stream
     * @public
     */
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;

      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false,
      });

      ws.on('message', function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

        if (!duplex.push(data)) ws.pause();
      });

      ws.once('error', function error(err) {
        if (duplex.destroyed) return;

        // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
        //
        // - If the `'error'` event is emitted before the `'open'` event, then
        //   `ws.terminate()` is a noop as no socket is assigned.
        // - Otherwise, the error is re-emitted by the listener of the `'error'`
        //   event of the `Receiver` object. The listener already closes the
        //   connection by calling `ws.close()`. This allows a close frame to be
        //   sent to the other peer. If `ws.terminate()` is called right after this,
        //   then the close frame might not be sent.
        terminateOnDestroy = false;
        duplex.destroy(err);
      });

      ws.once('close', function close() {
        if (duplex.destroyed) return;

        duplex.push(null);
      });

      duplex._destroy = function (err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }

        let called = false;

        ws.once('error', function error(err) {
          called = true;
          callback(err);
        });

        ws.once('close', function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });

        if (terminateOnDestroy) ws.terminate();
      };

      duplex._final = function (callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once('open', function open() {
            duplex._final(callback);
          });
          return;
        }

        // If the value of the `_socket` property is `null` it means that `ws` is a
        // client websocket and the handshake failed. In fact, when this happens, a
        // socket is never assigned to the websocket. Wait for the `'error'` event
        // that will be emitted by the websocket.
        if (ws._socket === null) return;

        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once('finish', function finish() {
            // `duplex` is not destroyed here because the `'end'` event will be
            // emitted on `duplex` after this `'finish'` event. The EOF signaling
            // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
            callback();
          });
          ws.close();
        }
      };

      duplex._read = function () {
        if (ws.isPaused) ws.resume();
      };

      duplex._write = function (chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once('open', function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }

        ws.send(chunk, callback);
      };

      duplex.on('end', duplexOnEnd);
      duplex.on('error', duplexOnError);
      return duplex;
    }

    module.exports = createWebSocketStream;

    /***/
  },

  /***/ 7016: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('url');

    /***/
  },

  /***/ 7025: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.JSONP = void 0;
    const polling_1 = __webpack_require__(5718);
    const qs = __webpack_require__(3480);
    const rDoubleSlashes = /\\\\n/g;
    const rSlashes = /(\\)?\\n/g;
    class JSONP extends polling_1.Polling {
      /**
       * JSON-P polling transport.
       */
      constructor(req) {
        super(req);
        this.head = '___eio[' + (req._query.j || '').replace(/[^0-9]/g, '') + '](';
        this.foot = ');';
      }
      onData(data) {
        // we leverage the qs module so that we get built-in DoS protection
        // and the fast alternative to decodeURIComponent
        data = qs.parse(data).d;
        if ('string' === typeof data) {
          // client will send already escaped newlines as \\\\n and newlines as \\n
          // \\n must be replaced with \n and \\\\n with \\n
          data = data.replace(rSlashes, function (match, slashes) {
            return slashes ? match : '\n';
          });
          super.onData(data.replace(rDoubleSlashes, '\\n'));
        }
      }
      doWrite(data, options, callback) {
        // we must output valid javascript, not valid json
        // see: http://timelessrepo.com/json-isnt-a-javascript-subset
        const js = JSON.stringify(data)
          .replace(/\u2028/g, '\\u2028')
          .replace(/\u2029/g, '\\u2029');
        // prepare response
        data = this.head + js + this.foot;
        super.doWrite(data, options, callback);
      }
    }
    exports.JSONP = JSONP;

    /***/
  },

  /***/ 7062: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var cstScalar = __webpack_require__(9795);
    var cstStringify = __webpack_require__(810);
    var cstVisit = __webpack_require__(1744);

    /** The byte order mark */
    const BOM = '\u{FEFF}';
    /** Start of doc-mode */
    const DOCUMENT = '\x02'; // C0: Start of Text
    /** Unexpected end of flow-mode */
    const FLOW_END = '\x18'; // C0: Cancel
    /** Next token is a scalar value */
    const SCALAR = '\x1f'; // C0: Unit Separator
    /** @returns `true` if `token` is a flow or block collection */
    const isCollection = token => !!token && 'items' in token;
    /** @returns `true` if `token` is a flow or block scalar; not an alias */
    const isScalar = token =>
      !!token &&
      (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
    /* istanbul ignore next */
    /** Get a printable representation of a lexer token */
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return '<BOM>';
        case DOCUMENT:
          return '<DOC>';
        case FLOW_END:
          return '<FLOW_END>';
        case SCALAR:
          return '<SCALAR>';
        default:
          return JSON.stringify(token);
      }
    }
    /** Identify the type of a lexer token. May return `null` for unknown tokens. */
    function tokenType(source) {
      switch (source) {
        case BOM:
          return 'byte-order-mark';
        case DOCUMENT:
          return 'doc-mode';
        case FLOW_END:
          return 'flow-error-end';
        case SCALAR:
          return 'scalar';
        case '---':
          return 'doc-start';
        case '...':
          return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
          return 'newline';
        case '-':
          return 'seq-item-ind';
        case '?':
          return 'explicit-key-ind';
        case ':':
          return 'map-value-ind';
        case '{':
          return 'flow-map-start';
        case '}':
          return 'flow-map-end';
        case '[':
          return 'flow-seq-start';
        case ']':
          return 'flow-seq-end';
        case ',':
          return 'comma';
      }
      switch (source[0]) {
        case ' ':
        case '\t':
          return 'space';
        case '#':
          return 'comment';
        case '%':
          return 'directive-line';
        case '*':
          return 'alias';
        case '&':
          return 'anchor';
        case '!':
          return 'tag';
        case "'":
          return 'single-quoted-scalar';
        case '"':
          return 'double-quoted-scalar';
        case '|':
        case '>':
          return 'block-scalar-header';
      }
      return null;
    }

    exports.createScalarToken = cstScalar.createScalarToken;
    exports.resolveAsScalar = cstScalar.resolveAsScalar;
    exports.setScalarValue = cstScalar.setScalarValue;
    exports.stringify = cstStringify.stringify;
    exports.visit = cstVisit.visit;
    exports.BOM = BOM;
    exports.DOCUMENT = DOCUMENT;
    exports.FLOW_END = FLOW_END;
    exports.SCALAR = SCALAR;
    exports.isCollection = isCollection;
    exports.isScalar = isScalar;
    exports.prettyToken = prettyToken;
    exports.tokenType = tokenType;

    /***/
  },

  /***/ 7080: /***/ module => {
    module.exports = /*#__PURE__*/ JSON.parse(
      '{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}',
    );

    /***/
  },

  /***/ 7182: /***/ (__unused_webpack_module, exports) => {
    const ALIAS = Symbol.for('yaml.alias');
    const DOC = Symbol.for('yaml.document');
    const MAP = Symbol.for('yaml.map');
    const PAIR = Symbol.for('yaml.pair');
    const SCALAR = Symbol.for('yaml.scalar');
    const SEQ = Symbol.for('yaml.seq');
    const NODE_TYPE = Symbol.for('yaml.node.type');
    const isAlias = node => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
    const isDocument = node => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
    const isMap = node => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
    const isPair = node => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
    const isScalar = node => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
    const isSeq = node => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    const hasAnchor = node => (isScalar(node) || isCollection(node)) && !!node.anchor;

    exports.ALIAS = ALIAS;
    exports.DOC = DOC;
    exports.MAP = MAP;
    exports.NODE_TYPE = NODE_TYPE;
    exports.PAIR = PAIR;
    exports.SCALAR = SCALAR;
    exports.SEQ = SEQ;
    exports.hasAnchor = hasAnchor;
    exports.isAlias = isAlias;
    exports.isCollection = isCollection;
    exports.isDocument = isDocument;
    exports.isMap = isMap;
    exports.isNode = isNode;
    exports.isPair = isPair;
    exports.isScalar = isScalar;
    exports.isSeq = isSeq;

    /***/
  },

  /***/ 7320: /***/ (__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {
    __webpack_require__.r(__webpack_exports__);
    /* harmony export */ __webpack_require__.d(__webpack_exports__, {
      /* harmony export */ Emitter: () => /* binding */ Emitter,
      /* harmony export */
    });
    /**
     * Initialize a new `Emitter`.
     *
     * @api public
     */

    function Emitter(obj) {
      if (obj) return mixin(obj);
    }

    /**
     * Mixin the emitter properties.
     *
     * @param {Object} obj
     * @return {Object}
     * @api private
     */

    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }

    /**
     * Listen on the given `event` with `fn`.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
      return this;
    };

    /**
     * Adds an `event` listener that will be invoked a single
     * time then automatically removed.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.once = function (event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }

      on.fn = fn;
      this.on(event, on);
      return this;
    };

    /**
     * Remove the given callback for `event` or all
     * registered callbacks.
     *
     * @param {String} event
     * @param {Function} fn
     * @return {Emitter}
     * @api public
     */

    Emitter.prototype.off =
      Emitter.prototype.removeListener =
      Emitter.prototype.removeAllListeners =
      Emitter.prototype.removeEventListener =
        function (event, fn) {
          this._callbacks = this._callbacks || {};

          // all
          if (0 == arguments.length) {
            this._callbacks = {};
            return this;
          }

          // specific event
          var callbacks = this._callbacks['$' + event];
          if (!callbacks) return this;

          // remove all handlers
          if (1 == arguments.length) {
            delete this._callbacks['$' + event];
            return this;
          }

          // remove specific handler
          var cb;
          for (var i = 0; i < callbacks.length; i++) {
            cb = callbacks[i];
            if (cb === fn || cb.fn === fn) {
              callbacks.splice(i, 1);
              break;
            }
          }

          // Remove event specific arrays for event types that no
          // one is subscribed for to avoid memory leak.
          if (callbacks.length === 0) {
            delete this._callbacks['$' + event];
          }

          return this;
        };

    /**
     * Emit `event` with the given args.
     *
     * @param {String} event
     * @param {Mixed} ...
     * @return {Emitter}
     */

    Emitter.prototype.emit = function (event) {
      this._callbacks = this._callbacks || {};

      var args = new Array(arguments.length - 1),
        callbacks = this._callbacks['$' + event];

      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }

      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }

      return this;
    };

    // alias used for reserved events (protected method)
    Emitter.prototype.emitReserved = Emitter.prototype.emit;

    /**
     * Return array of callbacks for `event`.
     *
     * @param {String} event
     * @return {Array}
     * @api public
     */

    Emitter.prototype.listeners = function (event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks['$' + event] || [];
    };

    /**
     * Check if this emitter has `event` handlers.
     *
     * @param {String} event
     * @return {Boolean}
     * @api public
     */

    Emitter.prototype.hasListeners = function (event) {
      return !!this.listeners(event).length;
    };

    /***/
  },

  /***/ 7404: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var Alias = __webpack_require__(9814);
    var Collection = __webpack_require__(5920);
    var identity = __webpack_require__(7182);
    var Pair = __webpack_require__(6544);
    var toJS = __webpack_require__(9126);
    var Schema = __webpack_require__(407);
    var stringifyDocument = __webpack_require__(6858);
    var anchors = __webpack_require__(8047);
    var applyReviver = __webpack_require__(5996);
    var createNode = __webpack_require__(6421);
    var directives = __webpack_require__(7923);

    class Document {
      constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === undefined && replacer) {
          options = replacer;
          replacer = undefined;
        }
        const opt = Object.assign(
          {
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            stringKeys: false,
            uniqueKeys: true,
            version: '1.2',
          },
          options,
        );
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit) version = this.directives.yaml.version;
        } else this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents = value === undefined ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC },
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives) copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range) copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents)) this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents)) this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor =
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
          value = replacer.call({ '': value }, '', value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = v => typeof v === 'number' || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0) replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === undefined && replacer) {
          options = replacer;
          replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || 'a',
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects,
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node)) node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
          if (this.contents == null) return false;
          // @ts-expect-error Presumed impossible if Strict extends false
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : undefined;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : undefined;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (Collection.isEmptyPath(path)) return this.contents !== undefined;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          // @ts-expect-error We can't really know that this matches Contents.
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
          // @ts-expect-error We can't really know that this matches Contents.
          this.contents = value;
        } else if (this.contents == null) {
          // @ts-expect-error We can't really know that this matches Contents.
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version, options = {}) {
        if (typeof version === 'number') version = String(version);
        let opt;
        switch (version) {
          case '1.1':
            if (this.directives) this.directives.yaml.version = '1.1';
            else this.directives = new directives.Directives({ version: '1.1' });
            opt = { resolveKnownTags: false, schema: 'yaml-1.1' };
            break;
          case '1.2':
          case 'next':
            if (this.directives) this.directives.yaml.version = version;
            else this.directives = new directives.Directives({ version });
            opt = { resolveKnownTags: true, schema: 'core' };
            break;
          case null:
            if (this.directives) delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object) this.schema = options.schema;
        else if (opt) this.schema = new Schema.Schema(Object.assign(opt, options));
        else throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100,
        };
        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function') for (const { count, res } of ctx.anchors.values()) onAnchor(res, count);
        return typeof reviver === 'function' ? applyReviver.applyReviver(reviver, { '': res }, '', res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');
        if ('indent' in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    }
    function assertCollection(contents) {
      if (identity.isCollection(contents)) return true;
      throw new Error('Expected a YAML collection as document contents');
    }

    exports.Document = Document;

    /***/
  },

  /***/ 7459: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var Scalar = __webpack_require__(6364);

    // If the value associated with a merge key is a single mapping node, each of
    // its key/value pairs is inserted into the current mapping, unless the key
    // already exists in it. If the value associated with the merge key is a
    // sequence, then this sequence is expected to contain mapping nodes and each
    // of these nodes is merged in turn according to its order in the sequence.
    // Keys in mapping nodes earlier in the sequence override keys specified in
    // later mapping nodes. -- http://yaml.org/type/merge.html
    const MERGE_KEY = '<<';
    const merge = {
      identify: value => value === MERGE_KEY || (typeof value === 'symbol' && value.description === MERGE_KEY),
      default: 'key',
      tag: 'tag:yaml.org,2002:merge',
      test: /^<<$/,
      resolve: () =>
        Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
          addToJSMap: addMergeToJSMap,
        }),
      stringify: () => MERGE_KEY,
    };
    const isMergeKey = (ctx, key) =>
      (merge.identify(key) ||
        (identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge.identify(key.value))) &&
      ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);
    function addMergeToJSMap(ctx, map, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value)) for (const it of value.items) mergeValue(ctx, map, it);
      else if (Array.isArray(value)) for (const it of value) mergeValue(ctx, map, it);
      else mergeValue(ctx, map, value);
    }
    function mergeValue(ctx, map, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source)) throw new Error('Merge sources must be maps or map aliases');
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key)) map.set(key, value);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true,
          });
        }
      }
      return map;
    }

    exports.addMergeToJSMap = addMergeToJSMap;
    exports.isMergeKey = isMergeKey;
    exports.merge = merge;

    /***/
  },

  /***/ 7515: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var stringify = __webpack_require__(8767);
    var stringifyComment = __webpack_require__(3774);

    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify(collection, ctx, options);
    }
    function stringifyBlockCollection(
      { comment, items },
      ctx,
      { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment },
    ) {
      const {
        indent,
        options: { commentString },
      } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false; // flag for the preceding node's status
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore) lines.push('');
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment) comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore) lines.push('');
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str = stringify.stringify(
          item,
          itemCtx,
          () => (comment = null),
          () => (chompKeep = true),
        );
        if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment) chompKeep = false;
        lines.push(blockItemPrefix + str);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `\n${indent}${line}` : '\n';
        }
      }
      if (comment) {
        str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment) onComment();
      } else if (chompKeep && onChompKeep) onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const {
        indent,
        indentStep,
        flowCollectionPadding: fcPadding,
        options: { commentString },
      } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null,
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore) lines.push('');
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment) comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore) lines.push('');
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment) reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment) comment = iv.comment;
            if (iv.commentBefore) reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment) reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1) str += ',';
        if (comment) str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n'))) reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines) str += line ? `\n${indentStep}${indent}${line}` : '\n';
          return `${str}\n${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep) comment = comment.replace(/^\n+/, '');
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
      }
    }

    exports.stringifyCollection = stringifyCollection;

    /***/
  },

  /***/ 7551: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var Scalar = __webpack_require__(6364);

    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source)) return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    const trueTag = {
      identify: value => value === true,
      default: true,
      tag: 'tag:yaml.org,2002:bool',
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify,
    };
    const falseTag = {
      identify: value => value === false,
      default: true,
      tag: 'tag:yaml.org,2002:bool',
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify,
    };

    exports.falseTag = falseTag;
    exports.trueTag = trueTag;

    /***/
  },

  /***/ 7682: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var composer = __webpack_require__(4045);
    var Document = __webpack_require__(7404);
    var errors = __webpack_require__(6101);
    var log = __webpack_require__(9454);
    var identity = __webpack_require__(7182);
    var lineCounter = __webpack_require__(8177);
    var parser = __webpack_require__(3893);

    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    /**
     * Parse the input as a stream of YAML documents.
     *
     * Documents should be separated from each other by `...` or `---` marker lines.
     *
     * @returns If an empty `docs` array is returned, it will be of type
     *   EmptyStream and contain additional stream information. In
     *   TypeScript, you should use `'empty' in docs` as a type guard for it.
     */
    function parseAllDocuments(source, options = {}) {
      const { lineCounter, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
      if (docs.length > 0) return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    /** Parse an input string into a single YAML.Document */
    function parseDocument(source, options = {}) {
      const { lineCounter, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter?.addNewLine);
      const composer$1 = new composer.Composer(options);
      // `doc` is always set by compose.end(true) at the very latest
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc) doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
          doc.errors.push(
            new errors.YAMLParseError(
              _doc.range.slice(0, 2),
              'MULTIPLE_DOCS',
              'Source contains multiple documents; please use YAML.parseAllDocuments()',
            ),
          );
          break;
        }
      }
      if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
      }
      return doc;
    }
    function parse(src, reviver, options) {
      let _reviver = undefined;
      if (typeof reviver === 'function') {
        _reviver = reviver;
      } else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc) return null;
      doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent') throw doc.errors[0];
        else doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === undefined && replacer) {
        options = replacer;
      }
      if (typeof options === 'string') options = options.length;
      if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined) return undefined;
      }
      if (identity.isDocument(value) && !_replacer) return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }

    exports.parse = parse;
    exports.parseAllDocuments = parseAllDocuments;
    exports.parseDocument = parseDocument;
    exports.stringify = stringify;

    /***/
  },

  /***/ 7709: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     */

    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = __webpack_require__(9049);
      createDebug.destroy = destroy;

      Object.keys(env).forEach(key => {
        createDebug[key] = env[key];
      });

      /**
       * The currently active debug mode names, and names to skip.
       */

      createDebug.names = [];
      createDebug.skips = [];

      /**
       * Map of special "%n" handling functions, for the debug "format" argument.
       *
       * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
       */
      createDebug.formatters = {};

      /**
       * Selects a color for a debug namespace
       * @param {String} namespace The namespace string for the debug instance to be colored
       * @return {Number|String} An ANSI color code for the given namespace
       * @api private
       */
      function selectColor(namespace) {
        let hash = 0;

        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0; // Convert to 32bit integer
        }

        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;

      /**
       * Create a debugger with the given `namespace`.
       *
       * @param {String} namespace
       * @return {Function}
       * @api public
       */
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;

        function debug(...args) {
          // Disabled?
          if (!debug.enabled) {
            return;
          }

          const self = debug;

          // Set `diff` timestamp
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self.diff = ms;
          self.prev = prevTime;
          self.curr = curr;
          prevTime = curr;

          args[0] = createDebug.coerce(args[0]);

          if (typeof args[0] !== 'string') {
            // Anything else let's inspect with %O
            args.unshift('%O');
          }

          // Apply any `formatters` transformations
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            // If we encounter an escaped % then don't increase the array index
            if (match === '%%') {
              return '%';
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === 'function') {
              const val = args[index];
              match = formatter.call(self, val);

              // Now we need to remove `args[index]` since it's inlined in the `format`
              args.splice(index, 1);
              index--;
            }
            return match;
          });

          // Apply env-specific formatting (colors, etc.)
          createDebug.formatArgs.call(self, args);

          const logFn = self.log || createDebug.log;
          logFn.apply(self, args);
        }

        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

        Object.defineProperty(debug, 'enabled', {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }

            return enabledCache;
          },
          set: v => {
            enableOverride = v;
          },
        });

        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
          createDebug.init(debug);
        }

        return debug;
      }

      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }

      /**
       * Enables a debug mode by namespaces. This can include modes
       * separated by a colon and wildcards.
       *
       * @param {String} namespaces
       * @api public
       */
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;

        createDebug.names = [];
        createDebug.skips = [];

        let i;
        const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
        const len = split.length;

        for (i = 0; i < len; i++) {
          if (!split[i]) {
            // ignore empty strings
            continue;
          }

          namespaces = split[i].replace(/\*/g, '.*?');

          if (namespaces[0] === '-') {
            createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
          } else {
            createDebug.names.push(new RegExp('^' + namespaces + '$'));
          }
        }
      }

      /**
       * Disable debug output.
       *
       * @return {String} namespaces
       * @api public
       */
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace),
        ].join(',');
        createDebug.enable('');
        return namespaces;
      }

      /**
       * Returns true if the given mode name is enabled, false otherwise.
       *
       * @param {String} name
       * @return {Boolean}
       * @api public
       */
      function enabled(name) {
        if (name[name.length - 1] === '*') {
          return true;
        }

        let i;
        let len;

        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }

        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }

        return false;
      }

      /**
       * Convert regexp to namespace
       *
       * @param {RegExp} regxep
       * @return {String} namespace
       * @api private
       */
      function toNamespace(regexp) {
        return regexp
          .toString()
          .substring(2, regexp.toString().length - 2)
          .replace(/\.\*\?$/, '*');
      }

      /**
       * Coerce `val`.
       *
       * @param {Mixed} val
       * @return {Mixed}
       * @api private
       */
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }

      /**
       * XXX DO NOT USE. This is a temporary stub function.
       * XXX It WILL be removed in the next major release.
       */
      function destroy() {
        console.warn(
          'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.',
        );
      }

      createDebug.enable(createDebug.load());

      return createDebug;
    }

    module.exports = setup;

    /***/
  },

  /***/ 7732: /***/ (__unused_webpack_module, exports) => {
    const maxDistance = 3;

    function editDistance(a, b) {
      // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance
      // Calculating optimal string alignment distance, no substring is edited more than once.
      // (Simple implementation.)

      // Quick early exit, return worst case.
      if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);

      // distance between prefix substrings of a and b
      const d = [];

      // pure deletions turn a into empty string
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      // pure insertions turn empty string into b
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }

      // fill matrix
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(
            d[i - 1][j] + 1, // deletion
            d[i][j - 1] + 1, // insertion
            d[i - 1][j - 1] + cost, // substitution
          );
          // transposition
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }

      return d[a.length][b.length];
    }

    /**
     * Find close matches, restricted to same number of edits.
     *
     * @param {string} word
     * @param {string[]} candidates
     * @returns {string}
     */

    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0) return '';
      // remove possible duplicates
      candidates = Array.from(new Set(candidates));

      const searchingOptions = word.startsWith('--');
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map(candidate => candidate.slice(2));
      }

      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach(candidate => {
        if (candidate.length <= 1) return; // no one character guesses

        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            // better edit distance, throw away previous worse matches
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });

      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map(candidate => `--${candidate}`);
      }

      if (similar.length > 1) {
        return `\n(Did you mean one of ${similar.join(', ')}?)`;
      }
      if (similar.length === 1) {
        return `\n(Did you mean ${similar[0]}?)`;
      }
      return '';
    }

    exports.suggestSimilar = suggestSimilar;

    /***/
  },

  /***/ 7758: /***/ (__unused_webpack_module, exports) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
    const PACKET_TYPES = Object.create(null); // no Map = no polyfill
    exports.PACKET_TYPES = PACKET_TYPES;
    PACKET_TYPES['open'] = '0';
    PACKET_TYPES['close'] = '1';
    PACKET_TYPES['ping'] = '2';
    PACKET_TYPES['pong'] = '3';
    PACKET_TYPES['message'] = '4';
    PACKET_TYPES['upgrade'] = '5';
    PACKET_TYPES['noop'] = '6';
    const PACKET_TYPES_REVERSE = Object.create(null);
    exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
    Object.keys(PACKET_TYPES).forEach(key => {
      PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
    });
    const ERROR_PACKET = { type: 'error', data: 'parser error' };
    exports.ERROR_PACKET = ERROR_PACKET;

    /***/
  },

  /***/ 7773: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Socket = void 0;
    const events_1 = __webpack_require__(4434);
    const debug_1 = __webpack_require__(1106);
    const timers_1 = __webpack_require__(3557);
    const debug = (0, debug_1.default)('engine:socket');
    class Socket extends events_1.EventEmitter {
      get readyState() {
        return this._readyState;
      }
      set readyState(state) {
        debug('readyState updated from %s to %s', this._readyState, state);
        this._readyState = state;
      }
      constructor(id, server, transport, req, protocol) {
        super();
        /**
         * The current state of the socket.
         */
        this._readyState = 'opening';
        /* private */ this.upgrading = false;
        /* private */ this.upgraded = false;
        this.writeBuffer = [];
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.cleanupFn = [];
        this.id = id;
        this.server = server;
        this.request = req;
        this.protocol = protocol;
        // Cache IP since it might not be in the req later
        if (req) {
          if (req.websocket && req.websocket._socket) {
            this.remoteAddress = req.websocket._socket.remoteAddress;
          } else {
            this.remoteAddress = req.connection.remoteAddress;
          }
        } else {
          // TODO there is currently no way to get the IP address of the client when it connects with WebTransport
          //  see https://github.com/fails-components/webtransport/issues/114
        }
        this.pingTimeoutTimer = null;
        this.pingIntervalTimer = null;
        this.setTransport(transport);
        this.onOpen();
      }
      /**
       * Called upon transport considered open.
       *
       * @private
       */
      onOpen() {
        this.readyState = 'open';
        // sends an `open` packet
        this.transport.sid = this.id;
        this.sendPacket(
          'open',
          JSON.stringify({
            sid: this.id,
            upgrades: this.getAvailableUpgrades(),
            pingInterval: this.server.opts.pingInterval,
            pingTimeout: this.server.opts.pingTimeout,
            maxPayload: this.server.opts.maxHttpBufferSize,
          }),
        );
        if (this.server.opts.initialPacket) {
          this.sendPacket('message', this.server.opts.initialPacket);
        }
        this.emit('open');
        if (this.protocol === 3) {
          // in protocol v3, the client sends a ping, and the server answers with a pong
          this.resetPingTimeout();
        } else {
          // in protocol v4, the server sends a ping, and the client answers with a pong
          this.schedulePing();
        }
      }
      /**
       * Called upon transport packet.
       *
       * @param {Object} packet
       * @private
       */
      onPacket(packet) {
        if ('open' !== this.readyState) {
          return debug('packet received with closed socket');
        }
        // export packet event
        debug(`received packet ${packet.type}`);
        this.emit('packet', packet);
        switch (packet.type) {
          case 'ping':
            if (this.transport.protocol !== 3) {
              this.onError(new Error('invalid heartbeat direction'));
              return;
            }
            debug('got ping');
            this.pingTimeoutTimer.refresh();
            this.sendPacket('pong');
            this.emit('heartbeat');
            break;
          case 'pong':
            if (this.transport.protocol === 3) {
              this.onError(new Error('invalid heartbeat direction'));
              return;
            }
            debug('got pong');
            (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
            this.pingIntervalTimer.refresh();
            this.emit('heartbeat');
            break;
          case 'error':
            this.onClose('parse error');
            break;
          case 'message':
            this.emit('data', packet.data);
            this.emit('message', packet.data);
            break;
        }
      }
      /**
       * Called upon transport error.
       *
       * @param {Error} err - error object
       * @private
       */
      onError(err) {
        debug('transport error');
        this.onClose('transport error', err);
      }
      /**
       * Pings client every `this.pingInterval` and expects response
       * within `this.pingTimeout` or closes connection.
       *
       * @private
       */
      schedulePing() {
        this.pingIntervalTimer = (0, timers_1.setTimeout)(() => {
          debug('writing ping packet - expecting pong within %sms', this.server.opts.pingTimeout);
          this.sendPacket('ping');
          this.resetPingTimeout();
        }, this.server.opts.pingInterval);
      }
      /**
       * Resets ping timeout.
       *
       * @private
       */
      resetPingTimeout() {
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        this.pingTimeoutTimer = (0, timers_1.setTimeout)(
          () => {
            if (this.readyState === 'closed') return;
            this.onClose('ping timeout');
          },
          this.protocol === 3
            ? this.server.opts.pingInterval + this.server.opts.pingTimeout
            : this.server.opts.pingTimeout,
        );
      }
      /**
       * Attaches handlers for the given transport.
       *
       * @param {Transport} transport
       * @private
       */
      setTransport(transport) {
        const onError = this.onError.bind(this);
        const onReady = () => this.flush();
        const onPacket = this.onPacket.bind(this);
        const onDrain = this.onDrain.bind(this);
        const onClose = this.onClose.bind(this, 'transport close');
        this.transport = transport;
        this.transport.once('error', onError);
        this.transport.on('ready', onReady);
        this.transport.on('packet', onPacket);
        this.transport.on('drain', onDrain);
        this.transport.once('close', onClose);
        this.cleanupFn.push(function () {
          transport.removeListener('error', onError);
          transport.removeListener('ready', onReady);
          transport.removeListener('packet', onPacket);
          transport.removeListener('drain', onDrain);
          transport.removeListener('close', onClose);
        });
      }
      /**
       * Upon transport "drain" event
       *
       * @private
       */
      onDrain() {
        if (this.sentCallbackFn.length > 0) {
          debug('executing batch send callback');
          const seqFn = this.sentCallbackFn.shift();
          if (seqFn) {
            for (let i = 0; i < seqFn.length; i++) {
              seqFn[i](this.transport);
            }
          }
        }
      }
      /**
       * Upgrades socket to the given transport
       *
       * @param {Transport} transport
       * @private
       */
      /* private */ _maybeUpgrade(transport) {
        debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
        this.upgrading = true;
        // set transport upgrade timer
        const upgradeTimeoutTimer = (0, timers_1.setTimeout)(() => {
          debug('client did not complete upgrade - closing transport');
          cleanup();
          if ('open' === transport.readyState) {
            transport.close();
          }
        }, this.server.opts.upgradeTimeout);
        let checkIntervalTimer;
        const onPacket = packet => {
          if ('ping' === packet.type && 'probe' === packet.data) {
            debug('got probe ping packet, sending pong');
            transport.send([{ type: 'pong', data: 'probe' }]);
            this.emit('upgrading', transport);
            clearInterval(checkIntervalTimer);
            checkIntervalTimer = setInterval(check, 100);
          } else if ('upgrade' === packet.type && this.readyState !== 'closed') {
            debug('got upgrade packet - upgrading');
            cleanup();
            this.transport.discard();
            this.upgraded = true;
            this.clearTransport();
            this.setTransport(transport);
            this.emit('upgrade', transport);
            this.flush();
            if (this.readyState === 'closing') {
              transport.close(() => {
                this.onClose('forced close');
              });
            }
          } else {
            cleanup();
            transport.close();
          }
        };
        // we force a polling cycle to ensure a fast upgrade
        const check = () => {
          if ('polling' === this.transport.name && this.transport.writable) {
            debug('writing a noop packet to polling for fast upgrade');
            this.transport.send([{ type: 'noop' }]);
          }
        };
        const cleanup = () => {
          this.upgrading = false;
          clearInterval(checkIntervalTimer);
          (0, timers_1.clearTimeout)(upgradeTimeoutTimer);
          transport.removeListener('packet', onPacket);
          transport.removeListener('close', onTransportClose);
          transport.removeListener('error', onError);
          this.removeListener('close', onClose);
        };
        const onError = err => {
          debug('client did not complete upgrade - %s', err);
          cleanup();
          transport.close();
          transport = null;
        };
        const onTransportClose = () => {
          onError('transport closed');
        };
        const onClose = () => {
          onError('socket closed');
        };
        transport.on('packet', onPacket);
        transport.once('close', onTransportClose);
        transport.once('error', onError);
        this.once('close', onClose);
      }
      /**
       * Clears listeners and timers associated with current transport.
       *
       * @private
       */
      clearTransport() {
        let cleanup;
        const toCleanUp = this.cleanupFn.length;
        for (let i = 0; i < toCleanUp; i++) {
          cleanup = this.cleanupFn.shift();
          cleanup();
        }
        // silence further transport errors and prevent uncaught exceptions
        this.transport.on('error', function () {
          debug('error triggered by discarded transport');
        });
        // ensure transport won't stay open
        this.transport.close();
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
      }
      /**
       * Called upon transport considered closed.
       * Possible reasons: `ping timeout`, `client error`, `parse error`,
       * `transport error`, `server close`, `transport close`
       */
      onClose(reason, description) {
        if ('closed' !== this.readyState) {
          this.readyState = 'closed';
          // clear timers
          (0, timers_1.clearTimeout)(this.pingIntervalTimer);
          (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
          // clean writeBuffer in next tick, so developers can still
          // grab the writeBuffer on 'close' event
          process.nextTick(() => {
            this.writeBuffer = [];
          });
          this.packetsFn = [];
          this.sentCallbackFn = [];
          this.clearTransport();
          this.emit('close', reason, description);
        }
      }
      /**
       * Sends a message packet.
       *
       * @param {Object} data
       * @param {Object} options
       * @param {Function} callback
       * @return {Socket} for chaining
       */
      send(data, options, callback) {
        this.sendPacket('message', data, options, callback);
        return this;
      }
      /**
       * Alias of {@link send}.
       *
       * @param data
       * @param options
       * @param callback
       */
      write(data, options, callback) {
        this.sendPacket('message', data, options, callback);
        return this;
      }
      /**
       * Sends a packet.
       *
       * @param {String} type - packet type
       * @param {String} data
       * @param {Object} options
       * @param {Function} callback
       *
       * @private
       */
      sendPacket(type, data, options = {}, callback) {
        if ('function' === typeof options) {
          callback = options;
          options = {};
        }
        if ('closing' !== this.readyState && 'closed' !== this.readyState) {
          debug('sending packet "%s" (%s)', type, data);
          // compression is enabled by default
          options.compress = options.compress !== false;
          const packet = {
            type,
            options: options,
          };
          if (data) packet.data = data;
          // exports packetCreate event
          this.emit('packetCreate', packet);
          this.writeBuffer.push(packet);
          // add send callback to object, if defined
          if ('function' === typeof callback) this.packetsFn.push(callback);
          this.flush();
        }
      }
      /**
       * Attempts to flush the packets buffer.
       *
       * @private
       */
      flush() {
        if ('closed' !== this.readyState && this.transport.writable && this.writeBuffer.length) {
          debug('flushing buffer to transport');
          this.emit('flush', this.writeBuffer);
          this.server.emit('flush', this, this.writeBuffer);
          const wbuf = this.writeBuffer;
          this.writeBuffer = [];
          if (this.packetsFn.length) {
            this.sentCallbackFn.push(this.packetsFn);
            this.packetsFn = [];
          } else {
            this.sentCallbackFn.push(null);
          }
          this.transport.send(wbuf);
          this.emit('drain');
          this.server.emit('drain', this);
        }
      }
      /**
       * Get available upgrades for this socket.
       *
       * @private
       */
      getAvailableUpgrades() {
        const availableUpgrades = [];
        const allUpgrades = this.server.upgrades(this.transport.name);
        for (let i = 0; i < allUpgrades.length; ++i) {
          const upg = allUpgrades[i];
          if (this.server.opts.transports.indexOf(upg) !== -1) {
            availableUpgrades.push(upg);
          }
        }
        return availableUpgrades;
      }
      /**
       * Closes the socket and underlying transport.
       *
       * @param {Boolean} discard - optional, discard the transport
       * @return {Socket} for chaining
       */
      close(discard) {
        if (discard && (this.readyState === 'open' || this.readyState === 'closing')) {
          return this.closeTransport(discard);
        }
        if ('open' !== this.readyState) return;
        this.readyState = 'closing';
        if (this.writeBuffer.length) {
          debug("there are %d remaining packets in the buffer, waiting for the 'drain' event", this.writeBuffer.length);
          this.once('drain', () => {
            debug('all packets have been sent, closing the transport');
            this.closeTransport(discard);
          });
          return;
        }
        debug('the buffer is empty, closing the transport right away');
        this.closeTransport(discard);
      }
      /**
       * Closes the underlying transport.
       *
       * @param {Boolean} discard
       * @private
       */
      closeTransport(discard) {
        debug('closing the transport (discard? %s)', !!discard);
        if (discard) this.transport.discard();
        this.transport.close(this.onClose.bind(this, 'forced close'));
      }
    }
    exports.Socket = Socket;

    /***/
  },

  /***/ 7821: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var map = __webpack_require__(4304);
    var _null = __webpack_require__(4985);
    var seq = __webpack_require__(581);
    var string = __webpack_require__(4401);
    var bool = __webpack_require__(3754);
    var float = __webpack_require__(3554);
    var int = __webpack_require__(9605);
    var schema = __webpack_require__(45);
    var schema$1 = __webpack_require__(914);
    var binary = __webpack_require__(8166);
    var merge = __webpack_require__(7459);
    var omap = __webpack_require__(90);
    var pairs = __webpack_require__(4710);
    var schema$2 = __webpack_require__(6936);
    var set = __webpack_require__(5359);
    var timestamp = __webpack_require__(5991);

    const schemas = new Map([
      ['core', schema.schema],
      ['failsafe', [map.map, seq.seq, string.string]],
      ['json', schema$1.schema],
      ['yaml11', schema$2.schema],
      ['yaml-1.1', schema$2.schema],
    ]);
    const tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int.int,
      intHex: int.intHex,
      intOct: int.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      merge: merge.merge,
      null: _null.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp,
    };
    const coreKnownTags = {
      'tag:yaml.org,2002:binary': binary.binary,
      'tag:yaml.org,2002:merge': merge.merge,
      'tag:yaml.org,2002:omap': omap.omap,
      'tag:yaml.org,2002:pairs': pairs.pairs,
      'tag:yaml.org,2002:set': set.set,
      'tag:yaml.org,2002:timestamp': timestamp.timestamp,
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge) ? schemaTags.concat(merge.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags)) tags = [];
        else {
          const keys = Array.from(schemas.keys())
            .filter(key => key !== 'yaml11')
            .map(key => JSON.stringify(key))
            .join(', ');
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags) tags = tags.concat(tag);
      } else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
      }
      if (addMergeTag) tags = tags.concat(merge.merge);
      return tags.reduce((tags, tag) => {
        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName)
            .map(key => JSON.stringify(key))
            .join(', ');
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags.includes(tagObj)) tags.push(tagObj);
        return tags;
      }, []);
    }

    exports.coreKnownTags = coreKnownTags;
    exports.getTags = getTags;

    /***/
  },

  /***/ 7825: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var log = __webpack_require__(9454);
    var merge = __webpack_require__(7459);
    var stringify = __webpack_require__(8767);
    var identity = __webpack_require__(7182);
    var toJS = __webpack_require__(9126);

    function addPairToJSMap(ctx, map, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap) key.addToJSMap(ctx, map, value);
      // TODO: Should drop this special case for bare << handling
      else if (merge.isMergeKey(ctx, key)) merge.addMergeToJSMap(ctx, map, value);
      else {
        const jsKey = toJS.toJS(key, '', ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true,
            });
          else map[stringKey] = jsValue;
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null) return '';
      // eslint-disable-next-line @typescript-eslint/no-base-to-string
      if (typeof jsKey !== 'object') return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys()) strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40) jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(
            ctx.doc.options.logLevel,
            `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`,
          );
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }

    exports.addPairToJSMap = addPairToJSMap;

    /***/
  },

  /***/ 7923: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var visit = __webpack_require__(6695);

    const escapeChars = {
      '!': '%21',
      ',': '%2C',
      '[': '%5B',
      ']': '%5D',
      '{': '%7B',
      '}': '%7D',
    };
    const escapeTagName = tn => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
    class Directives {
      constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
      }
      clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case '1.1':
            this.atNextDocument = true;
            break;
          case '1.2':
            this.atNextDocument = false;
            this.yaml = {
              explicit: Directives.defaultYaml.explicit,
              version: '1.2',
            };
            this.tags = Object.assign({}, Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
          this.tags = Object.assign({}, Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case '%TAG': {
            if (parts.length !== 2) {
              onError(0, '%TAG directive should contain exactly two parts');
              if (parts.length < 2) return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case '%YAML': {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, '%YAML directive should contain exactly one part');
              return false;
            }
            const [version] = parts;
            if (version === '1.1' || version === '1.2') {
              this.yaml.version = version;
              return true;
            } else {
              const isValid = /^\d+\.\d+$/.test(version);
              onError(6, `Unsupported YAML version ${version}`, isValid);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === '!') return '!'; // non-specific tag
        if (source[0] !== '!') {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === '<') {
          const verbatim = source.slice(2, -1);
          if (verbatim === '!' || verbatim === '!!') {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== '>') onError('Verbatim tags must end with a >');
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix) onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === '!') return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix)) return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || '1.2'}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag) tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === '!!' && prefix === 'tag:yaml.org,2002:') continue;
          if (!doc || tagNames.some(tn => tn.startsWith(prefix))) lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
      }
    }
    Directives.defaultYaml = { explicit: false, version: '1.2' };
    Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

    exports.Directives = Directives;

    /***/
  },

  /***/ 7926: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    /* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */

    const EventEmitter = __webpack_require__(4434);
    const https = __webpack_require__(5692);
    const http = __webpack_require__(8611);
    const net = __webpack_require__(9278);
    const tls = __webpack_require__(4756);
    const { randomBytes, createHash } = __webpack_require__(6982);
    const { Duplex, Readable } = __webpack_require__(2203);
    const { URL } = __webpack_require__(7016);

    const PerMessageDeflate = __webpack_require__(4229);
    const Receiver = __webpack_require__(8348);
    const Sender = __webpack_require__(9364);
    const { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } =
      __webpack_require__(8936);
    const {
      EventTarget: { addEventListener, removeEventListener },
    } = __webpack_require__(4371);
    const { format, parse } = __webpack_require__(5824);
    const { toBuffer } = __webpack_require__(8732);

    const closeTimeout = 30 * 1000;
    const kAborted = Symbol('kAborted');
    const protocolVersions = [8, 13];
    const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
    const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

    /**
     * Class representing a WebSocket.
     *
     * @extends EventEmitter
     */
    class WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();

        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = '';
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;

        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;

          if (protocols === undefined) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === 'object' && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }

          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }

      /**
       * This deviates from the WHATWG interface since ws doesn't support the
       * required default "blob" type (instead we define a custom "nodebuffer"
       * type).
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }

      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;

        this._binaryType = type;

        //
        // Allow to change `binaryType` on the fly.
        //
        if (this._receiver) this._receiver._binaryType = type;
      }

      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;

        return this._socket._writableState.length + this._sender._bufferedBytes;
      }

      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }

      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }

      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }

      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }

      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }

      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }

      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }

      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }

      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }

      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation,
        });

        this._sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;

        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;

        receiver.on('conclude', receiverOnConclude);
        receiver.on('drain', receiverOnDrain);
        receiver.on('error', receiverOnError);
        receiver.on('message', receiverOnMessage);
        receiver.on('ping', receiverOnPing);
        receiver.on('pong', receiverOnPong);

        //
        // These methods may not be available if `socket` is just a `Duplex`.
        //
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();

        if (head.length > 0) socket.unshift(head);

        socket.on('close', socketOnClose);
        socket.on('data', socketOnData);
        socket.on('end', socketOnEnd);
        socket.on('error', socketOnError);

        this._readyState = WebSocket.OPEN;
        this.emit('open');
      }

      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit('close', this._closeCode, this._closeMessage);
          return;
        }

        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }

        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
      }

      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = 'WebSocket was closed before the connection was established';
          abortHandshake(this, this._req, msg);
          return;
        }

        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }

          return;
        }

        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, err => {
          //
          // This error is handled by the `'error'` listener on the socket. We only
          // want to know if the close frame has been sent here.
          //
          if (err) return;

          this._closeFrameSent = true;

          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });

        //
        // Specify a timeout for the closing handshake to complete.
        //
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }

      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }

        this._paused = true;
        this._socket.pause();
      }

      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }

        if (typeof data === 'function') {
          cb = data;
          data = mask = undefined;
        } else if (typeof mask === 'function') {
          cb = mask;
          mask = undefined;
        }

        if (typeof data === 'number') data = data.toString();

        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }

        if (mask === undefined) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }

      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }

        if (typeof data === 'function') {
          cb = data;
          data = mask = undefined;
        } else if (typeof mask === 'function') {
          cb = mask;
          mask = undefined;
        }

        if (typeof data === 'number') data = data.toString();

        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }

        if (mask === undefined) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }

      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }

        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }

      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
        }

        if (typeof options === 'function') {
          cb = options;
          options = {};
        }

        if (typeof data === 'number') data = data.toString();

        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }

        const opts = {
          binary: typeof data !== 'string',
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options,
        };

        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }

        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }

      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = 'WebSocket was closed before the connection was established';
          abortHandshake(this, this._req, msg);
          return;
        }

        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    }

    /**
     * @constant {Number} CONNECTING
     * @memberof WebSocket
     */
    Object.defineProperty(WebSocket, 'CONNECTING', {
      enumerable: true,
      value: readyStates.indexOf('CONNECTING'),
    });

    /**
     * @constant {Number} CONNECTING
     * @memberof WebSocket.prototype
     */
    Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
      enumerable: true,
      value: readyStates.indexOf('CONNECTING'),
    });

    /**
     * @constant {Number} OPEN
     * @memberof WebSocket
     */
    Object.defineProperty(WebSocket, 'OPEN', {
      enumerable: true,
      value: readyStates.indexOf('OPEN'),
    });

    /**
     * @constant {Number} OPEN
     * @memberof WebSocket.prototype
     */
    Object.defineProperty(WebSocket.prototype, 'OPEN', {
      enumerable: true,
      value: readyStates.indexOf('OPEN'),
    });

    /**
     * @constant {Number} CLOSING
     * @memberof WebSocket
     */
    Object.defineProperty(WebSocket, 'CLOSING', {
      enumerable: true,
      value: readyStates.indexOf('CLOSING'),
    });

    /**
     * @constant {Number} CLOSING
     * @memberof WebSocket.prototype
     */
    Object.defineProperty(WebSocket.prototype, 'CLOSING', {
      enumerable: true,
      value: readyStates.indexOf('CLOSING'),
    });

    /**
     * @constant {Number} CLOSED
     * @memberof WebSocket
     */
    Object.defineProperty(WebSocket, 'CLOSED', {
      enumerable: true,
      value: readyStates.indexOf('CLOSED'),
    });

    /**
     * @constant {Number} CLOSED
     * @memberof WebSocket.prototype
     */
    Object.defineProperty(WebSocket.prototype, 'CLOSED', {
      enumerable: true,
      value: readyStates.indexOf('CLOSED'),
    });

    ['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(property => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });

    //
    // Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
    // See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
    //
    ['open', 'error', 'close', 'message'].forEach(method => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }

          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }

          if (typeof handler !== 'function') return;

          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true,
          });
        },
      });
    });

    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;

    module.exports = WebSocket;

    /**
     * Initialize a WebSocket client.
     *
     * @param {WebSocket} websocket The client to initialize
     * @param {(String|URL)} address The URL to which to connect
     * @param {Array} protocols The subprotocols
     * @param {Object} [options] Connection options
     * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
     *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
     *     times in the same tick
     * @param {Boolean} [options.autoPong=true] Specifies whether or not to
     *     automatically send a pong in response to a ping
     * @param {Function} [options.finishRequest] A function which can be used to
     *     customize the headers of each http request before it is sent
     * @param {Boolean} [options.followRedirects=false] Whether or not to follow
     *     redirects
     * @param {Function} [options.generateMask] The function used to generate the
     *     masking key
     * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
     *     handshake request
     * @param {Number} [options.maxPayload=104857600] The maximum allowed message
     *     size
     * @param {Number} [options.maxRedirects=10] The maximum number of redirects
     *     allowed
     * @param {String} [options.origin] Value of the `Origin` or
     *     `Sec-WebSocket-Origin` header
     * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
     *     permessage-deflate
     * @param {Number} [options.protocolVersion=13] Value of the
     *     `Sec-WebSocket-Version` header
     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
     *     not to skip UTF-8 validation for text and close messages
     * @private
     */
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: undefined,
        hostname: undefined,
        protocol: undefined,
        timeout: undefined,
        method: 'GET',
        host: undefined,
        path: undefined,
        port: undefined,
      };

      websocket._autoPong = opts.autoPong;

      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} ` +
            `(supported versions: ${protocolVersions.join(', ')})`,
        );
      }

      let parsedUrl;

      if (address instanceof URL) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }

      if (parsedUrl.protocol === 'http:') {
        parsedUrl.protocol = 'ws:';
      } else if (parsedUrl.protocol === 'https:') {
        parsedUrl.protocol = 'wss:';
      }

      websocket._url = parsedUrl.href;

      const isSecure = parsedUrl.protocol === 'wss:';
      const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
      let invalidUrlMessage;

      if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
        invalidUrlMessage = 'The URL\'s protocol must be one of "ws:", "wss:", ' + '"http:", "https", or "ws+unix:"';
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = 'The URL contains a fragment identifier';
      }

      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);

        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }

      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString('base64');
      const request = isSecure ? https.request : http.request;
      const protocolSet = new Set();
      let perMessageDeflate;

      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        'Sec-WebSocket-Version': opts.protocolVersion,
        'Sec-WebSocket-Key': key,
        Connection: 'Upgrade',
        Upgrade: 'websocket',
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;

      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload,
        );
        opts.headers['Sec-WebSocket-Extensions'] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer(),
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError('An invalid or duplicated subprotocol was specified');
          }

          protocolSet.add(protocol);
        }

        opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers['Sec-WebSocket-Origin'] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }

      if (isIpcUrl) {
        const parts = opts.path.split(':');

        opts.socketPath = parts[0];
        opts.path = parts[1];
      }

      let req;

      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;

          const headers = options && options.headers;

          //
          // Shallow copy the user provided options so that headers can be changed
          // without mutating the original object.
          //
          options = { ...options, headers: {} };

          if (headers) {
            for (const [key, value] of Object.entries(headers)) {
              options.headers[key.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount('redirect') === 0) {
          const isSameHost = isIpcUrl
            ? websocket._originalIpc
              ? opts.socketPath === websocket._originalHostOrSocketPath
              : false
            : websocket._originalIpc
              ? false
              : parsedUrl.host === websocket._originalHostOrSocketPath;

          if (!isSameHost || (websocket._originalSecure && !isSecure)) {
            //
            // Match curl 7.77.0 behavior and drop the following headers. These
            // headers are also dropped when following a redirect to a subdomain.
            //
            delete opts.headers.authorization;
            delete opts.headers.cookie;

            if (!isSameHost) delete opts.headers.host;

            opts.auth = undefined;
          }
        }

        //
        // Match curl 7.77.0 behavior and make the first `Authorization` header win.
        // If the `Authorization` header is set, then there is nothing to do as it
        // will take precedence.
        //
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');
        }

        req = websocket._req = request(opts);

        if (websocket._redirects) {
          //
          // Unlike what is done for the `'upgrade'` event, no early exit is
          // triggered here if the user calls `websocket.close()` or
          // `websocket.terminate()` from a listener of the `'redirect'` event. This
          // is because the user can also call `request.destroy()` with an error
          // before calling `websocket.close()` or `websocket.terminate()` and this
          // would result in an error being emitted on the `request` object with no
          // `'error'` event listeners attached.
          //
          websocket.emit('redirect', websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }

      if (opts.timeout) {
        req.on('timeout', () => {
          abortHandshake(websocket, req, 'Opening handshake has timed out');
        });
      }

      req.on('error', err => {
        if (req === null || req[kAborted]) return;

        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });

      req.on('response', res => {
        const location = res.headers.location;
        const statusCode = res.statusCode;

        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, 'Maximum redirects exceeded');
            return;
          }

          req.abort();

          let addr;

          try {
            addr = new URL(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }

          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit('unexpected-response', req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });

      req.on('upgrade', (res, socket, head) => {
        websocket.emit('upgrade', res);

        //
        // The user may have closed the connection from a listener of the
        // `'upgrade'` event.
        //
        if (websocket.readyState !== WebSocket.CONNECTING) return;

        req = websocket._req = null;

        const upgrade = res.headers.upgrade;

        if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
          abortHandshake(websocket, socket, 'Invalid Upgrade header');
          return;
        }

        const digest = createHash('sha1')
          .update(key + GUID)
          .digest('base64');

        if (res.headers['sec-websocket-accept'] !== digest) {
          abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
          return;
        }

        const serverProt = res.headers['sec-websocket-protocol'];
        let protError;

        if (serverProt !== undefined) {
          if (!protocolSet.size) {
            protError = 'Server sent a subprotocol but none was requested';
          } else if (!protocolSet.has(serverProt)) {
            protError = 'Server sent an invalid subprotocol';
          }
        } else if (protocolSet.size) {
          protError = 'Server sent no subprotocol';
        }

        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }

        if (serverProt) websocket._protocol = serverProt;

        const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

        if (secWebSocketExtensions !== undefined) {
          if (!perMessageDeflate) {
            const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';
            abortHandshake(websocket, socket, message);
            return;
          }

          let extensions;

          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = 'Invalid Sec-WebSocket-Extensions header';
            abortHandshake(websocket, socket, message);
            return;
          }

          const extensionNames = Object.keys(extensions);

          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = 'Server indicated an extension that was not requested';
            abortHandshake(websocket, socket, message);
            return;
          }

          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = 'Invalid Sec-WebSocket-Extensions header';
            abortHandshake(websocket, socket, message);
            return;
          }

          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }

        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation,
        });
      });

      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }

    /**
     * Emit the `'error'` and `'close'` events.
     *
     * @param {WebSocket} websocket The WebSocket instance
     * @param {Error} The error to emit
     * @private
     */
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit('error', err);
      websocket.emitClose();
    }

    /**
     * Create a `net.Socket` and initiate a connection.
     *
     * @param {Object} options Connection options
     * @return {net.Socket} The newly created socket used to start the connection
     * @private
     */
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }

    /**
     * Create a `tls.TLSSocket` and initiate a connection.
     *
     * @param {Object} options Connection options
     * @return {tls.TLSSocket} The newly created socket used to start the connection
     * @private
     */
    function tlsConnect(options) {
      options.path = undefined;

      if (!options.servername && options.servername !== '') {
        options.servername = net.isIP(options.host) ? '' : options.host;
      }

      return tls.connect(options);
    }

    /**
     * Abort the handshake and emit an error.
     *
     * @param {WebSocket} websocket The WebSocket instance
     * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
     *     abort or the socket to destroy
     * @param {String} message The error message
     * @private
     */
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket.CLOSING;

      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);

      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();

        if (stream.socket && !stream.socket.destroyed) {
          //
          // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
          // called after the request completed. See
          // https://github.com/websockets/ws/issues/1869.
          //
          stream.socket.destroy();
        }

        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once('error', websocket.emit.bind(websocket, 'error'));
        stream.once('close', websocket.emitClose.bind(websocket));
      }
    }

    /**
     * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
     * when the `readyState` attribute is `CLOSING` or `CLOSED`.
     *
     * @param {WebSocket} websocket The WebSocket instance
     * @param {*} [data] The data to send
     * @param {Function} [cb] Callback
     * @private
     */
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;

        //
        // The `_bufferedAmount` property is used only when the peer is a client and
        // the opening handshake fails. Under these circumstances, in fact, the
        // `setSocket()` method is not called, so the `_socket` and `_sender`
        // properties are set to `null`.
        //
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }

      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`,
        );
        process.nextTick(cb, err);
      }
    }

    /**
     * The listener of the `Receiver` `'conclude'` event.
     *
     * @param {Number} code The status code
     * @param {Buffer} reason The reason for closing
     * @private
     */
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];

      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;

      if (websocket._socket[kWebSocket] === undefined) return;

      websocket._socket.removeListener('data', socketOnData);
      process.nextTick(resume, websocket._socket);

      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }

    /**
     * The listener of the `Receiver` `'drain'` event.
     *
     * @private
     */
    function receiverOnDrain() {
      const websocket = this[kWebSocket];

      if (!websocket.isPaused) websocket._socket.resume();
    }

    /**
     * The listener of the `Receiver` `'error'` event.
     *
     * @param {(RangeError|Error)} err The emitted error
     * @private
     */
    function receiverOnError(err) {
      const websocket = this[kWebSocket];

      if (websocket._socket[kWebSocket] !== undefined) {
        websocket._socket.removeListener('data', socketOnData);

        //
        // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
        // https://github.com/websockets/ws/issues/1940.
        //
        process.nextTick(resume, websocket._socket);

        websocket.close(err[kStatusCode]);
      }

      websocket.emit('error', err);
    }

    /**
     * The listener of the `Receiver` `'finish'` event.
     *
     * @private
     */
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }

    /**
     * The listener of the `Receiver` `'message'` event.
     *
     * @param {Buffer|ArrayBuffer|Buffer[])} data The message
     * @param {Boolean} isBinary Specifies whether the message is binary or not
     * @private
     */
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit('message', data, isBinary);
    }

    /**
     * The listener of the `Receiver` `'ping'` event.
     *
     * @param {Buffer} data The data included in the ping frame
     * @private
     */
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];

      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit('ping', data);
    }

    /**
     * The listener of the `Receiver` `'pong'` event.
     *
     * @param {Buffer} data The data included in the pong frame
     * @private
     */
    function receiverOnPong(data) {
      this[kWebSocket].emit('pong', data);
    }

    /**
     * Resume a readable stream
     *
     * @param {Readable} stream The readable stream
     * @private
     */
    function resume(stream) {
      stream.resume();
    }

    /**
     * The listener of the socket `'close'` event.
     *
     * @private
     */
    function socketOnClose() {
      const websocket = this[kWebSocket];

      this.removeListener('close', socketOnClose);
      this.removeListener('data', socketOnData);
      this.removeListener('end', socketOnEnd);

      websocket._readyState = WebSocket.CLOSING;

      let chunk;

      //
      // The close frame might not have been received or the `'end'` event emitted,
      // for example, if the socket was destroyed due to an error. Ensure that the
      // `receiver` stream is closed after writing any remaining buffered data to
      // it. If the readable side of the socket is in flowing mode then there is no
      // buffered data as everything has been already written and `readable.read()`
      // will return `null`. If instead, the socket is paused, any possible buffered
      // data will be read as a single chunk.
      //
      if (
        !this._readableState.endEmitted &&
        !websocket._closeFrameReceived &&
        !websocket._receiver._writableState.errorEmitted &&
        (chunk = websocket._socket.read()) !== null
      ) {
        websocket._receiver.write(chunk);
      }

      websocket._receiver.end();

      this[kWebSocket] = undefined;

      clearTimeout(websocket._closeTimer);

      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on('error', receiverOnFinish);
        websocket._receiver.on('finish', receiverOnFinish);
      }
    }

    /**
     * The listener of the socket `'data'` event.
     *
     * @param {Buffer} chunk A chunk of data
     * @private
     */
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }

    /**
     * The listener of the socket `'end'` event.
     *
     * @private
     */
    function socketOnEnd() {
      const websocket = this[kWebSocket];

      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }

    /**
     * The listener of the socket `'error'` event.
     *
     * @private
     */
    function socketOnError() {
      const websocket = this[kWebSocket];

      this.removeListener('error', socketOnError);
      this.on('error', NOOP);

      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }

    /***/
  },

  /***/ 7952: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var Scalar = __webpack_require__(6364);
    var YAMLMap = __webpack_require__(8741);
    var YAMLSeq = __webpack_require__(2016);
    var resolveBlockMap = __webpack_require__(704);
    var resolveBlockSeq = __webpack_require__(245);
    var resolveFlowCollection = __webpack_require__(5985);

    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll =
        token.type === 'block-map'
          ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)
          : token.type === 'block-seq'
            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      // If we got a tagName matching the class, or the tag name is '!',
      // then use the tagName from the node class used to create it.
      if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName) coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
      if (token.type === 'block-seq') {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp =
          anchor && tagToken ? (anchor.offset > tagToken.offset ? anchor : tagToken) : (anchor ?? tagToken);
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = 'Missing newline after block sequence props';
          onError(lastProp, 'MISSING_CHAR', message);
        }
      }
      const expType =
        token.type === 'block-map'
          ? 'map'
          : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
              ? 'map'
              : 'seq';
      // shortcut: check if it's a generic YAMLMap or YAMLSeq
      // before jumping into the custom tag logic.
      if (
        !tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq')
      ) {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt) {
            onError(
              tagToken,
              'BAD_COLLECTION_TYPE',
              `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`,
              true,
            );
          } else {
            onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format) node.format = tag.format;
      return node;
    }

    exports.composeCollection = composeCollection;

    /***/
  },

  /***/ 8047: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);
    var visit = __webpack_require__(6695);

    /**
     * Verify that the input string is a valid anchor.
     *
     * Will throw on errors.
     */
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor) anchors.add(node.anchor);
        },
      });
      return anchors;
    }
    /** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name)) return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = new Map();
      let prevAnchors = null;
      return {
        onAnchor: source => {
          aliasObjects.push(source);
          prevAnchors ?? (prevAnchors = anchorNames(doc));
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (
              typeof ref === 'object' &&
              ref.anchor &&
              (identity.isScalar(ref.node) || identity.isCollection(ref.node))
            ) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error('Failed to resolve repeated object (this should not happen)');
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects,
      };
    }

    exports.anchorIsValid = anchorIsValid;
    exports.anchorNames = anchorNames;
    exports.createNodeAnchors = createNodeAnchors;
    exports.findNewAnchor = findNewAnchor;

    /***/
  },

  /***/ 8069: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    const polling_1 = __webpack_require__(4898);
    const websocket_1 = __webpack_require__(1978);
    exports['default'] = {
      polling: polling_1.Polling,
      websocket: websocket_1.WebSocket,
    };

    /***/
  },

  /***/ 8113: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var Scalar = __webpack_require__(6364);
    var resolveEnd = __webpack_require__(191);

    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case 'scalar':
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case 'single-quoted-scalar':
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case 'double-quoted-scalar':
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
          return {
            value: '',
            type: null,
            comment: '',
            range: [offset, offset + source.length, offset + source.length],
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset],
      };
    }
    function plainValue(source, onError) {
      let badChar = '';
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
          badChar = 'a tab character';
          break;
        case ',':
          badChar = 'flow indicator character ,';
          break;
        case '%':
          badChar = 'directive indicator character %';
          break;
        case '|':
        case '>': {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case '@':
        case '`': {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar) onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      /**
       * The negative lookbehind here and in the `re` RegExp is to
       * prevent causing a polynomial search time in certain cases.
       *
       * The try-catch is for Safari, which doesn't support this yet:
       * https://caniuse.com/js-regexp-lookbehind
       */
      let first, line;
      try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match) return source;
      let res = match[1];
      let sep = ' ';
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while ((match = line.exec(source))) {
        if (match[1] === '') {
          if (sep === '\n') res += sep;
          else sep = '\n';
        } else {
          res += sep + match[1];
          sep = ' ';
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match?.[1] ?? '');
    }
    function doubleQuotedValue(source, onError) {
      let res = '';
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n') continue;
        if (ch === '\n') {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === '\\') {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc) res += cc;
          else if (next === '\n') {
            // skip escaped newlines, but still trim the following line
            next = source[i + 1];
            while (next === ' ' || next === '\t') next = source[++i + 1];
          } else if (next === '\r' && source[i + 1] === '\n') {
            // skip escaped CRLF newlines, but still trim the following line
            next = source[++i + 1];
            while (next === ' ' || next === '\t') next = source[++i + 1];
          } else if (next === 'x' || next === 'u' || next === 'U') {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === ' ' || ch === '\t') {
          // trim trailing whitespace
          const wsStart = i;
          let next = source[i + 1];
          while (next === ' ' || next === '\t') next = source[++i + 1];
          if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
      return res;
    }
    /**
     * Fold a single newline into a space, multiple newlines to N - 1 newlines.
     * Presumes `source[offset] === '\n'`
     */
    function foldNewline(source, offset) {
      let fold = '';
      let ch = source[offset + 1];
      while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n') break;
        if (ch === '\n') fold += '\n';
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold) fold = ' ';
      return { fold, offset };
    }
    const escapeCodes = {
      0: '\0', // null character
      a: '\x07', // bell character
      b: '\b', // backspace
      e: '\x1b', // escape character
      f: '\f', // form feed
      n: '\n', // line feed
      r: '\r', // carriage return
      t: '\t', // horizontal tab
      v: '\v', // vertical tab
      N: '\u0085', // Unicode next line
      _: '\u00a0', // Unicode non-breaking space
      L: '\u2028', // Unicode line separator
      P: '\u2029', // Unicode paragraph separator
      ' ': ' ',
      '"': '"',
      '/': '/',
      '\\': '\\',
      '\t': '\t',
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }

    exports.resolveFlowScalar = resolveFlowScalar;

    /***/
  },

  /***/ 8166: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var node_buffer = __webpack_require__(181);
    var Scalar = __webpack_require__(6364);
    var stringifyString = __webpack_require__(9850);

    const binary = {
      identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array
      default: false,
      tag: 'tag:yaml.org,2002:binary',
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof node_buffer.Buffer === 'function') {
          return node_buffer.Buffer.from(src, 'base64');
        } else if (typeof atob === 'function') {
          // On IE 11, atob() can't handle newlines
          const str = atob(src.replace(/[\n\r]/g, ''));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i) buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError('This environment does not support reading binary tags; either Buffer or atob is required');
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value) return '';
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof node_buffer.Buffer === 'function') {
          str =
            buf instanceof node_buffer.Buffer
              ? buf.toString('base64')
              : node_buffer.Buffer.from(buf.buffer).toString('base64');
        } else if (typeof btoa === 'function') {
          let s = '';
          for (let i = 0; i < buf.length; ++i) s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      },
    };

    exports.binary = binary;

    /***/
  },

  /***/ 8177: /***/ (__unused_webpack_module, exports) => {
    /**
     * Tracks newlines during parsing in order to provide an efficient API for
     * determining the one-indexed `{ line, col }` position for any offset
     * within the input.
     */
    class LineCounter {
      constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = offset => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = offset => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
            if (this.lineStarts[mid] < offset) low = mid + 1;
            else high = mid;
          }
          if (this.lineStarts[low] === offset) return { line: low + 1, col: 1 };
          if (low === 0) return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    }

    exports.LineCounter = LineCounter;

    /***/
  },

  /***/ 8348: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const { Writable } = __webpack_require__(2203);

    const PerMessageDeflate = __webpack_require__(4229);
    const { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __webpack_require__(8936);
    const { concat, toArrayBuffer, unmask } = __webpack_require__(8732);
    const { isValidStatusCode, isValidUTF8 } = __webpack_require__(1610);

    const FastBuffer = Buffer[Symbol.species];

    const GET_INFO = 0;
    const GET_PAYLOAD_LENGTH_16 = 1;
    const GET_PAYLOAD_LENGTH_64 = 2;
    const GET_MASK = 3;
    const GET_DATA = 4;
    const INFLATING = 5;
    const DEFER_EVENT = 6;

    /**
     * HyBi Receiver implementation.
     *
     * @extends Writable
     */
    class Receiver extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();

        this._allowSynchronousEvents =
          options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = undefined;

        this._bufferedBytes = 0;
        this._buffers = [];

        this._compressed = false;
        this._payloadLength = 0;
        this._mask = undefined;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;

        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];

        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }

      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }

      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;

        if (n === this._buffers[0].length) return this._buffers.shift();

        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);

          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }

        const dst = Buffer.allocUnsafe(n);

        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;

          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
          }

          n -= buf.length;
        } while (n > 0);

        return dst;
      }

      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;

        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);

        if (!this._errored) cb();
      }

      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }

        const buf = this.consume(2);

        if ((buf[0] & 0x30) !== 0x00) {
          const error = this.createError(
            RangeError,
            'RSV2 and RSV3 must be clear',
            true,
            1002,
            'WS_ERR_UNEXPECTED_RSV_2_3',
          );

          cb(error);
          return;
        }

        const compressed = (buf[0] & 0x40) === 0x40;

        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');

          cb(error);
          return;
        }

        this._fin = (buf[0] & 0x80) === 0x80;
        this._opcode = buf[0] & 0x0f;
        this._payloadLength = buf[1] & 0x7f;

        if (this._opcode === 0x00) {
          if (compressed) {
            const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');

            cb(error);
            return;
          }

          if (!this._fragmented) {
            const error = this.createError(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');

            cb(error);
            return;
          }

          this._opcode = this._fragmented;
        } else if (this._opcode === 0x01 || this._opcode === 0x02) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              'WS_ERR_INVALID_OPCODE',
            );

            cb(error);
            return;
          }

          this._compressed = compressed;
        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
          if (!this._fin) {
            const error = this.createError(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');

            cb(error);
            return;
          }

          if (compressed) {
            const error = this.createError(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');

            cb(error);
            return;
          }

          if (this._payloadLength > 0x7d || (this._opcode === 0x08 && this._payloadLength === 1)) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH',
            );

            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            'WS_ERR_INVALID_OPCODE',
          );

          cb(error);
          return;
        }

        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 0x80) === 0x80;

        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');

            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');

          cb(error);
          return;
        }

        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }

      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }

        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }

      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }

        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);

        //
        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
        // if payload length is greater than this number.
        //
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            'Unsupported WebSocket frame: payload length > 2^53 - 1',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH',
          );

          cb(error);
          return;
        }

        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }

      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 0x08) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              'Max payload size exceeded',
              false,
              1009,
              'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH',
            );

            cb(error);
            return;
          }
        }

        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }

      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }

        this._mask = this.consume(4);
        this._state = GET_DATA;
      }

      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;

        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }

          data = this.consume(this._payloadLength);

          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }

        if (this._opcode > 0x07) {
          this.controlMessage(data, cb);
          return;
        }

        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }

        if (data.length) {
          //
          // This message is not compressed so its length is the sum of the payload
          // length of all fragments.
          //
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }

        this.dataMessage(cb);
      }

      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);

          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                'Max payload size exceeded',
                false,
                1009,
                'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH',
              );

              cb(error);
              return;
            }

            this._fragments.push(buf);
          }

          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }

      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }

        const messageLength = this._messageLength;
        const fragments = this._fragments;

        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];

        if (this._opcode === 2) {
          let data;

          if (this._binaryType === 'nodebuffer') {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === 'arraybuffer') {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }

          if (this._allowSynchronousEvents) {
            this.emit('message', data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit('message', data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);

          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');

            cb(error);
            return;
          }

          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit('message', buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit('message', buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }

      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 0x08) {
          if (data.length === 0) {
            this._loop = false;
            this.emit('conclude', 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);

            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                'WS_ERR_INVALID_CLOSE_CODE',
              );

              cb(error);
              return;
            }

            const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);

            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');

              cb(error);
              return;
            }

            this._loop = false;
            this.emit('conclude', code, buf);
            this.end();
          }

          this._state = GET_INFO;
          return;
        }

        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }

      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;

        const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);

        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    }

    module.exports = Receiver;

    /***/
  },

  /***/ 8417: /***/ module => {
    /**
     * negotiator
     * Copyright(c) 2012 Isaac Z. Schlueter
     * Copyright(c) 2014 Federico Romero
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module exports.
     * @public
     */

    module.exports = preferredEncodings;
    module.exports.preferredEncodings = preferredEncodings;

    /**
     * Module variables.
     * @private
     */

    var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

    /**
     * Parse the Accept-Encoding header.
     * @private
     */

    function parseAcceptEncoding(accept) {
      var accepts = accept.split(',');
      var hasIdentity = false;
      var minQuality = 1;

      for (var i = 0, j = 0; i < accepts.length; i++) {
        var encoding = parseEncoding(accepts[i].trim(), i);

        if (encoding) {
          accepts[j++] = encoding;
          hasIdentity = hasIdentity || specify('identity', encoding);
          minQuality = Math.min(minQuality, encoding.q || 1);
        }
      }

      if (!hasIdentity) {
        /*
         * If identity doesn't explicitly appear in the accept-encoding header,
         * it's added to the list of acceptable encoding with the lowest q
         */
        accepts[j++] = {
          encoding: 'identity',
          q: minQuality,
          i: i,
        };
      }

      // trim accepts
      accepts.length = j;

      return accepts;
    }

    /**
     * Parse an encoding from the Accept-Encoding header.
     * @private
     */

    function parseEncoding(str, i) {
      var match = simpleEncodingRegExp.exec(str);
      if (!match) return null;

      var encoding = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(';');
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split('=');
          if (p[0] === 'q') {
            q = parseFloat(p[1]);
            break;
          }
        }
      }

      return {
        encoding: encoding,
        q: q,
        i: i,
      };
    }

    /**
     * Get the priority of an encoding.
     * @private
     */

    function getEncodingPriority(encoding, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };

      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(encoding, accepted[i], index);

        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }

      return priority;
    }

    /**
     * Get the specificity of the encoding.
     * @private
     */

    function specify(encoding, spec, index) {
      var s = 0;
      if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
        s |= 1;
      } else if (spec.encoding !== '*') {
        return null;
      }

      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s,
      };
    }

    /**
     * Get the preferred encodings from an Accept-Encoding header.
     * @public
     */

    function preferredEncodings(accept, provided) {
      var accepts = parseAcceptEncoding(accept || '');

      if (!provided) {
        // sorted list of all encodings
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
      }

      var priorities = provided.map(function getPriority(type, index) {
        return getEncodingPriority(type, accepts, index);
      });

      // sorted list of accepted encodings
      return priorities
        .filter(isQuality)
        .sort(compareSpecs)
        .map(function getEncoding(priority) {
          return provided[priorities.indexOf(priority)];
        });
    }

    /**
     * Compare two specs.
     * @private
     */

    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }

    /**
     * Get full encoding string.
     * @private
     */

    function getFullEncoding(spec) {
      return spec.encoding;
    }

    /**
     * Check if a spec has any quality.
     * @private
     */

    function isQuality(spec) {
      return spec.q > 0;
    }

    /***/
  },

  /***/ 8452: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var composer = __webpack_require__(4045);
    var Document = __webpack_require__(7404);
    var Schema = __webpack_require__(407);
    var errors = __webpack_require__(6101);
    var Alias = __webpack_require__(9814);
    var identity = __webpack_require__(7182);
    var Pair = __webpack_require__(6544);
    var Scalar = __webpack_require__(6364);
    var YAMLMap = __webpack_require__(8741);
    var YAMLSeq = __webpack_require__(2016);
    var cst = __webpack_require__(7062);
    var lexer = __webpack_require__(1322);
    var lineCounter = __webpack_require__(8177);
    var parser = __webpack_require__(3893);
    var publicApi = __webpack_require__(7682);
    var visit = __webpack_require__(6695);

    exports.Composer = composer.Composer;
    exports.Document = Document.Document;
    exports.Schema = Schema.Schema;
    exports.YAMLError = errors.YAMLError;
    exports.YAMLParseError = errors.YAMLParseError;
    exports.YAMLWarning = errors.YAMLWarning;
    exports.Alias = Alias.Alias;
    exports.isAlias = identity.isAlias;
    exports.isCollection = identity.isCollection;
    exports.isDocument = identity.isDocument;
    exports.isMap = identity.isMap;
    exports.isNode = identity.isNode;
    exports.isPair = identity.isPair;
    exports.isScalar = identity.isScalar;
    exports.isSeq = identity.isSeq;
    exports.Pair = Pair.Pair;
    exports.Scalar = Scalar.Scalar;
    exports.YAMLMap = YAMLMap.YAMLMap;
    exports.YAMLSeq = YAMLSeq.YAMLSeq;
    exports.CST = cst;
    exports.Lexer = lexer.Lexer;
    exports.LineCounter = lineCounter.LineCounter;
    exports.Parser = parser.Parser;
    exports.parse = publicApi.parse;
    exports.parseAllDocuments = publicApi.parseAllDocuments;
    exports.parseDocument = publicApi.parseDocument;
    exports.stringify = publicApi.stringify;
    exports.visit = visit.visit;
    exports.visitAsync = visit.visitAsync;

    /***/
  },

  /***/ 8474: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('node:events');

    /***/
  },

  /***/ 8510: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.WebSocket = void 0;
    const transport_1 = __webpack_require__(2879);
    const debug_1 = __webpack_require__(1106);
    const debug = (0, debug_1.default)('engine:ws');
    class WebSocket extends transport_1.Transport {
      /**
       * WebSocket transport
       *
       * @param {EngineRequest} req
       */
      constructor(req) {
        super(req);
        this._doSend = data => {
          this.socket.send(data, this._onSent);
        };
        this._doSendLast = data => {
          this.socket.send(data, this._onSentLast);
        };
        this._onSent = err => {
          if (err) {
            this.onError('write error', err.stack);
          }
        };
        this._onSentLast = err => {
          if (err) {
            this.onError('write error', err.stack);
          } else {
            this.emit('drain');
            this.writable = true;
            this.emit('ready');
          }
        };
        this.socket = req.websocket;
        this.socket.on('message', (data, isBinary) => {
          const message = isBinary ? data : data.toString();
          debug('received "%s"', message);
          super.onData(message);
        });
        this.socket.once('close', this.onClose.bind(this));
        this.socket.on('error', this.onError.bind(this));
        this.writable = true;
        this.perMessageDeflate = null;
      }
      /**
       * Transport name
       */
      get name() {
        return 'websocket';
      }
      /**
       * Advertise upgrade support.
       */
      get handlesUpgrades() {
        return true;
      }
      send(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const isLast = i + 1 === packets.length;
          if (this._canSendPreEncodedFrame(packet)) {
            // the WebSocket frame was computed with WebSocket.Sender.frame()
            // see https://github.com/websockets/ws/issues/617#issuecomment-283002469
            this.socket._sender.sendFrame(
              // @ts-ignore
              packet.options.wsPreEncodedFrame,
              isLast ? this._onSentLast : this._onSent,
            );
          } else {
            this.parser.encodePacket(packet, this.supportsBinary, isLast ? this._doSendLast : this._doSend);
          }
        }
      }
      /**
       * Whether the encoding of the WebSocket frame can be skipped.
       * @param packet
       * @private
       */
      _canSendPreEncodedFrame(packet) {
        var _a, _b, _c;
        return (
          !this.perMessageDeflate &&
          typeof ((_b = (_a = this.socket) === null || _a === void 0 ? void 0 : _a._sender) === null || _b === void 0
            ? void 0
            : _b.sendFrame) === 'function' &&
          // @ts-ignore
          ((_c = packet.options) === null || _c === void 0 ? void 0 : _c.wsPreEncodedFrame) !== undefined
        );
      }
      doClose(fn) {
        debug('closing');
        this.socket.close();
        fn && fn();
      }
    }
    exports.WebSocket = WebSocket;

    /***/
  },

  /***/ 8578: /***/ (__unused_webpack_module, exports) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.RESERVED_EVENTS = void 0;
    exports.RESERVED_EVENTS = new Set([
      'connect',
      'connect_error',
      'disconnect',
      'disconnecting',
      'newListener',
      'removeListener',
    ]);

    /***/
  },

  /***/ 8611: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('http');

    /***/
  },

  /***/ 8723: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.MessageType =
      exports.ClusterAdapterWithHeartbeat =
      exports.ClusterAdapter =
      exports.SessionAwareAdapter =
      exports.Adapter =
        void 0;
    var in_memory_adapter_1 = __webpack_require__(9595);
    Object.defineProperty(exports, 'Adapter', {
      enumerable: true,
      get: function () {
        return in_memory_adapter_1.Adapter;
      },
    });
    Object.defineProperty(exports, 'SessionAwareAdapter', {
      enumerable: true,
      get: function () {
        return in_memory_adapter_1.SessionAwareAdapter;
      },
    });
    var cluster_adapter_1 = __webpack_require__(2443);
    Object.defineProperty(exports, 'ClusterAdapter', {
      enumerable: true,
      get: function () {
        return cluster_adapter_1.ClusterAdapter;
      },
    });
    Object.defineProperty(exports, 'ClusterAdapterWithHeartbeat', {
      enumerable: true,
      get: function () {
        return cluster_adapter_1.ClusterAdapterWithHeartbeat;
      },
    });
    Object.defineProperty(exports, 'MessageType', {
      enumerable: true,
      get: function () {
        return cluster_adapter_1.MessageType;
      },
    });

    /***/
  },

  /***/ 8732: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const { EMPTY_BUFFER } = __webpack_require__(8936);

    const FastBuffer = Buffer[Symbol.species];

    /**
     * Merges an array of buffers into a new buffer.
     *
     * @param {Buffer[]} list The array of buffers to concat
     * @param {Number} totalLength The total length of buffers in the list
     * @return {Buffer} The resulting buffer
     * @public
     */
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];

      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;

      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }

      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }

      return target;
    }

    /**
     * Masks a buffer using the given mask.
     *
     * @param {Buffer} source The buffer to mask
     * @param {Buffer} mask The mask to use
     * @param {Buffer} output The buffer where to store the result
     * @param {Number} offset The offset at which to start writing
     * @param {Number} length The number of bytes to mask.
     * @public
     */
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }

    /**
     * Unmasks a buffer using the given mask.
     *
     * @param {Buffer} buffer The buffer to unmask
     * @param {Buffer} mask The mask to use
     * @public
     */
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }

    /**
     * Converts a buffer to an `ArrayBuffer`.
     *
     * @param {Buffer} buf The buffer to convert
     * @return {ArrayBuffer} Converted buffer
     * @public
     */
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }

      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }

    /**
     * Converts `data` to a `Buffer`.
     *
     * @param {*} data The data to convert
     * @return {Buffer} The buffer
     * @throws {TypeError}
     * @public
     */
    function toBuffer(data) {
      toBuffer.readOnly = true;

      if (Buffer.isBuffer(data)) return data;

      let buf;

      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }

      return buf;
    }

    module.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask,
    };

    /* istanbul ignore else  */
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = __webpack_require__(4681);

        module.exports.mask = function (source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };

        module.exports.unmask = function (buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
        // Continue regardless of the error.
      }
    }

    /***/
  },

  /***/ 8741: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var stringifyCollection = __webpack_require__(7515);
    var addPairToJSMap = __webpack_require__(7825);
    var Collection = __webpack_require__(5920);
    var identity = __webpack_require__(7182);
    var Pair = __webpack_require__(6544);
    var Scalar = __webpack_require__(6364);

    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k) return it;
          if (identity.isScalar(it.key) && it.key.value === k) return it;
        }
      }
      return undefined;
    }
    class YAMLMap extends Collection.Collection {
      static get tagName() {
        return 'tag:yaml.org,2002:map';
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === 'function') value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key)) return;
          if (value !== undefined || keepUndefined) map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj) add(key, value);
        } else if (obj && typeof obj === 'object') {
          for (const key of Object.keys(obj)) add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
          map.items.sort(schema.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair)) _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
          // In TypeScript, this never happens.
          _pair = new Pair.Pair(pair, pair?.value);
        } else _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite) throw new Error(`Key ${_pair.key} already set`);
          // For scalars, keep the old node & its comments and anchors
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value)) prev.value.value = _pair.value;
          else prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
          if (i === -1) this.items.push(_pair);
          else this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it) return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate) ctx.onCreate(map);
        for (const item of this.items) addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx) return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false)) ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: '',
          flowChars: { start: '{', end: '}' },
          itemIndent: ctx.indent || '',
          onChompKeep,
          onComment,
        });
      }
    }

    exports.YAMLMap = YAMLMap;
    exports.findPair = findPair;

    /***/
  },

  /***/ 8767: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var anchors = __webpack_require__(8047);
    var identity = __webpack_require__(7182);
    var stringifyComment = __webpack_require__(3774);
    var stringifyString = __webpack_require__(9850);

    function createStringifyContext(doc, options) {
      const opt = Object.assign(
        {
          blockQuote: true,
          commentString: stringifyComment.stringifyComment,
          defaultKeyType: null,
          defaultStringType: 'PLAIN',
          directives: null,
          doubleQuotedAsJSON: false,
          doubleQuotedMinMultiLineLength: 40,
          falseStr: 'false',
          flowCollectionPadding: true,
          indentSeq: true,
          lineWidth: 80,
          minContentWidth: 20,
          nullStr: 'null',
          simpleKeys: false,
          singleQuote: null,
          trueStr: 'true',
          verifyAliasOrder: true,
        },
        doc.schema.toStringOptions,
        options,
      );
      let inFlow;
      switch (opt.collectionStyle) {
        case 'block':
          inFlow = false;
          break;
        case 'flow':
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt,
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0) return match.find(t => t.format === item.format) ?? match[0];
      }
      let tagObj = undefined;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter(t => t.identify?.(obj));
        if (match.length > 1) {
          const testMatch = match.filter(t => t.test);
          if (testMatch.length > 0) match = testMatch;
        }
        tagObj = match.find(t => t.format === item.format) ?? match.find(t => !t.format);
      } else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? 'null' : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    // needs to be called before value stringifier to allow for circular anchor refs
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives) return '';
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
      if (tag) props.push(doc.directives.tagString(tag));
      return props.join(' ');
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item)) return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives) return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases) ctx.resolvedAliases.add(item);
          else ctx.resolvedAliases = new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = undefined;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
      tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str =
        typeof tagObj.stringify === 'function'
          ? tagObj.stringify(node, ctx, onComment, onChompKeep)
          : identity.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
      if (!props) return str;
      return identity.isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
    }

    exports.createStringifyContext = createStringifyContext;
    exports.stringify = stringify;

    /***/
  },

  /***/ 8773: /***/ module => {
    const kDone = Symbol('kDone');
    const kRun = Symbol('kRun');

    /**
     * A very simple job queue with adjustable concurrency. Adapted from
     * https://github.com/STRML/async-limiter
     */
    class Limiter {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }

      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }

      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;

        if (this.jobs.length) {
          const job = this.jobs.shift();

          this.pending++;
          job(this[kDone]);
        }
      }
    }

    module.exports = Limiter;

    /***/
  },

  /***/ 8873: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    const polling_1 = __webpack_require__(5718);
    const polling_jsonp_1 = __webpack_require__(7025);
    const websocket_1 = __webpack_require__(8510);
    const webtransport_1 = __webpack_require__(9218);
    exports['default'] = {
      polling: polling,
      websocket: websocket_1.WebSocket,
      webtransport: webtransport_1.WebTransport,
    };
    /**
     * Polling polymorphic constructor.
     */
    function polling(req) {
      if ('string' === typeof req._query.j) {
        return new polling_jsonp_1.JSONP(req);
      } else {
        return new polling_1.Polling(req);
      }
    }
    polling.upgradesTo = ['websocket', 'webtransport'];

    /***/
  },

  /***/ 8915: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const { Argument } = __webpack_require__(1292);
    const { Command } = __webpack_require__(146);
    const { CommanderError, InvalidArgumentError } = __webpack_require__(6729);
    const { Help } = __webpack_require__(9736);
    const { Option } = __webpack_require__(1490);

    exports.DM = new Command();

    exports.gu = name => new Command(name);
    exports.Ww = (flags, description) => new Option(flags, description);
    exports.er = (name, description) => new Argument(name, description);

    /**
     * Expose classes
     */

    exports.uB = Command;
    exports.c$ = Option;
    exports.ef = Argument;
    exports._V = Help;

    exports.b7 = CommanderError;
    exports.Di = InvalidArgumentError;
    exports.a2 = InvalidArgumentError; // Deprecated

    /***/
  },

  /***/ 8936: /***/ module => {
    module.exports = {
      BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
      kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
      kListener: Symbol('kListener'),
      kStatusCode: Symbol('status-code'),
      kWebSocket: Symbol('websocket'),
      NOOP: () => {},
    };

    /***/
  },

  /***/ 8958: /***/ module => {
    /**
     * negotiator
     * Copyright(c) 2012 Isaac Z. Schlueter
     * Copyright(c) 2014 Federico Romero
     * Copyright(c) 2014-2015 Douglas Christopher Wilson
     * MIT Licensed
     */

    /**
     * Module exports.
     * @public
     */

    module.exports = preferredCharsets;
    module.exports.preferredCharsets = preferredCharsets;

    /**
     * Module variables.
     * @private
     */

    var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;

    /**
     * Parse the Accept-Charset header.
     * @private
     */

    function parseAcceptCharset(accept) {
      var accepts = accept.split(',');

      for (var i = 0, j = 0; i < accepts.length; i++) {
        var charset = parseCharset(accepts[i].trim(), i);

        if (charset) {
          accepts[j++] = charset;
        }
      }

      // trim accepts
      accepts.length = j;

      return accepts;
    }

    /**
     * Parse a charset from the Accept-Charset header.
     * @private
     */

    function parseCharset(str, i) {
      var match = simpleCharsetRegExp.exec(str);
      if (!match) return null;

      var charset = match[1];
      var q = 1;
      if (match[2]) {
        var params = match[2].split(';');
        for (var j = 0; j < params.length; j++) {
          var p = params[j].trim().split('=');
          if (p[0] === 'q') {
            q = parseFloat(p[1]);
            break;
          }
        }
      }

      return {
        charset: charset,
        q: q,
        i: i,
      };
    }

    /**
     * Get the priority of a charset.
     * @private
     */

    function getCharsetPriority(charset, accepted, index) {
      var priority = { o: -1, q: 0, s: 0 };

      for (var i = 0; i < accepted.length; i++) {
        var spec = specify(charset, accepted[i], index);

        if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
          priority = spec;
        }
      }

      return priority;
    }

    /**
     * Get the specificity of the charset.
     * @private
     */

    function specify(charset, spec, index) {
      var s = 0;
      if (spec.charset.toLowerCase() === charset.toLowerCase()) {
        s |= 1;
      } else if (spec.charset !== '*') {
        return null;
      }

      return {
        i: index,
        o: spec.i,
        q: spec.q,
        s: s,
      };
    }

    /**
     * Get the preferred charsets from an Accept-Charset header.
     * @public
     */

    function preferredCharsets(accept, provided) {
      // RFC 2616 sec 14.2: no header = *
      var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

      if (!provided) {
        // sorted list of all charsets
        return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
      }

      var priorities = provided.map(function getPriority(type, index) {
        return getCharsetPriority(type, accepts, index);
      });

      // sorted list of accepted charsets
      return priorities
        .filter(isQuality)
        .sort(compareSpecs)
        .map(function getCharset(priority) {
          return provided[priorities.indexOf(priority)];
        });
    }

    /**
     * Compare two specs.
     * @private
     */

    function compareSpecs(a, b) {
      return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
    }

    /**
     * Get full charset string.
     * @private
     */

    function getFullCharset(spec) {
      return spec.charset;
    }

    /**
     * Check if a spec has any quality.
     * @private
     */

    function isQuality(spec) {
      return spec.q > 0;
    }

    /***/
  },

  /***/ 9023: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('util');

    /***/
  },

  /***/ 9049: /***/ module => {
    /**
     * Helpers.
     */

    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    module.exports = function (val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match =
        /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str,
        );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'weeks':
        case 'week':
        case 'w':
          return n * w;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
      }
      return ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
    }

    /***/
  },

  /***/ 9126: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var identity = __webpack_require__(7182);

    /**
     * Recursively convert any node or its contents to native JavaScript
     *
     * @param value - The input value
     * @param arg - If `value` defines a `toJSON()` method, use this
     *   as its first argument
     * @param ctx - Conversion context, originally set in Document#toJS(). If
     *   `{ keep: true }` is not set, output should be suitable for JSON
     *   stringification.
     */
    function toJS(value, arg, ctx) {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return
      if (Array.isArray(value)) return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !identity.hasAnchor(value)) return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
          data.res = res;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate) ctx.onCreate(res);
        return res;
      }
      if (typeof value === 'bigint' && !ctx?.keep) return Number(value);
      return value;
    }

    exports.toJS = toJS;

    /***/
  },

  /***/ 9218: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.WebTransport = void 0;
    const transport_1 = __webpack_require__(2879);
    const debug_1 = __webpack_require__(1106);
    const engine_io_parser_1 = __webpack_require__(2680);
    const debug = (0, debug_1.default)('engine:webtransport');
    /**
     * Reference: https://developer.mozilla.org/en-US/docs/Web/API/WebTransport_API
     */
    class WebTransport extends transport_1.Transport {
      constructor(session, stream, reader) {
        super({ _query: { EIO: '4' } });
        this.session = session;
        const transformStream = (0, engine_io_parser_1.createPacketEncoderStream)();
        transformStream.readable.pipeTo(stream.writable).catch(() => {
          debug('the stream was closed');
        });
        this.writer = transformStream.writable.getWriter();
        (async () => {
          try {
            while (true) {
              const { value, done } = await reader.read();
              if (done) {
                debug('session is closed');
                break;
              }
              debug('received chunk: %o', value);
              this.onPacket(value);
            }
          } catch (e) {
            debug('error while reading: %s', e.message);
          }
        })();
        session.closed.then(() => this.onClose());
        this.writable = true;
      }
      get name() {
        return 'webtransport';
      }
      async send(packets) {
        this.writable = false;
        try {
          for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            await this.writer.write(packet);
          }
        } catch (e) {
          debug('error while writing: %s', e.message);
        }
        this.emit('drain');
        this.writable = true;
        this.emit('ready');
      }
      doClose(fn) {
        debug('closing WebTransport session');
        this.session.close();
        fn && fn();
      }
    }
    exports.WebTransport = WebTransport;

    /***/
  },

  /***/ 9278: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('net');

    /***/
  },

  /***/ 9318: /***/ function (__unused_webpack_module, exports, __webpack_require__) {
    var __importDefault =
      (this && this.__importDefault) ||
      function (mod) {
        return mod && mod.__esModule ? mod : { default: mod };
      };
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.patchAdapter = patchAdapter;
    exports.restoreAdapter = restoreAdapter;
    exports.serveFile = serveFile;
    const socket_io_adapter_1 = __webpack_require__(8723);
    const fs_1 = __webpack_require__(9896);
    const debug_1 = __importDefault(__webpack_require__(1106));
    const debug = (0, debug_1.default)('socket.io:adapter-uws');
    const SEPARATOR = '\x1f'; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text
    const { addAll, del, broadcast } = socket_io_adapter_1.Adapter.prototype;
    function patchAdapter(app /* : TemplatedApp */) {
      socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {
        const isNew = !this.sids.has(id);
        addAll.call(this, id, rooms);
        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);
        if (!socket) {
          return;
        }
        if (socket.conn.transport.name === 'websocket') {
          subscribe(this.nsp.name, socket, isNew, rooms);
          return;
        }
        if (isNew) {
          socket.conn.on('upgrade', () => {
            const rooms = this.sids.get(id);
            if (rooms) {
              subscribe(this.nsp.name, socket, isNew, rooms);
            }
          });
        }
      };
      socket_io_adapter_1.Adapter.prototype.del = function (id, room) {
        del.call(this, id, room);
        const socket = this.nsp.sockets.get(id) || this.nsp._preConnectSockets.get(id);
        if (socket && socket.conn.transport.name === 'websocket') {
          // @ts-ignore
          const sessionId = socket.conn.id;
          // @ts-ignore
          const websocket = socket.conn.transport.socket;
          const topic = `${this.nsp.name}${SEPARATOR}${room}`;
          debug('unsubscribe connection %s from topic %s', sessionId, topic);
          websocket.unsubscribe(topic);
        }
      };
      socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {
        const useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;
        if (!useFastPublish) {
          broadcast.call(this, packet, opts);
          return;
        }
        const flags = opts.flags || {};
        const basePacketOpts = {
          preEncoded: true,
          volatile: flags.volatile,
          compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        const encodedPackets = this.encoder.encode(packet);
        const topic =
          opts.rooms.size === 0 ? this.nsp.name : `${this.nsp.name}${SEPARATOR}${opts.rooms.keys().next().value}`;
        debug('fast publish to %s', topic);
        // fast publish for clients connected with WebSocket
        encodedPackets.forEach(encodedPacket => {
          const isBinary = typeof encodedPacket !== 'string';
          // "4" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol
          app.publish(topic, isBinary ? encodedPacket : '4' + encodedPacket, isBinary);
        });
        this.apply(opts, socket => {
          if (socket.conn.transport.name !== 'websocket') {
            // classic publish for clients connected with HTTP long-polling
            socket.client.writeToEngine(encodedPackets, basePacketOpts);
          }
        });
      };
    }
    function subscribe(namespaceName, socket, isNew, rooms) {
      // @ts-ignore
      const sessionId = socket.conn.id;
      // @ts-ignore
      const websocket = socket.conn.transport.socket;
      if (isNew) {
        debug('subscribe connection %s to topic %s', sessionId, namespaceName);
        websocket.subscribe(namespaceName);
      }
      rooms.forEach(room => {
        const topic = `${namespaceName}${SEPARATOR}${room}`; // '#' can be used as wildcard
        debug('subscribe connection %s to topic %s', sessionId, topic);
        websocket.subscribe(topic);
      });
    }
    function restoreAdapter() {
      socket_io_adapter_1.Adapter.prototype.addAll = addAll;
      socket_io_adapter_1.Adapter.prototype.del = del;
      socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
    }
    const toArrayBuffer = buffer => {
      const { buffer: arrayBuffer, byteOffset, byteLength } = buffer;
      return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
    };
    // imported from https://github.com/kolodziejczak-sz/uwebsocket-serve
    function serveFile(res /* : HttpResponse */, filepath) {
      const { size } = (0, fs_1.statSync)(filepath);
      const readStream = (0, fs_1.createReadStream)(filepath);
      const destroyReadStream = () => !readStream.destroyed && readStream.destroy();
      const onError = error => {
        destroyReadStream();
        throw error;
      };
      const onDataChunk = chunk => {
        const arrayBufferChunk = toArrayBuffer(chunk);
        res.cork(() => {
          const lastOffset = res.getWriteOffset();
          const [ok, done] = res.tryEnd(arrayBufferChunk, size);
          if (!done && !ok) {
            readStream.pause();
            res.onWritable(offset => {
              const [ok, done] = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size);
              if (!done && ok) {
                readStream.resume();
              }
              return ok;
            });
          }
        });
      };
      res.onAborted(destroyReadStream);
      readStream.on('data', onDataChunk).on('error', onError).on('end', destroyReadStream);
    }

    /***/
  },

  /***/ 9364: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    /* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */

    const { Duplex } = __webpack_require__(2203);
    const { randomFillSync } = __webpack_require__(6982);

    const PerMessageDeflate = __webpack_require__(4229);
    const { EMPTY_BUFFER } = __webpack_require__(8936);
    const { isValidStatusCode } = __webpack_require__(1610);
    const { mask: applyMask, toBuffer } = __webpack_require__(8732);

    const kByteLength = Symbol('kByteLength');
    const maskBuffer = Buffer.alloc(4);
    const RANDOM_POOL_SIZE = 8 * 1024;
    let randomPool;
    let randomPoolPointer = RANDOM_POOL_SIZE;

    /**
     * HyBi Sender implementation.
     */
    class Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};

        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }

        this._socket = socket;

        this._firstFragment = true;
        this._compress = false;

        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }

      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;

        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;

          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              /* istanbul ignore else  */
              if (randomPool === undefined) {
                //
                // This is lazily initialized because server-sent frames must not
                // be masked so it may never be used.
                //
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }

              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }

            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }

          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }

        let dataLength;

        if (typeof data === 'string') {
          if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }

        let payloadLength = dataLength;

        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }

        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
        if (options.rsv1) target[0] |= 0x40;

        target[1] = payloadLength;

        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }

        if (!options.mask) return [target, data];

        target[1] |= 0x80;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];

        if (skipMasking) return [target, data];

        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }

        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }

      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;

        if (code === undefined) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
          throw new TypeError('First argument must be a valid error code number');
        } else if (data === undefined || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);

          if (length > 123) {
            throw new RangeError('The message must not be greater than 123 bytes');
          }

          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);

          if (typeof data === 'string') {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }

        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 0x08,
          readOnly: false,
          rsv1: false,
        };

        if (this._deflating) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options), cb);
        }
      }

      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;

        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }

        if (byteLength > 125) {
          throw new RangeError('The data size must not be greater than 125 bytes');
        }

        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 0x09,
          readOnly,
          rsv1: false,
        };

        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }

      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;

        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }

        if (byteLength > 125) {
          throw new RangeError('The data size must not be greater than 125 bytes');
        }

        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 0x0a,
          readOnly,
          rsv1: false,
        };

        if (this._deflating) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options), cb);
        }
      }

      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;

        let byteLength;
        let readOnly;

        if (typeof data === 'string') {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }

        if (this._firstFragment) {
          this._firstFragment = false;
          if (
            rsv1 &&
            perMessageDeflate &&
            perMessageDeflate.params[
              perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover'
            ]
          ) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }

        if (options.fin) this._firstFragment = true;

        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1,
          };

          if (this._deflating) {
            this.enqueue([this.dispatch, data, this._compress, opts, cb]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(
            Sender.frame(data, {
              [kByteLength]: byteLength,
              fin: options.fin,
              generateMask: this._generateMask,
              mask: options.mask,
              maskBuffer: this._maskBuffer,
              opcode,
              readOnly,
              rsv1: false,
            }),
            cb,
          );
        }
      }

      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }

        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error('The socket was closed while data was being compressed');

            if (typeof cb === 'function') cb(err);

            for (let i = 0; i < this._queue.length; i++) {
              const params = this._queue[i];
              const callback = params[params.length - 1];

              if (typeof callback === 'function') callback(err);
            }

            return;
          }

          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }

      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();

          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }

      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }

      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    }

    module.exports = Sender;

    /***/
  },

  /***/ 9454: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var node_process = __webpack_require__(932);

    function debug(logLevel, ...messages) {
      if (logLevel === 'debug') console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === 'debug' || logLevel === 'warn') {
        if (typeof node_process.emitWarning === 'function') node_process.emitWarning(warning);
        else console.warn(warning);
      }
    }

    exports.debug = debug;
    exports.warn = warn;

    /***/
  },

  /***/ 9478: /***/ (module, __unused_webpack_exports, __webpack_require__) => {
    const os = __webpack_require__(857);
    const tty = __webpack_require__(2018);
    const hasFlag = __webpack_require__(1533);

    const { env } = process;

    let forceColor;
    if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
      forceColor = 0;
    } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
      forceColor = 1;
    }

    if ('FORCE_COLOR' in env) {
      if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
      } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }

    function translateLevel(level) {
      if (level === 0) {
        return false;
      }

      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3,
      };
    }

    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }

      if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
      }

      if (hasFlag('color=256')) {
        return 2;
      }

      if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
      }

      const min = forceColor || 0;

      if (env.TERM === 'dumb') {
        return min;
      }

      if (process.platform === 'win32') {
        // Windows 10 build 10586 is the first Windows release that supports 256 colors.
        // Windows 10 build 14931 is the first release that supports 16m/TrueColor.
        const osRelease = os.release().split('.');
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }

        return 1;
      }

      if ('CI' in env) {
        if (
          ['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) ||
          env.CI_NAME === 'codeship'
        ) {
          return 1;
        }

        return min;
      }

      if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }

      if (env.COLORTERM === 'truecolor') {
        return 3;
      }

      if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

        switch (env.TERM_PROGRAM) {
          case 'iTerm.app':
            return version >= 3 ? 3 : 2;
          case 'Apple_Terminal':
            return 2;
          // No default
        }
      }

      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }

      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }

      if ('COLORTERM' in env) {
        return 1;
      }

      return min;
    }

    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }

    module.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2))),
    };

    /***/
  },

  /***/ 9595: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var _a;
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.SessionAwareAdapter = exports.Adapter = void 0;
    const events_1 = __webpack_require__(4434);
    const yeast_1 = __webpack_require__(9747);
    const WebSocket = __webpack_require__(3001);
    const canPreComputeFrame =
      typeof ((_a = WebSocket === null || WebSocket === void 0 ? void 0 : WebSocket.Sender) === null || _a === void 0
        ? void 0
        : _a.frame) === 'function';
    class Adapter extends events_1.EventEmitter {
      /**
       * In-memory adapter constructor.
       *
       * @param {Namespace} nsp
       */
      constructor(nsp) {
        super();
        this.nsp = nsp;
        this.rooms = new Map();
        this.sids = new Map();
        this.encoder = nsp.server.encoder;
      }
      /**
       * To be overridden
       */
      init() {}
      /**
       * To be overridden
       */
      close() {}
      /**
       * Returns the number of Socket.IO servers in the cluster
       *
       * @public
       */
      serverCount() {
        return Promise.resolve(1);
      }
      /**
       * Adds a socket to a list of room.
       *
       * @param {SocketId}  id      the socket id
       * @param {Set<Room>} rooms   a set of rooms
       * @public
       */
      addAll(id, rooms) {
        if (!this.sids.has(id)) {
          this.sids.set(id, new Set());
        }
        for (const room of rooms) {
          this.sids.get(id).add(room);
          if (!this.rooms.has(room)) {
            this.rooms.set(room, new Set());
            this.emit('create-room', room);
          }
          if (!this.rooms.get(room).has(id)) {
            this.rooms.get(room).add(id);
            this.emit('join-room', room, id);
          }
        }
      }
      /**
       * Removes a socket from a room.
       *
       * @param {SocketId} id     the socket id
       * @param {Room}     room   the room name
       */
      del(id, room) {
        if (this.sids.has(id)) {
          this.sids.get(id).delete(room);
        }
        this._del(room, id);
      }
      _del(room, id) {
        const _room = this.rooms.get(room);
        if (_room != null) {
          const deleted = _room.delete(id);
          if (deleted) {
            this.emit('leave-room', room, id);
          }
          if (_room.size === 0 && this.rooms.delete(room)) {
            this.emit('delete-room', room);
          }
        }
      }
      /**
       * Removes a socket from all rooms it's joined.
       *
       * @param {SocketId} id   the socket id
       */
      delAll(id) {
        if (!this.sids.has(id)) {
          return;
        }
        for (const room of this.sids.get(id)) {
          this._del(room, id);
        }
        this.sids.delete(id);
      }
      /**
       * Broadcasts a packet.
       *
       * Options:
       *  - `flags` {Object} flags for this packet
       *  - `except` {Array} sids that should be excluded
       *  - `rooms` {Array} list of rooms to broadcast to
       *
       * @param {Object} packet   the packet object
       * @param {Object} opts     the options
       * @public
       */
      broadcast(packet, opts) {
        const flags = opts.flags || {};
        const packetOpts = {
          preEncoded: true,
          volatile: flags.volatile,
          compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        const encodedPackets = this._encode(packet, packetOpts);
        this.apply(opts, socket => {
          if (typeof socket.notifyOutgoingListeners === 'function') {
            socket.notifyOutgoingListeners(packet);
          }
          socket.client.writeToEngine(encodedPackets, packetOpts);
        });
      }
      /**
       * Broadcasts a packet and expects multiple acknowledgements.
       *
       * Options:
       *  - `flags` {Object} flags for this packet
       *  - `except` {Array} sids that should be excluded
       *  - `rooms` {Array} list of rooms to broadcast to
       *
       * @param {Object} packet   the packet object
       * @param {Object} opts     the options
       * @param clientCountCallback - the number of clients that received the packet
       * @param ack                 - the callback that will be called for each client response
       *
       * @public
       */
      broadcastWithAck(packet, opts, clientCountCallback, ack) {
        const flags = opts.flags || {};
        const packetOpts = {
          preEncoded: true,
          volatile: flags.volatile,
          compress: flags.compress,
        };
        packet.nsp = this.nsp.name;
        // we can use the same id for each packet, since the _ids counter is common (no duplicate)
        packet.id = this.nsp._ids++;
        const encodedPackets = this._encode(packet, packetOpts);
        let clientCount = 0;
        this.apply(opts, socket => {
          // track the total number of acknowledgements that are expected
          clientCount++;
          // call the ack callback for each client response
          socket.acks.set(packet.id, ack);
          if (typeof socket.notifyOutgoingListeners === 'function') {
            socket.notifyOutgoingListeners(packet);
          }
          socket.client.writeToEngine(encodedPackets, packetOpts);
        });
        clientCountCallback(clientCount);
      }
      _encode(packet, packetOpts) {
        const encodedPackets = this.encoder.encode(packet);
        if (canPreComputeFrame && encodedPackets.length === 1 && typeof encodedPackets[0] === 'string') {
          // "4" being the "message" packet type in the Engine.IO protocol
          const data = Buffer.from('4' + encodedPackets[0]);
          // see https://github.com/websockets/ws/issues/617#issuecomment-283002469
          packetOpts.wsPreEncodedFrame = WebSocket.Sender.frame(data, {
            readOnly: false,
            mask: false,
            rsv1: false,
            opcode: 1,
            fin: true,
          });
        }
        return encodedPackets;
      }
      /**
       * Gets a list of sockets by sid.
       *
       * @param {Set<Room>} rooms   the explicit set of rooms to check.
       */
      sockets(rooms) {
        const sids = new Set();
        this.apply({ rooms }, socket => {
          sids.add(socket.id);
        });
        return Promise.resolve(sids);
      }
      /**
       * Gets the list of rooms a given socket has joined.
       *
       * @param {SocketId} id   the socket id
       */
      socketRooms(id) {
        return this.sids.get(id);
      }
      /**
       * Returns the matching socket instances
       *
       * @param opts - the filters to apply
       */
      fetchSockets(opts) {
        const sockets = [];
        this.apply(opts, socket => {
          sockets.push(socket);
        });
        return Promise.resolve(sockets);
      }
      /**
       * Makes the matching socket instances join the specified rooms
       *
       * @param opts - the filters to apply
       * @param rooms - the rooms to join
       */
      addSockets(opts, rooms) {
        this.apply(opts, socket => {
          socket.join(rooms);
        });
      }
      /**
       * Makes the matching socket instances leave the specified rooms
       *
       * @param opts - the filters to apply
       * @param rooms - the rooms to leave
       */
      delSockets(opts, rooms) {
        this.apply(opts, socket => {
          rooms.forEach(room => socket.leave(room));
        });
      }
      /**
       * Makes the matching socket instances disconnect
       *
       * @param opts - the filters to apply
       * @param close - whether to close the underlying connection
       */
      disconnectSockets(opts, close) {
        this.apply(opts, socket => {
          socket.disconnect(close);
        });
      }
      apply(opts, callback) {
        const rooms = opts.rooms;
        const except = this.computeExceptSids(opts.except);
        if (rooms.size) {
          const ids = new Set();
          for (const room of rooms) {
            if (!this.rooms.has(room)) continue;
            for (const id of this.rooms.get(room)) {
              if (ids.has(id) || except.has(id)) continue;
              const socket = this.nsp.sockets.get(id);
              if (socket) {
                callback(socket);
                ids.add(id);
              }
            }
          }
        } else {
          for (const [id] of this.sids) {
            if (except.has(id)) continue;
            const socket = this.nsp.sockets.get(id);
            if (socket) callback(socket);
          }
        }
      }
      computeExceptSids(exceptRooms) {
        const exceptSids = new Set();
        if (exceptRooms && exceptRooms.size > 0) {
          for (const room of exceptRooms) {
            if (this.rooms.has(room)) {
              this.rooms.get(room).forEach(sid => exceptSids.add(sid));
            }
          }
        }
        return exceptSids;
      }
      /**
       * Send a packet to the other Socket.IO servers in the cluster
       * @param packet - an array of arguments, which may include an acknowledgement callback at the end
       */
      serverSideEmit(packet) {
        console.warn('this adapter does not support the serverSideEmit() functionality');
      }
      /**
       * Save the client session in order to restore it upon reconnection.
       */
      persistSession(session) {}
      /**
       * Restore the session and find the packets that were missed by the client.
       * @param pid
       * @param offset
       */
      restoreSession(pid, offset) {
        return null;
      }
    }
    exports.Adapter = Adapter;
    class SessionAwareAdapter extends Adapter {
      constructor(nsp) {
        super(nsp);
        this.nsp = nsp;
        this.sessions = new Map();
        this.packets = [];
        this.maxDisconnectionDuration = nsp.server.opts.connectionStateRecovery.maxDisconnectionDuration;
        const timer = setInterval(() => {
          const threshold = Date.now() - this.maxDisconnectionDuration;
          this.sessions.forEach((session, sessionId) => {
            const hasExpired = session.disconnectedAt < threshold;
            if (hasExpired) {
              this.sessions.delete(sessionId);
            }
          });
          for (let i = this.packets.length - 1; i >= 0; i--) {
            const hasExpired = this.packets[i].emittedAt < threshold;
            if (hasExpired) {
              this.packets.splice(0, i + 1);
              break;
            }
          }
        }, 60 * 1000);
        // prevents the timer from keeping the process alive
        timer.unref();
      }
      persistSession(session) {
        session.disconnectedAt = Date.now();
        this.sessions.set(session.pid, session);
      }
      restoreSession(pid, offset) {
        const session = this.sessions.get(pid);
        if (!session) {
          // the session may have expired
          return null;
        }
        const hasExpired = session.disconnectedAt + this.maxDisconnectionDuration < Date.now();
        if (hasExpired) {
          // the session has expired
          this.sessions.delete(pid);
          return null;
        }
        const index = this.packets.findIndex(packet => packet.id === offset);
        if (index === -1) {
          // the offset may be too old
          return null;
        }
        const missedPackets = [];
        for (let i = index + 1; i < this.packets.length; i++) {
          const packet = this.packets[i];
          if (shouldIncludePacket(session.rooms, packet.opts)) {
            missedPackets.push(packet.data);
          }
        }
        return Promise.resolve(Object.assign(Object.assign({}, session), { missedPackets }));
      }
      broadcast(packet, opts) {
        var _a;
        const isEventPacket = packet.type === 2;
        // packets with acknowledgement are not stored because the acknowledgement function cannot be serialized and
        // restored on another server upon reconnection
        const withoutAcknowledgement = packet.id === undefined;
        const notVolatile = ((_a = opts.flags) === null || _a === void 0 ? void 0 : _a.volatile) === undefined;
        if (isEventPacket && withoutAcknowledgement && notVolatile) {
          const id = (0, yeast_1.yeast)();
          // the offset is stored at the end of the data array, so the client knows the ID of the last packet it has
          // processed (and the format is backward-compatible)
          packet.data.push(id);
          this.packets.push({
            id,
            opts,
            data: packet.data,
            emittedAt: Date.now(),
          });
        }
        super.broadcast(packet, opts);
      }
    }
    exports.SessionAwareAdapter = SessionAwareAdapter;
    function shouldIncludePacket(sessionRooms, opts) {
      const included = opts.rooms.size === 0 || sessionRooms.some(room => opts.rooms.has(room));
      const notExcluded = sessionRooms.every(room => !opts.except.has(room));
      return included && notExcluded;
    }

    /***/
  },

  /***/ 9605: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var stringifyNumber = __webpack_require__(2490);

    const intIdentify = value => typeof value === 'bigint' || Number.isInteger(value);
    const intResolve = (str, offset, radix, { intAsBigInt }) =>
      intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0) return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    const intOct = {
      identify: value => intIdentify(value) && value >= 0,
      default: true,
      tag: 'tag:yaml.org,2002:int',
      format: 'OCT',
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: node => intStringify(node, 8, '0o'),
    };
    const int = {
      identify: intIdentify,
      default: true,
      tag: 'tag:yaml.org,2002:int',
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber,
    };
    const intHex = {
      identify: value => intIdentify(value) && value >= 0,
      default: true,
      tag: 'tag:yaml.org,2002:int',
      format: 'HEX',
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: node => intStringify(node, 16, '0x'),
    };

    exports.int = int;
    exports.intHex = intHex;
    exports.intOct = intOct;

    /***/
  },

  /***/ 9736: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    const { humanReadableArgName } = __webpack_require__(1292);

    /**
     * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
     * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
     * @typedef { import("./argument.js").Argument } Argument
     * @typedef { import("./command.js").Command } Command
     * @typedef { import("./option.js").Option } Option
     */

    // Although this is a class, methods are static in style to allow override using subclass or just functions.
    class Help {
      constructor() {
        this.helpWidth = undefined;
        this.minWidthToWrap = 40;
        this.sortSubcommands = false;
        this.sortOptions = false;
        this.showGlobalOptions = false;
      }

      /**
       * prepareContext is called by Commander after applying overrides from `Command.configureHelp()`
       * and just before calling `formatHelp()`.
       *
       * Commander just uses the helpWidth and the rest is provided for optional use by more complex subclasses.
       *
       * @param {{ error?: boolean, helpWidth?: number, outputHasColors?: boolean }} contextOptions
       */
      prepareContext(contextOptions) {
        this.helpWidth = this.helpWidth ?? contextOptions.helpWidth ?? 80;
      }

      /**
       * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
       *
       * @param {Command} cmd
       * @returns {Command[]}
       */

      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);
        const helpCommand = cmd._getHelpCommand();
        if (helpCommand && !helpCommand._hidden) {
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            // @ts-ignore: because overloaded return type
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }

      /**
       * Compare options for sort.
       *
       * @param {Option} a
       * @param {Option} b
       * @returns {number}
       */
      compareOptions(a, b) {
        const getSortKey = option => {
          // WYSIWYG for order displayed in help. Short used for comparison if present. No special handling for negated.
          return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
        };
        return getSortKey(a).localeCompare(getSortKey(b));
      }

      /**
       * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */

      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter(option => !option.hidden);
        // Built-in help option.
        const helpOption = cmd._getHelpOption();
        if (helpOption && !helpOption.hidden) {
          // Automatically hide conflicting flags. Bit dubious but a historical behaviour that is convenient for single-command programs.
          const removeShort = helpOption.short && cmd._findOption(helpOption.short);
          const removeLong = helpOption.long && cmd._findOption(helpOption.long);
          if (!removeShort && !removeLong) {
            visibleOptions.push(helpOption); // no changes needed
          } else if (helpOption.long && !removeLong) {
            visibleOptions.push(cmd.createOption(helpOption.long, helpOption.description));
          } else if (helpOption.short && !removeShort) {
            visibleOptions.push(cmd.createOption(helpOption.short, helpOption.description));
          }
        }
        if (this.sortOptions) {
          visibleOptions.sort(this.compareOptions);
        }
        return visibleOptions;
      }

      /**
       * Get an array of the visible global options. (Not including help.)
       *
       * @param {Command} cmd
       * @returns {Option[]}
       */

      visibleGlobalOptions(cmd) {
        if (!this.showGlobalOptions) return [];

        const globalOptions = [];
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          const visibleOptions = ancestorCmd.options.filter(option => !option.hidden);
          globalOptions.push(...visibleOptions);
        }
        if (this.sortOptions) {
          globalOptions.sort(this.compareOptions);
        }
        return globalOptions;
      }

      /**
       * Get an array of the arguments if any have a description.
       *
       * @param {Command} cmd
       * @returns {Argument[]}
       */

      visibleArguments(cmd) {
        // Side effect! Apply the legacy descriptions before the arguments are displayed.
        if (cmd._argsDescription) {
          cmd.registeredArguments.forEach(argument => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
          });
        }

        // If there are any arguments with a description then return all the arguments.
        if (cmd.registeredArguments.find(argument => argument.description)) {
          return cmd.registeredArguments;
        }
        return [];
      }

      /**
       * Get the command term to show in the list of subcommands.
       *
       * @param {Command} cmd
       * @returns {string}
       */

      subcommandTerm(cmd) {
        // Legacy. Ignores custom usage string, and nested commands.
        const args = cmd.registeredArguments.map(arg => humanReadableArgName(arg)).join(' ');
        return (
          cmd._name +
          (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
          (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
          (args ? ' ' + args : '')
        );
      }

      /**
       * Get the option term to show in the list of options.
       *
       * @param {Option} option
       * @returns {string}
       */

      optionTerm(option) {
        return option.flags;
      }

      /**
       * Get the argument term to show in the list of arguments.
       *
       * @param {Argument} argument
       * @returns {string}
       */

      argumentTerm(argument) {
        return argument.name();
      }

      /**
       * Get the longest command term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */

      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, this.displayWidth(helper.styleSubcommandTerm(helper.subcommandTerm(command))));
        }, 0);
      }

      /**
       * Get the longest option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */

      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
        }, 0);
      }

      /**
       * Get the longest global option term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */

      longestGlobalOptionTermLength(cmd, helper) {
        return helper.visibleGlobalOptions(cmd).reduce((max, option) => {
          return Math.max(max, this.displayWidth(helper.styleOptionTerm(helper.optionTerm(option))));
        }, 0);
      }

      /**
       * Get the longest argument term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */

      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, this.displayWidth(helper.styleArgumentTerm(helper.argumentTerm(argument))));
        }, 0);
      }

      /**
       * Get the command usage to be displayed at the top of the built-in help.
       *
       * @param {Command} cmd
       * @returns {string}
       */

      commandUsage(cmd) {
        // Usage
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + '|' + cmd._aliases[0];
        }
        let ancestorCmdNames = '';
        for (let ancestorCmd = cmd.parent; ancestorCmd; ancestorCmd = ancestorCmd.parent) {
          ancestorCmdNames = ancestorCmd.name() + ' ' + ancestorCmdNames;
        }
        return ancestorCmdNames + cmdName + ' ' + cmd.usage();
      }

      /**
       * Get the description for the command.
       *
       * @param {Command} cmd
       * @returns {string}
       */

      commandDescription(cmd) {
        // @ts-ignore: because overloaded return type
        return cmd.description();
      }

      /**
       * Get the subcommand summary to show in the list of subcommands.
       * (Fallback to description for backwards compatibility.)
       *
       * @param {Command} cmd
       * @returns {string}
       */

      subcommandDescription(cmd) {
        // @ts-ignore: because overloaded return type
        return cmd.summary() || cmd.description();
      }

      /**
       * Get the option description to show in the list of options.
       *
       * @param {Option} option
       * @return {string}
       */

      optionDescription(option) {
        const extraInfo = [];

        if (option.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${option.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`,
          );
        }
        if (option.defaultValue !== undefined) {
          // default for boolean and negated more for programmer than end user,
          // but show true/false for boolean option as may be for hand-rolled env or config processing.
          const showDefault =
            option.required || option.optional || (option.isBoolean() && typeof option.defaultValue === 'boolean');
          if (showDefault) {
            extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
          }
        }
        // preset for boolean and negated are more for programmer than end user
        if (option.presetArg !== undefined && option.optional) {
          extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
        }
        if (option.envVar !== undefined) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(', ')})`;
        }

        return option.description;
      }

      /**
       * Get the argument description to show in the list of arguments.
       *
       * @param {Argument} argument
       * @return {string}
       */

      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(
            // use stringify to match the display of the default value
            `choices: ${argument.argChoices.map(choice => JSON.stringify(choice)).join(', ')}`,
          );
        }
        if (argument.defaultValue !== undefined) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescription = `(${extraInfo.join(', ')})`;
          if (argument.description) {
            return `${argument.description} ${extraDescription}`;
          }
          return extraDescription;
        }
        return argument.description;
      }

      /**
       * Generate the built-in help text.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {string}
       */

      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth ?? 80; // in case prepareContext() was not called

        function callFormatItem(term, description) {
          return helper.formatItem(term, termWidth, description, helper);
        }

        // Usage
        let output = [`${helper.styleTitle('Usage:')} ${helper.styleUsage(helper.commandUsage(cmd))}`, ''];

        // Description
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([helper.boxWrap(helper.styleCommandDescription(commandDescription), helpWidth), '']);
        }

        // Arguments
        const argumentList = helper.visibleArguments(cmd).map(argument => {
          return callFormatItem(
            helper.styleArgumentTerm(helper.argumentTerm(argument)),
            helper.styleArgumentDescription(helper.argumentDescription(argument)),
          );
        });
        if (argumentList.length > 0) {
          output = output.concat([helper.styleTitle('Arguments:'), ...argumentList, '']);
        }

        // Options
        const optionList = helper.visibleOptions(cmd).map(option => {
          return callFormatItem(
            helper.styleOptionTerm(helper.optionTerm(option)),
            helper.styleOptionDescription(helper.optionDescription(option)),
          );
        });
        if (optionList.length > 0) {
          output = output.concat([helper.styleTitle('Options:'), ...optionList, '']);
        }

        if (helper.showGlobalOptions) {
          const globalOptionList = helper.visibleGlobalOptions(cmd).map(option => {
            return callFormatItem(
              helper.styleOptionTerm(helper.optionTerm(option)),
              helper.styleOptionDescription(helper.optionDescription(option)),
            );
          });
          if (globalOptionList.length > 0) {
            output = output.concat([helper.styleTitle('Global Options:'), ...globalOptionList, '']);
          }
        }

        // Commands
        const commandList = helper.visibleCommands(cmd).map(cmd => {
          return callFormatItem(
            helper.styleSubcommandTerm(helper.subcommandTerm(cmd)),
            helper.styleSubcommandDescription(helper.subcommandDescription(cmd)),
          );
        });
        if (commandList.length > 0) {
          output = output.concat([helper.styleTitle('Commands:'), ...commandList, '']);
        }

        return output.join('\n');
      }

      /**
       * Return display width of string, ignoring ANSI escape sequences. Used in padding and wrapping calculations.
       *
       * @param {string} str
       * @returns {number}
       */
      displayWidth(str) {
        return stripColor(str).length;
      }

      /**
       * Style the title for displaying in the help. Called with 'Usage:', 'Options:', etc.
       *
       * @param {string} str
       * @returns {string}
       */
      styleTitle(str) {
        return str;
      }

      styleUsage(str) {
        // Usage has lots of parts the user might like to color separately! Assume default usage string which is formed like:
        //    command subcommand [options] [command] <foo> [bar]
        return str
          .split(' ')
          .map(word => {
            if (word === '[options]') return this.styleOptionText(word);
            if (word === '[command]') return this.styleSubcommandText(word);
            if (word[0] === '[' || word[0] === '<') return this.styleArgumentText(word);
            return this.styleCommandText(word); // Restrict to initial words?
          })
          .join(' ');
      }
      styleCommandDescription(str) {
        return this.styleDescriptionText(str);
      }
      styleOptionDescription(str) {
        return this.styleDescriptionText(str);
      }
      styleSubcommandDescription(str) {
        return this.styleDescriptionText(str);
      }
      styleArgumentDescription(str) {
        return this.styleDescriptionText(str);
      }
      styleDescriptionText(str) {
        return str;
      }
      styleOptionTerm(str) {
        return this.styleOptionText(str);
      }
      styleSubcommandTerm(str) {
        // This is very like usage with lots of parts! Assume default string which is formed like:
        //    subcommand [options] <foo> [bar]
        return str
          .split(' ')
          .map(word => {
            if (word === '[options]') return this.styleOptionText(word);
            if (word[0] === '[' || word[0] === '<') return this.styleArgumentText(word);
            return this.styleSubcommandText(word); // Restrict to initial words?
          })
          .join(' ');
      }
      styleArgumentTerm(str) {
        return this.styleArgumentText(str);
      }
      styleOptionText(str) {
        return str;
      }
      styleArgumentText(str) {
        return str;
      }
      styleSubcommandText(str) {
        return str;
      }
      styleCommandText(str) {
        return str;
      }

      /**
       * Calculate the pad width from the maximum term length.
       *
       * @param {Command} cmd
       * @param {Help} helper
       * @returns {number}
       */

      padWidth(cmd, helper) {
        return Math.max(
          helper.longestOptionTermLength(cmd, helper),
          helper.longestGlobalOptionTermLength(cmd, helper),
          helper.longestSubcommandTermLength(cmd, helper),
          helper.longestArgumentTermLength(cmd, helper),
        );
      }

      /**
       * Detect manually wrapped and indented strings by checking for line break followed by whitespace.
       *
       * @param {string} str
       * @returns {boolean}
       */
      preformatted(str) {
        return /\n[^\S\r\n]/.test(str);
      }

      /**
       * Format the "item", which consists of a term and description. Pad the term and wrap the description, indenting the following lines.
       *
       * So "TTT", 5, "DDD DDDD DD DDD" might be formatted for this.helpWidth=17 like so:
       *   TTT  DDD DDDD
       *        DD DDD
       *
       * @param {string} term
       * @param {number} termWidth
       * @param {string} description
       * @param {Help} helper
       * @returns {string}
       */
      formatItem(term, termWidth, description, helper) {
        const itemIndent = 2;
        const itemIndentStr = ' '.repeat(itemIndent);
        if (!description) return itemIndentStr + term;

        // Pad the term out to a consistent width, so descriptions are aligned.
        const paddedTerm = term.padEnd(termWidth + term.length - helper.displayWidth(term));

        // Format the description.
        const spacerWidth = 2; // between term and description
        const helpWidth = this.helpWidth ?? 80; // in case prepareContext() was not called
        const remainingWidth = helpWidth - termWidth - spacerWidth - itemIndent;
        let formattedDescription;
        if (remainingWidth < this.minWidthToWrap || helper.preformatted(description)) {
          formattedDescription = description;
        } else {
          const wrappedDescription = helper.boxWrap(description, remainingWidth);
          formattedDescription = wrappedDescription.replace(/\n/g, '\n' + ' '.repeat(termWidth + spacerWidth));
        }

        // Construct and overall indent.
        return (
          itemIndentStr +
          paddedTerm +
          ' '.repeat(spacerWidth) +
          formattedDescription.replace(/\n/g, `\n${itemIndentStr}`)
        );
      }

      /**
       * Wrap a string at whitespace, preserving existing line breaks.
       * Wrapping is skipped if the width is less than `minWidthToWrap`.
       *
       * @param {string} str
       * @param {number} width
       * @returns {string}
       */
      boxWrap(str, width) {
        if (width < this.minWidthToWrap) return str;

        const rawLines = str.split(/\r\n|\n/);
        // split up text by whitespace
        const chunkPattern = /[\s]*[^\s]+/g;
        const wrappedLines = [];
        rawLines.forEach(line => {
          const chunks = line.match(chunkPattern);
          if (chunks === null) {
            wrappedLines.push('');
            return;
          }

          let sumChunks = [chunks.shift()];
          let sumWidth = this.displayWidth(sumChunks[0]);
          chunks.forEach(chunk => {
            const visibleWidth = this.displayWidth(chunk);
            // Accumulate chunks while they fit into width.
            if (sumWidth + visibleWidth <= width) {
              sumChunks.push(chunk);
              sumWidth += visibleWidth;
              return;
            }
            wrappedLines.push(sumChunks.join(''));

            const nextChunk = chunk.trimStart(); // trim space at line break
            sumChunks = [nextChunk];
            sumWidth = this.displayWidth(nextChunk);
          });
          wrappedLines.push(sumChunks.join(''));
        });

        return wrappedLines.join('\n');
      }
    }

    /**
     * Strip style ANSI escape sequences from the string. In particular, SGR (Select Graphic Rendition) codes.
     *
     * @param {string} str
     * @returns {string}
     * @package
     */

    function stripColor(str) {
      const sgrPattern = /\x1b\[\d*(;\d*)*m/g;
      return str.replace(sgrPattern, '');
    }

    exports.Help = Help;
    exports.stripColor = stripColor;

    /***/
  },

  /***/ 9747: /***/ (__unused_webpack_module, exports) => {
    // imported from https://github.com/unshiftio/yeast

    Object.defineProperty(exports, '__esModule', { value: true });
    exports.yeast = exports.decode = exports.encode = void 0;
    const alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),
      length = 64,
      map = {};
    let seed = 0,
      i = 0,
      prev;
    /**
     * Return a string representing the specified number.
     *
     * @param {Number} num The number to convert.
     * @returns {String} The string representation of the number.
     * @api public
     */
    function encode(num) {
      let encoded = '';
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
      return encoded;
    }
    exports.encode = encode;
    /**
     * Return the integer value specified by the given string.
     *
     * @param {String} str The string to convert.
     * @returns {Number} The integer value represented by the string.
     * @api public
     */
    function decode(str) {
      let decoded = 0;
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
      }
      return decoded;
    }
    exports.decode = decode;
    /**
     * Yeast: A tiny growing id generator.
     *
     * @returns {String} A unique id.
     * @api public
     */
    function yeast() {
      const now = encode(+new Date());
      if (now !== prev) return ((seed = 0), (prev = now));
      return now + '.' + encode(seed++);
    }
    exports.yeast = yeast;
    //
    // Map each character to its index.
    //
    for (; i < length; i++) map[alphabet[i]] = i;

    /***/
  },

  /***/ 9795: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var resolveBlockScalar = __webpack_require__(140);
    var resolveFlowScalar = __webpack_require__(8113);
    var errors = __webpack_require__(6101);
    var stringifyString = __webpack_require__(9850);

    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError) onError(offset, code, message);
          else throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case 'scalar':
          case 'single-quoted-scalar':
          case 'double-quoted-scalar':
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case 'block-scalar':
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    /**
     * Create a new scalar token with `value`
     *
     * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
     * as this function does not support any schema operations and won't check for such conflicts.
     *
     * @param value The string representation of the value, which will have its content properly indented.
     * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
     * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
     * @param context.indent The indent level of the token.
     * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
     * @param context.offset The offset position of the token.
     * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
     */
    function createScalarToken(value, context) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
      const source = stringifyString.stringifyString(
        { type, value },
        {
          implicitKey,
          indent: indent > 0 ? ' '.repeat(indent) : '',
          inFlow,
          options: { blockQuote: true, lineWidth: -1 },
        },
      );
      const end = context.end ?? [{ type: 'newline', offset: -1, indent, source: '\n' }];
      switch (source[0]) {
        case '|':
        case '>': {
          const he = source.indexOf('\n');
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + '\n';
          const props = [{ type: 'block-scalar-header', offset, indent, source: head }];
          if (!addEndtoBlockProps(props, end)) props.push({ type: 'newline', offset: -1, indent, source: '\n' });
          return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
          return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
          return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
          return { type: 'scalar', offset, indent, source, end };
      }
    }
    /**
     * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
     *
     * Best efforts are made to retain any comments previously associated with the `token`,
     * though all contents within a collection's `items` will be overwritten.
     *
     * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
     * as this function does not support any schema operations and won't check for such conflicts.
     *
     * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
     * @param value The string representation of the value, which will have its content properly indented.
     * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
     * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
     * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
     * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
     */
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = 'indent' in token ? token.indent : null;
      if (afterKey && typeof indent === 'number') indent += 2;
      if (!type)
        switch (token.type) {
          case 'single-quoted-scalar':
            type = 'QUOTE_SINGLE';
            break;
          case 'double-quoted-scalar':
            type = 'QUOTE_DOUBLE';
            break;
          case 'block-scalar': {
            const header = token.props[0];
            if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');
            type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
            break;
          }
          default:
            type = 'PLAIN';
        }
      const source = stringifyString.stringifyString(
        { type, value },
        {
          implicitKey: implicitKey || indent === null,
          indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
          inFlow,
          options: { blockQuote: true, lineWidth: -1 },
        },
      );
      switch (source[0]) {
        case '|':
        case '>':
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, 'double-quoted-scalar');
          break;
        case "'":
          setFlowScalarValue(token, source, 'single-quoted-scalar');
          break;
        default:
          setFlowScalarValue(token, source, 'scalar');
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf('\n');
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + '\n';
      if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header') throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [{ type: 'block-scalar-header', offset, indent, source: head }];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
          props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
      }
    }
    /** @returns `true` if last token is a newline */
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case 'space':
            case 'comment':
              props.push(st);
              break;
            case 'newline':
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
          token.type = type;
          token.source = source;
          break;
        case 'block-scalar': {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === 'block-scalar-header') oa -= token.props[0].source.length;
          for (const tok of end) tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case 'block-map':
        case 'block-seq': {
          const offset = token.offset + source.length;
          const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = 'indent' in token ? token.indent : -1;
          const end =
            'end' in token && Array.isArray(token.end)
              ? token.end.filter(st => st.type === 'space' || st.type === 'comment' || st.type === 'newline')
              : [];
          for (const key of Object.keys(token)) if (key !== 'type' && key !== 'offset') delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }

    exports.createScalarToken = createScalarToken;
    exports.resolveAsScalar = resolveAsScalar;
    exports.setScalarValue = setScalarValue;

    /***/
  },

  /***/ 9814: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var anchors = __webpack_require__(8047);
    var visit = __webpack_require__(6695);
    var identity = __webpack_require__(7182);
    var Node = __webpack_require__(4176);
    var toJS = __webpack_require__(9126);

    class Alias extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
          set() {
            throw new Error('Alias nodes cannot have tags');
          },
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit.visit(doc, {
            Node: (_key, node) => {
              if (identity.isAlias(node) || identity.hasAnchor(node)) nodes.push(node);
            },
          });
          if (ctx) ctx.aliasResolveCache = nodes;
        }
        let found = undefined;
        for (const node of nodes) {
          if (node === this) break;
          if (node.anchor === this.source) found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx) return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
          // Resolve anchors for Node.prototype.toJS()
          toJS.toJS(source, null, ctx);
          data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
          const msg = 'This should not happen: Alias anchor was not resolved?';
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0) data.aliasCount = getAliasCount(doc, source, anchors);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = 'Excessive alias count indicates a resource exhaustion attack';
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey) return `${src} `;
        }
        return src;
      }
    }
    function getAliasCount(doc, node, anchors) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors);
          if (c > count) count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
      }
      return 1;
    }

    exports.Alias = Alias;

    /***/
  },

  /***/ 9834: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    Object.defineProperty(exports, '__esModule', { value: true });
    exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;
    const component_emitter_1 = __webpack_require__(7320);
    const binary_js_1 = __webpack_require__(3641);
    const is_binary_js_1 = __webpack_require__(180);
    const debug_1 = __webpack_require__(1106); // debug()
    const debug = (0, debug_1.default)('socket.io-parser'); // debug()
    /**
     * These strings must not be used as event names, as they have a special meaning.
     */
    const RESERVED_EVENTS = [
      'connect',
      'connect_error',
      'disconnect',
      'disconnecting',
      'newListener',
      'removeListener', // used by the Node.js EventEmitter
    ];
    /**
     * Protocol version.
     *
     * @public
     */
    exports.protocol = 5;
    var PacketType;
    (function (PacketType) {
      PacketType[(PacketType['CONNECT'] = 0)] = 'CONNECT';
      PacketType[(PacketType['DISCONNECT'] = 1)] = 'DISCONNECT';
      PacketType[(PacketType['EVENT'] = 2)] = 'EVENT';
      PacketType[(PacketType['ACK'] = 3)] = 'ACK';
      PacketType[(PacketType['CONNECT_ERROR'] = 4)] = 'CONNECT_ERROR';
      PacketType[(PacketType['BINARY_EVENT'] = 5)] = 'BINARY_EVENT';
      PacketType[(PacketType['BINARY_ACK'] = 6)] = 'BINARY_ACK';
    })((PacketType = exports.PacketType || (exports.PacketType = {})));
    /**
     * A socket.io Encoder instance
     */
    class Encoder {
      /**
       * Encoder constructor
       *
       * @param {function} replacer - custom replacer to pass down to JSON.parse
       */
      constructor(replacer) {
        this.replacer = replacer;
      }
      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       */
      encode(obj) {
        debug('encoding packet %j', obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if ((0, is_binary_js_1.hasBinary)(obj)) {
            return this.encodeAsBinary({
              type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
              nsp: obj.nsp,
              data: obj.data,
              id: obj.id,
            });
          }
        }
        return [this.encodeAsString(obj)];
      }
      /**
       * Encode packet as string.
       */
      encodeAsString(obj) {
        // first is type
        let str = '' + obj.type;
        // attachments if we have them
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + '-';
        }
        // if we have a namespace other than `/`
        // we append it followed by a comma `,`
        if (obj.nsp && '/' !== obj.nsp) {
          str += obj.nsp + ',';
        }
        // immediately followed by the id
        if (null != obj.id) {
          str += obj.id;
        }
        // json data
        if (null != obj.data) {
          str += JSON.stringify(obj.data, this.replacer);
        }
        debug('encoded %j as %s', obj, str);
        return str;
      }
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       */
      encodeAsBinary(obj) {
        const deconstruction = (0, binary_js_1.deconstructPacket)(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack); // add packet info to beginning of data list
        return buffers; // write all the buffers
      }
    }
    exports.Encoder = Encoder;
    // see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript
    function isObject(value) {
      return Object.prototype.toString.call(value) === '[object Object]';
    }
    /**
     * A socket.io Decoder instance
     *
     * @return {Object} decoder
     */
    class Decoder extends component_emitter_1.Emitter {
      /**
       * Decoder constructor
       *
       * @param {function} reviver - custom reviver to pass down to JSON.stringify
       */
      constructor(reviver) {
        super();
        this.reviver = reviver;
      }
      /**
       * Decodes an encoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       */
      add(obj) {
        let packet;
        if (typeof obj === 'string') {
          if (this.reconstructor) {
            throw new Error('got plaintext data when reconstructing a packet');
          }
          packet = this.decodeString(obj);
          const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
          if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
            // binary packet's json
            this.reconstructor = new BinaryReconstructor(packet);
            // no attachments, labeled binary but no binary data to follow
            if (packet.attachments === 0) {
              super.emitReserved('decoded', packet);
            }
          } else {
            // non-binary full packet
            super.emitReserved('decoded', packet);
          }
        } else if ((0, is_binary_js_1.isBinary)(obj) || obj.base64) {
          // raw binary data
          if (!this.reconstructor) {
            throw new Error('got binary data when not reconstructing a packet');
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              // received final buffer
              this.reconstructor = null;
              super.emitReserved('decoded', packet);
            }
          }
        } else {
          throw new Error('Unknown type: ' + obj);
        }
      }
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       */
      decodeString(str) {
        let i = 0;
        // look up type
        const p = {
          type: Number(str.charAt(0)),
        };
        if (PacketType[p.type] === undefined) {
          throw new Error('unknown packet type ' + p.type);
        }
        // look up attachments if type binary
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          const start = i + 1;
          while (str.charAt(++i) !== '-' && i != str.length) {}
          const buf = str.substring(start, i);
          if (buf != Number(buf) || str.charAt(i) !== '-') {
            throw new Error('Illegal attachments');
          }
          p.attachments = Number(buf);
        }
        // look up namespace (if any)
        if ('/' === str.charAt(i + 1)) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (',' === c) break;
            if (i === str.length) break;
          }
          p.nsp = str.substring(start, i);
        } else {
          p.nsp = '/';
        }
        // look up id
        const next = str.charAt(i + 1);
        if ('' !== next && Number(next) == next) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (null == c || Number(c) != c) {
              --i;
              break;
            }
            if (i === str.length) break;
          }
          p.id = Number(str.substring(start, i + 1));
        }
        // look up json data
        if (str.charAt(++i)) {
          const payload = this.tryParse(str.substr(i));
          if (Decoder.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error('invalid payload');
          }
        }
        debug('decoded %s as %j', str, p);
        return p;
      }
      tryParse(str) {
        try {
          return JSON.parse(str, this.reviver);
        } catch (e) {
          return false;
        }
      }
      static isPayloadValid(type, payload) {
        switch (type) {
          case PacketType.CONNECT:
            return isObject(payload);
          case PacketType.DISCONNECT:
            return payload === undefined;
          case PacketType.CONNECT_ERROR:
            return typeof payload === 'string' || isObject(payload);
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return (
              Array.isArray(payload) &&
              (typeof payload[0] === 'number' ||
                (typeof payload[0] === 'string' && RESERVED_EVENTS.indexOf(payload[0]) === -1))
            );
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      /**
       * Deallocates a parser's resources
       */
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
          this.reconstructor = null;
        }
      }
    }
    exports.Decoder = Decoder;
    /**
     * A manager of a binary event's 'buffer sequence'. Should
     * be constructed whenever a packet of type BINARY_EVENT is
     * decoded.
     *
     * @param {Object} packet
     * @return {BinaryReconstructor} initialized reconstructor
     */
    class BinaryReconstructor {
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       */
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          // done with buffer list
          const packet = (0, binary_js_1.reconstructPacket)(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      /**
       * Cleans up binary packet reconstruction variables.
       */
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    }

    /***/
  },

  /***/ 9850: /***/ (__unused_webpack_module, exports, __webpack_require__) => {
    var Scalar = __webpack_require__(6364);
    var foldFlowLines = __webpack_require__(2216);

    const getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth,
    });
    // Also checks for lines starting with %, as parsing the output as YAML 1.1 will
    // presume that's starting a new document.
    const containsDocumentMarker = str => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0) return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit) return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
          if (i - start > limit) return true;
          start = i + 1;
          if (strLen - start <= limit) return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON) return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
      let str = '';
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
          // space before newline needs to be escaped to not be folded
          str += json.slice(start, i) + '\\ ';
          i += 1;
          start = i;
          ch = '\\';
        }
        if (ch === '\\')
          switch (json[i + 1]) {
            case 'u':
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case '0000':
                    str += '\\0';
                    break;
                  case '0007':
                    str += '\\a';
                    break;
                  case '000b':
                    str += '\\v';
                    break;
                  case '001b':
                    str += '\\e';
                    break;
                  case '0085':
                    str += '\\N';
                    break;
                  case '00a0':
                    str += '\\_';
                    break;
                  case '2028':
                    str += '\\L';
                    break;
                  case '2029':
                    str += '\\P';
                    break;
                  default:
                    if (code.substr(0, 2) === '00') str += '\\x' + code.substr(2);
                    else str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case 'n':
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                // folding will eat first newline
                str += json.slice(start, i) + '\n\n';
                while (json[i + 2] === '\\' && json[i + 3] === 'n' && json[i + 4] !== '"') {
                  str += '\n';
                  i += 2;
                }
                str += indent;
                // space after newline needs to be escaped to not be folded
                if (json[i + 2] === ' ') str += '\\';
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (
        ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
      )
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
      return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false) qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle) qs = singleQuotedString;
        else if (hasSingle && !hasDouble) qs = doubleQuotedString;
        else qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    // The negative lookbehind avoids a polynomial search,
    // but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
    let blockEndNewlines;
    try {
      blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      // 1. Block can't end in whitespace unless the last line is non-empty.
      // 2. Strings consisting of only whitespace are best rendered explicitly.
      if (!blockQuote || /\n[\t ]+$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
      const literal =
        blockQuote === 'literal'
          ? true
          : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.Scalar.BLOCK_LITERAL
              ? true
              : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value) return literal ? '|\n' : '>\n';
      // determine chomping from whitespace at value end
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ') break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf('\n');
      if (endNlPos === -1) {
        chomp = '-'; // strip
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep) onChompKeep();
      } else {
        chomp = ''; // clip
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n') end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      // determine indent indicator from whitespace at value start
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ') startWithSpace = true;
        else if (ch === '\n') startNlPos = startEnd;
        else break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? '2' : '1'; // root is at -1
      // Leading | or > is added later
      let header = (startWithSpace ? indentSize : '') + chomp;
      if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment) onComment();
      }
      if (!literal) {
        const foldedValue = value
          .replace(/\n+/g, '\n$&')
          .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
          //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
          .replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== 'folded' && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(
          `${start}${foldedValue}${end}`,
          indent,
          foldFlowLines.FOLD_BLOCK,
          foldOptions,
        );
        if (!literalFallback) return `>${header}\n${indent}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent}`);
      return `|${header}\n${indent}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if ((implicitKey && value.includes('\n')) || (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
      }
      if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
          ? quotedString(value, ctx)
          : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === '') {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&\n${indent}`);
      // Verify that output will be parsed as a string, as e.g. plain numbers and
      // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
      // and others in v1.1.
      if (actualString) {
        const test = tag => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test)) return quotedString(value, ctx);
      }
      return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === 'string' ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value)) type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = _type => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow
              ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
              : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null) throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }

    exports.stringifyString = stringifyString;

    /***/
  },

  /***/ 9896: /***/ module => {
    module.exports = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('fs');

    /***/
  },

  /******/
};
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
  /******/ // Check if module is in cache
  /******/ var cachedModule = __webpack_module_cache__[moduleId];
  /******/ if (cachedModule !== undefined) {
    /******/ return cachedModule.exports;
    /******/
  }
  /******/ // Create a new module (and put it into the cache)
  /******/ var module = (__webpack_module_cache__[moduleId] = {
    /******/ id: moduleId,
    /******/ loaded: false,
    /******/ exports: {},
    /******/
  });
  /******/
  /******/ // Execute the module function
  /******/ __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
  /******/
  /******/ // Flag the module as loaded
  /******/ module.loaded = true;
  /******/
  /******/ // Return the exports of the module
  /******/ return module.exports;
  /******/
}
/******/
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
  /******/ // getDefaultExport function for compatibility with non-harmony modules
  /******/ __webpack_require__.n = module => {
    /******/ var getter = module && module.__esModule ? /******/ () => module['default'] : /******/ () => module;
    /******/ __webpack_require__.d(getter, { a: getter });
    /******/ return getter;
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
  /******/ // define getter functions for harmony exports
  /******/ __webpack_require__.d = (exports, definition) => {
    /******/ for (var key in definition) {
      /******/ if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
        /******/ Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
        /******/
      }
      /******/
    }
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
  /******/ __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
  /******/
})();
/******/
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
  /******/ // define __esModule on exports
  /******/ __webpack_require__.r = exports => {
    /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
      /******/ Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
      /******/
    }
    /******/ Object.defineProperty(exports, '__esModule', { value: true });
    /******/
  };
  /******/
})();
/******/
/******/ /* webpack/runtime/node module decorator */
/******/ (() => {
  /******/ __webpack_require__.nmd = module => {
    /******/ module.paths = [];
    /******/ if (!module.children) module.children = [];
    /******/ return module;
    /******/
  };
  /******/
})();
/******/
/************************************************************************/
var __webpack_exports__ = {}; // ./src/server/settings_default.yaml?raw

const settings_defaultraw_namespaceObject =
  '# yaml-language-server: $schema=https://testingcf.jsdelivr.net/gh/StageDog/tavern_sync/dist/schema/settings.zh.json\n\n# 在此填入 user 名称, 提示词中如果有这个名字则会被替换成 <user> 宏\nuser名称: 青空黎\n\n# 在此填入新的"世界书"或"预设"配置\n配置:\n  # 配置名称, 可以和酒馆中的不同. 你使用脚本时需要填写配置名称来指出用哪个配置, 因此尽量配置名称尽量简单点方便填写\n  恩赐之主:\n    # 类型可以是"世界书"或"预设"\n    类型: 世界书\n\n    # 在酒馆中这个"世界书"或"预设"叫什么\n    酒馆中的名称: 恩赐之主\n\n    # 这个世界书或预设的等效配置文件要提取到本地哪个文件中, 可以是绝对路径或相对于本文件的相对路径\n    # 如果不满足路径格式将会报错\n    # - 绝对路径: 如 Windows 中, 想将世界书提取到 C 盘"恩赐之主文件夹"中, 则填入 `C:/恩赐之主/恩赐之主.yaml`\n    # - 相对路径:\n    #   - 想将世界书配置文件提取到本文件相同的文件夹中, 则填入 `./恩赐之主.yaml` 或 `恩赐之主.yaml`\n    #   - 想将世界书配置文件提取到本文件所在文件夹的子文件夹"世界书"中, 则填入 `./世界书/恩赐之主.yaml` 或 `世界书/恩赐之主.yaml`\n    #   - 想将世界书配置文件提取到本文件所在文件夹的父文件夹中, 则填入 `../恩赐之主.yaml`\n    本地文件路径: ./世界书/恩赐之主.yaml\n';
// EXTERNAL MODULE: ./node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/lodash.js
var lodash = __webpack_require__(2935);
var lodash_default = /*#__PURE__*/ __webpack_require__.n(lodash); // ./src/server/util/map_deep.ts
function map_keys_deep_impl(data, fn, is_recursive) {
  if (!data && !is_recursive) {
    return {};
  }
  if (!is_recursive) {
    if (typeof data === 'string' || typeof data === 'number' || typeof data === 'boolean') {
      return {};
    }
  }
  if (Array.isArray(data)) {
    return data.map(item => map_keys_deep_impl(item, fn, true));
  }
  if (!lodash_default().isPlainObject(data)) {
    return data;
  }
  const result = lodash_default().mapKeys(data, fn);
  return lodash_default().mapValues(result, value => map_keys_deep_impl(value, fn, true));
}
function map_keys_deep(data, fn) {
  return map_keys_deep_impl(data, fn, false);
}
function map_values_deep(data, fn) {
  if (Array.isArray(data)) {
    return data.map(item => map_values_deep(item, fn));
  }
  if (!lodash_default().isPlainObject(data)) {
    return fn(data);
  }
  return lodash_default().mapValues(data, value => map_values_deep(value, fn));
} // ./src/server/util/translate.ts

function translate(data, map) {
  const try_map = string => {
    if (typeof string !== 'string') {
      return string;
    }
    if (map[string]) {
      return map[string];
    }
    return string;
  };
  data = map_keys_deep(data, (_value, key) => {
    return try_map(key);
  });
  data = map_values_deep(data, try_map);
  return data;
}

// EXTERNAL MODULE: external "node:fs"
var external_node_fs_ = __webpack_require__(3024);
// EXTERNAL MODULE: external "node:path"
var external_node_path_ = __webpack_require__(6760); // ./src/server/util/write_file_recursively.ts
function write_file_recursively(base, file, data) {
  try {
    (0, external_node_fs_.mkdirSync)((0, external_node_path_.resolve)(base, (0, external_node_path_.dirname)(file)), {
      recursive: true,
    });
    (0, external_node_fs_.writeFileSync)((0, external_node_path_.resolve)(base, file), data);
  } catch (error) {
    throw Error(`写入文件 '${file}' 失败: ${error}`);
  }
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/core.js

/** A special constant with type `never` */
const NEVER = Object.freeze({
  status: 'aborted',
});
function $constructor(name, initializer, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, '_zod', {
      value: inst._zod ?? {},
      enumerable: false,
    });
    (_a = inst._zod).traits ?? (_a.traits = new Set());
    inst._zod.traits.add(name);
    initializer(inst, def);
    // support prototype modifications
    for (const k in _.prototype) {
      if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  // doesn't work if Parent has a constructor with arguments
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {}
  Object.defineProperty(Definition, 'name', { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, 'init', { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: inst => {
      if (params?.Parent && inst instanceof params.Parent) return true;
      return inst?._zod?.traits?.has(name);
    },
  });
  Object.defineProperty(_, 'name', { value: name });
  return _;
}
//////////////////////////////   UTILITIES   ///////////////////////////////////////
const $brand = Symbol('zod_brand');
class $ZodAsyncError extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
}
class $ZodEncodeError extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = 'ZodEncodeError';
  }
}
const globalConfig = {};
function config(newConfig) {
  if (newConfig) Object.assign(globalConfig, newConfig);
  return globalConfig;
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/regexes.js

const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** Implements ISO 8601-2 extensions like explicit +- prefixes, mixing weeks with other units, and fractional/negative components. */
const extendedDuration =
  /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 9562/4122 UUID.
 *
 * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid = version => {
  if (!version)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(
    `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`,
  );
};
const uuid4 = /*@__PURE__*/ /* unused pure expression or super */ null && uuid(4);
const uuid6 = /*@__PURE__*/ /* unused pure expression or super */ null && uuid(6);
const uuid7 = /*@__PURE__*/ /* unused pure expression or super */ null && uuid(7);
/** Practical email validation */
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
/** Equivalent to the HTML5 input[type=email] validation implemented by browsers. Source: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/email */
const html5Email =
  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
/** The classic emailregex.com regex for RFC 5322-compliant emails */
const rfc5322Email =
  /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
/** A loose regex that allows Unicode characters, enforces length limits, and that's about it. */
const unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
const idnEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
const browserEmail =
  /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, 'u');
}
const ipv4 =
  /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
const cidrv4 =
  /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 =
  /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
// export const hostname: RegExp = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
const hostname =
  /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
const domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
// const dateSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date = /*@__PURE__*/ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex =
    typeof args.precision === 'number'
      ? args.precision === -1
        ? `${hhmm}`
        : args.precision === 0
          ? `${hhmm}:[0-5]\\d`
          : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
      : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetime(args) {
  const time = timeSource({ precision: args.precision });
  const opts = ['Z'];
  if (args.local) opts.push('');
  // if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
  if (args.offset) opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time}(?:${opts.join('|')})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string = params => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ''}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
const bigint = /^\d+n?$/;
const integer = /^\d+$/;
const number = /^-?\d+(?:\.\d+)?/i;
const regexes_boolean = /true|false/i;
const _null = /null/i;

const _undefined = /undefined/i;

// regex for string with no uppercase letters
const lowercase = /^[^A-Z]*$/;
// regex for string with no lowercase letters
const uppercase = /^[^a-z]*$/;
// regex for hexadecimal strings (any length)
const hex = /^[0-9a-fA-F]*$/;
// Hash regexes for different algorithms and encodings
// Helper function to create base64 regex with exact length and padding
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
// Helper function to create base64url regex with exact length (no padding)
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9-_]{${length}}$`);
}
// MD5 (16 bytes): base64 = 24 chars total (22 + "==")
const md5_hex = /^[0-9a-fA-F]{32}$/;
const md5_base64 = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64(22, '==');
const md5_base64url = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64url(22);
// SHA1 (20 bytes): base64 = 28 chars total (27 + "=")
const sha1_hex = /^[0-9a-fA-F]{40}$/;
const sha1_base64 = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64(27, '=');
const sha1_base64url = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64url(27);
// SHA256 (32 bytes): base64 = 44 chars total (43 + "=")
const sha256_hex = /^[0-9a-fA-F]{64}$/;
const sha256_base64 = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64(43, '=');
const sha256_base64url = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64url(43);
// SHA384 (48 bytes): base64 = 64 chars total (no padding)
const sha384_hex = /^[0-9a-fA-F]{96}$/;
const sha384_base64 = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64(64, '');
const sha384_base64url = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64url(64);
// SHA512 (64 bytes): base64 = 88 chars total (86 + "==")
const sha512_hex = /^[0-9a-fA-F]{128}$/;
const sha512_base64 = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64(86, '==');
const sha512_base64url = /*@__PURE__*/ /* unused pure expression or super */ null && fixedBase64url(86); // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/util.js

// functions
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter(v => typeof v === 'number');
  const values = Object.entries(entries)
    .filter(([k, _]) => numericValues.indexOf(+k) === -1)
    .map(([_, v]) => v);
  return values;
}
function joinValues(array, separator = '|') {
  return array.map(val => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === 'bigint') return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, 'value', { value });
        return value;
      }
      throw new Error('cached value already set');
    },
  };
}
function nullish(input) {
  return input === null || input === undefined;
}
function cleanRegex(source) {
  const start = source.startsWith('^') ? 1 : 0;
  const end = source.endsWith('$') ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split('.')[1] || '').length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split('.')[1] || '').length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace('.', ''));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace('.', ''));
  return (valInt % stepInt) / 10 ** decCount;
}
const EVALUATING = Symbol('evaluating');
function defineLazy(object, key, getter) {
  let value = undefined;
  Object.defineProperty(object, key, {
    get() {
      if (value === EVALUATING) {
        // Circular reference detected, return undefined to break the cycle
        return undefined;
      }
      if (value === undefined) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object, key, {
        value: v,
        // configurable: true,
      });
      // object[key] = v;
    },
    configurable: true,
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true,
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path) return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map(key => promisesObj[key]);
  return Promise.all(promises).then(results => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = 'abcdefghijklmnopqrstuvwxyz';
  let str = '';
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
const captureStackTrace = 'captureStackTrace' in Error ? Error.captureStackTrace : (..._args) => {};
function util_isObject(data) {
  return typeof data === 'object' && data !== null && !Array.isArray(data);
}
const util_allowsEval = cached(() => {
  // @ts-ignore
  if (typeof navigator !== 'undefined' && navigator?.userAgent?.includes('Cloudflare')) {
    return false;
  }
  try {
    const F = Function;
    new F('');
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (util_isObject(o) === false) return false;
  // modified constructor
  const ctor = o.constructor;
  if (ctor === undefined) return true;
  // modified prototype
  const prot = ctor.prototype;
  if (util_isObject(prot) === false) return false;
  // ctor doesn't have static `isPrototypeOf`
  if (Object.prototype.hasOwnProperty.call(prot, 'isPrototypeOf') === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o)) return { ...o };
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
const getParsedType = data => {
  const t = typeof data;
  switch (t) {
    case 'undefined':
      return 'undefined';
    case 'string':
      return 'string';
    case 'number':
      return Number.isNaN(data) ? 'nan' : 'number';
    case 'boolean':
      return 'boolean';
    case 'function':
      return 'function';
    case 'bigint':
      return 'bigint';
    case 'symbol':
      return 'symbol';
    case 'object':
      if (Array.isArray(data)) {
        return 'array';
      }
      if (data === null) {
        return 'null';
      }
      if (data.then && typeof data.then === 'function' && data.catch && typeof data.catch === 'function') {
        return 'promise';
      }
      if (typeof Map !== 'undefined' && data instanceof Map) {
        return 'map';
      }
      if (typeof Set !== 'undefined' && data instanceof Set) {
        return 'set';
      }
      if (typeof Date !== 'undefined' && data instanceof Date) {
        return 'date';
      }
      // @ts-ignore
      if (typeof File !== 'undefined' && data instanceof File) {
        return 'file';
      }
      return 'object';
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
const propertyKeyTypes = new Set(['string', 'number', 'symbol']);
const primitiveTypes = new Set(['string', 'number', 'bigint', 'boolean', 'symbol', 'undefined']);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
// zod-specific utils
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent) cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params) return {};
  if (typeof params === 'string') return { error: () => params };
  if (params?.message !== undefined) {
    if (params?.error !== undefined) throw new Error('Cannot specify both `message` and `error` params');
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === 'string') return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy(
    {},
    {
      get(_, prop, receiver) {
        target ?? (target = getter());
        return Reflect.get(target, prop, receiver);
      },
      set(_, prop, value, receiver) {
        target ?? (target = getter());
        return Reflect.set(target, prop, value, receiver);
      },
      has(_, prop) {
        target ?? (target = getter());
        return Reflect.has(target, prop);
      },
      deleteProperty(_, prop) {
        target ?? (target = getter());
        return Reflect.deleteProperty(target, prop);
      },
      ownKeys(_) {
        target ?? (target = getter());
        return Reflect.ownKeys(target);
      },
      getOwnPropertyDescriptor(_, prop) {
        target ?? (target = getter());
        return Reflect.getOwnPropertyDescriptor(target, prop);
      },
      defineProperty(_, prop, descriptor) {
        target ?? (target = getter());
        return Reflect.defineProperty(target, prop, descriptor);
      },
    },
  );
}
function stringifyPrimitive(value) {
  if (typeof value === 'bigint') return value.toString() + 'n';
  if (typeof value === 'string') return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter(k => {
    return shape[k]._zod.optin === 'optional' && shape[k]._zod.optout === 'optional';
  });
}
const NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-3.4028234663852886e38, 3.4028234663852886e38],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
const BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__*/ BigInt('-9223372036854775808'), /* @__PURE__*/ BigInt('9223372036854775807')],
  uint64: [/* @__PURE__*/ BigInt(0), /* @__PURE__*/ BigInt('18446744073709551615')],
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key]) continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, 'shape', newShape); // self-caching
      return newShape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key]) continue;
        delete newShape[key];
      }
      assignProp(this, 'shape', newShape); // self-caching
      return newShape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error('Invalid input to extend: expected a plain object');
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error('Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.');
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, 'shape', _shape); // self-caching
      return _shape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error('Invalid input to safeExtend: expected a plain object');
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, 'shape', _shape); // self-caching
      return _shape;
    },
    checks: schema._zod.def.checks,
  };
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, 'shape', _shape); // self-caching
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: [], // delete existing checks
  });
  return clone(a, def);
}
function partial(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key]) continue;
          // if (oldShape[key]!._zod.optin === "optional") continue;
          shape[key] = Class
            ? new Class({
                type: 'optional',
                innerType: oldShape[key],
              })
            : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          // if (oldShape[key]!._zod.optin === "optional") continue;
          shape[key] = Class
            ? new Class({
                type: 'optional',
                innerType: oldShape[key],
              })
            : oldShape[key];
        }
      }
      assignProp(this, 'shape', shape); // self-caching
      return shape;
    },
    checks: [],
  });
  return clone(schema, def);
}
function required(Class, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key]) continue;
          // overwrite with non-optional
          shape[key] = new Class({
            type: 'nonoptional',
            innerType: oldShape[key],
          });
        }
      } else {
        for (const key in oldShape) {
          // overwrite with non-optional
          shape[key] = new Class({
            type: 'nonoptional',
            innerType: oldShape[key],
          });
        }
      }
      assignProp(this, 'shape', shape); // self-caching
      return shape;
    },
    checks: [],
  });
  return clone(schema, def);
}
// invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom
function aborted(x, startIndex = 0) {
  if (x.aborted === true) return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map(iss => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === 'string' ? message : message?.message;
}
function finalizeIssue(iss, ctx, config) {
  const full = { ...iss, path: iss.path ?? [] };
  // for backwards compatibility
  if (!iss.message) {
    const message =
      unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
      unwrapMessage(ctx?.error?.(iss)) ??
      unwrapMessage(config.customError?.(iss)) ??
      unwrapMessage(config.localeError?.(iss)) ??
      'Invalid input';
    full.message = message;
  }
  // delete (full as any).def;
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set) return 'set';
  if (input instanceof Map) return 'map';
  // @ts-ignore
  if (input instanceof File) return 'file';
  return 'unknown';
}
function getLengthableOrigin(input) {
  if (Array.isArray(input)) return 'array';
  if (typeof input === 'string') return 'string';
  return 'unknown';
}
function util_issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === 'string') {
    return {
      message: iss,
      code: 'custom',
      input,
      inst,
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj)
    .filter(([k, _]) => {
      // return true if NaN, meaning it's not a number, thus a string key
      return Number.isNaN(Number.parseInt(k, 10));
    })
    .map(el => el[1]);
}
// Codec utility functions
function base64ToUint8Array(base64) {
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = '';
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url) {
  const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
  const padding = '='.repeat((4 - (base64.length % 4)) % 4);
  return base64ToUint8Array(base64 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}
function hexToUint8Array(hex) {
  const cleanHex = hex.replace(/^0x/, '');
  if (cleanHex.length % 2 !== 0) {
    throw new Error('Invalid hex string length');
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes)
    .map(b => b.toString(16).padStart(2, '0'))
    .join('');
}
// instanceof
class Class {
  constructor(..._args) {}
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/checks.js

// import { $ZodType } from "./schemas.js";

const $ZodCheck = /*@__PURE__*/ $constructor('$ZodCheck', (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
  number: 'number',
  bigint: 'bigint',
  object: 'date',
};
const $ZodCheckLessThan = /*@__PURE__*/ $constructor('$ZodCheckLessThan', (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive) bag.maximum = def.value;
      else bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = payload => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: 'too_big',
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckGreaterThan = /*@__PURE__*/ $constructor('$ZodCheckGreaterThan', (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive) bag.minimum = def.value;
      else bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = payload => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: 'too_small',
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckMultipleOf = /*@__PURE__*/ $constructor('$ZodCheckMultipleOf', (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push(inst => {
    var _a;
    (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = payload => {
    if (typeof payload.value !== typeof def.value)
      throw new Error('Cannot mix number and bigint in multiple_of check.');
    const isMultiple =
      typeof payload.value === 'bigint'
        ? payload.value % def.value === BigInt(0)
        : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple) return;
    payload.issues.push({
      origin: typeof payload.value,
      code: 'not_multiple_of',
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckNumberFormat = /*@__PURE__*/ $constructor('$ZodCheckNumberFormat', (inst, def) => {
  $ZodCheck.init(inst, def); // no format checks
  def.format = def.format || 'float64';
  const isInt = def.format?.includes('int');
  const origin = isInt ? 'int' : 'number';
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt) bag.pattern = integer;
  });
  inst._zod.check = payload => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        // invalid_format issue
        // payload.issues.push({
        //   expected: def.format,
        //   format: def.format,
        //   code: "invalid_format",
        //   input,
        //   inst,
        // });
        // invalid_type issue
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: 'invalid_type',
          continue: false,
          input,
          inst,
        });
        return;
        // not_multiple_of issue
        // payload.issues.push({
        //   code: "not_multiple_of",
        //   origin: "number",
        //   input,
        //   inst,
        //   divisor: 1,
        // });
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          // too_big
          payload.issues.push({
            input,
            code: 'too_big',
            maximum: Number.MAX_SAFE_INTEGER,
            note: 'Integers must be within the safe integer range.',
            inst,
            origin,
            continue: !def.abort,
          });
        } else {
          // too_small
          payload.issues.push({
            input,
            code: 'too_small',
            minimum: Number.MIN_SAFE_INTEGER,
            note: 'Integers must be within the safe integer range.',
            inst,
            origin,
            continue: !def.abort,
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: 'number',
        input,
        code: 'too_small',
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort,
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: 'number',
        input,
        code: 'too_big',
        maximum,
        inst,
      });
    }
  };
});
const $ZodCheckBigIntFormat =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodCheckBigIntFormat', (inst, def) => {
    $ZodCheck.init(inst, def); // no format checks
    const [minimum, maximum] = util.BIGINT_FORMAT_RANGES[def.format];
    inst._zod.onattach.push(inst => {
      const bag = inst._zod.bag;
      bag.format = def.format;
      bag.minimum = minimum;
      bag.maximum = maximum;
    });
    inst._zod.check = payload => {
      const input = payload.value;
      if (input < minimum) {
        payload.issues.push({
          origin: 'bigint',
          input,
          code: 'too_small',
          minimum: minimum,
          inclusive: true,
          inst,
          continue: !def.abort,
        });
      }
      if (input > maximum) {
        payload.issues.push({
          origin: 'bigint',
          input,
          code: 'too_big',
          maximum,
          inst,
        });
      }
    };
  });
const $ZodCheckMaxSize =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodCheckMaxSize', (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ??
      (_a.when = payload => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== undefined;
      });
    inst._zod.onattach.push(inst => {
      const curr = inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
      if (def.maximum < curr) inst._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = payload => {
      const input = payload.value;
      const size = input.size;
      if (size <= def.maximum) return;
      payload.issues.push({
        origin: util.getSizableOrigin(input),
        code: 'too_big',
        maximum: def.maximum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort,
      });
    };
  });
const $ZodCheckMinSize =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodCheckMinSize', (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ??
      (_a.when = payload => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== undefined;
      });
    inst._zod.onattach.push(inst => {
      const curr = inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
      if (def.minimum > curr) inst._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = payload => {
      const input = payload.value;
      const size = input.size;
      if (size >= def.minimum) return;
      payload.issues.push({
        origin: util.getSizableOrigin(input),
        code: 'too_small',
        minimum: def.minimum,
        inclusive: true,
        input,
        inst,
        continue: !def.abort,
      });
    };
  });
const $ZodCheckSizeEquals =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodCheckSizeEquals', (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ??
      (_a.when = payload => {
        const val = payload.value;
        return !util.nullish(val) && val.size !== undefined;
      });
    inst._zod.onattach.push(inst => {
      const bag = inst._zod.bag;
      bag.minimum = def.size;
      bag.maximum = def.size;
      bag.size = def.size;
    });
    inst._zod.check = payload => {
      const input = payload.value;
      const size = input.size;
      if (size === def.size) return;
      const tooBig = size > def.size;
      payload.issues.push({
        origin: util.getSizableOrigin(input),
        ...(tooBig ? { code: 'too_big', maximum: def.size } : { code: 'too_small', minimum: def.size }),
        inclusive: true,
        exact: true,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  });
const $ZodCheckMaxLength = /*@__PURE__*/ $constructor('$ZodCheckMaxLength', (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ??
    (_a.when = payload => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
  inst._zod.onattach.push(inst => {
    const curr = inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr) inst._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = payload => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum) return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: 'too_big',
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckMinLength = /*@__PURE__*/ $constructor('$ZodCheckMinLength', (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ??
    (_a.when = payload => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
  inst._zod.onattach.push(inst => {
    const curr = inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr) inst._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = payload => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum) return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: 'too_small',
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckLengthEquals = /*@__PURE__*/ $constructor('$ZodCheckLengthEquals', (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ??
    (_a.when = payload => {
      const val = payload.value;
      return !nullish(val) && val.length !== undefined;
    });
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = payload => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length) return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...(tooBig ? { code: 'too_big', maximum: def.length } : { code: 'too_small', minimum: def.length }),
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckStringFormat = /*@__PURE__*/ $constructor('$ZodCheckStringFormat', (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ??
      (_a.check = payload => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value)) return;
        payload.issues.push({
          origin: 'string',
          code: 'invalid_format',
          format: def.format,
          input: payload.value,
          ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
          inst,
          continue: !def.abort,
        });
      });
  else (_b = inst._zod).check ?? (_b.check = () => {});
});
const $ZodCheckRegex = /*@__PURE__*/ $constructor('$ZodCheckRegex', (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = payload => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value)) return;
    payload.issues.push({
      origin: 'string',
      code: 'invalid_format',
      format: 'regex',
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckLowerCase = /*@__PURE__*/ $constructor('$ZodCheckLowerCase', (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /*@__PURE__*/ $constructor('$ZodCheckUpperCase', (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /*@__PURE__*/ $constructor('$ZodCheckIncludes', (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === 'number' ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    bag.patterns ?? (bag.patterns = new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = payload => {
    if (payload.value.includes(def.includes, def.position)) return;
    payload.issues.push({
      origin: 'string',
      code: 'invalid_format',
      format: 'includes',
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckStartsWith = /*@__PURE__*/ $constructor('$ZodCheckStartsWith', (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    bag.patterns ?? (bag.patterns = new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = payload => {
    if (payload.value.startsWith(def.prefix)) return;
    payload.issues.push({
      origin: 'string',
      code: 'invalid_format',
      format: 'starts_with',
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCheckEndsWith = /*@__PURE__*/ $constructor('$ZodCheckEndsWith', (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    bag.patterns ?? (bag.patterns = new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = payload => {
    if (payload.value.endsWith(def.suffix)) return;
    payload.issues.push({
      origin: 'string',
      code: 'invalid_format',
      format: 'ends_with',
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
///////////////////////////////////
/////    $ZodCheckProperty    /////
///////////////////////////////////
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...util.prefixIssues(property, result.issues));
  }
}
const $ZodCheckProperty =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodCheckProperty', (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = payload => {
      const result = def.schema._zod.run(
        {
          value: payload.value[def.property],
          issues: [],
        },
        {},
      );
      if (result instanceof Promise) {
        return result.then(result => handleCheckPropertyResult(result, payload, def.property));
      }
      handleCheckPropertyResult(result, payload, def.property);
      return;
    };
  });
const $ZodCheckMimeType =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodCheckMimeType', (inst, def) => {
    $ZodCheck.init(inst, def);
    const mimeSet = new Set(def.mime);
    inst._zod.onattach.push(inst => {
      inst._zod.bag.mime = def.mime;
    });
    inst._zod.check = payload => {
      if (mimeSet.has(payload.value.type)) return;
      payload.issues.push({
        code: 'invalid_value',
        values: def.mime,
        input: payload.value.type,
        inst,
        continue: !def.abort,
      });
    };
  });
const $ZodCheckOverwrite = /*@__PURE__*/ $constructor('$ZodCheckOverwrite', (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = payload => {
    payload.value = def.tx(payload.value);
  };
}); // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/doc.js

class Doc {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this) this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === 'function') {
      arg(this, { execution: 'sync' });
      arg(this, { execution: 'async' });
      return;
    }
    const content = arg;
    const lines = content.split('\n').filter(x => x);
    const minIndent = Math.min(...lines.map(x => x.length - x.trimStart().length));
    const dedented = lines.map(x => x.slice(minIndent)).map(x => ' '.repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map(x => `  ${x}`)];
    // console.log(lines.join("\n"));
    return new F(...args, lines.join('\n'));
  }
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/errors.js

const initializer = (inst, def) => {
  inst.name = '$ZodError';
  Object.defineProperty(inst, '_zod', {
    value: inst._zod,
    enumerable: false,
  });
  Object.defineProperty(inst, 'issues', {
    value: def,
    enumerable: false,
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, 'toString', {
    value: () => inst.message,
    enumerable: false,
  });
};
const $ZodError = $constructor('$ZodError', initializer);
const $ZodRealError = $constructor('$ZodError', initializer, { Parent: Error });
function flattenError(error, mapper = issue => issue.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper =
    _mapper ||
    function (issue) {
      return issue.message;
    };
  const fieldErrors = { _errors: [] };
  const processError = error => {
    for (const issue of error.issues) {
      if (issue.code === 'invalid_union' && issue.errors.length) {
        issue.errors.map(issues => processError({ issues }));
      } else if (issue.code === 'invalid_key') {
        processError({ issues: issue.issues });
      } else if (issue.code === 'invalid_element') {
        processError({ issues: issue.issues });
      } else if (issue.path.length === 0) {
        fieldErrors._errors.push(mapper(issue));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue.path.length) {
          const el = issue.path[i];
          const terminal = i === issue.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}
function treeifyError(error, _mapper) {
  const mapper =
    _mapper ||
    function (issue) {
      return issue.message;
    };
  const result = { errors: [] };
  const processError = (error, path = []) => {
    var _a, _b;
    for (const issue of error.issues) {
      if (issue.code === 'invalid_union' && issue.errors.length) {
        // regular union error
        issue.errors.map(issues => processError({ issues }, issue.path));
      } else if (issue.code === 'invalid_key') {
        processError({ issues: issue.issues }, issue.path);
      } else if (issue.code === 'invalid_element') {
        processError({ issues: issue.issues }, issue.path);
      } else {
        const fullpath = [...path, ...issue.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === 'string') {
            curr.properties ?? (curr.properties = {});
            (_a = curr.properties)[el] ?? (_a[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue));
          }
          i++;
        }
      }
    }
  };
  processError(error);
  return result;
}
/** Format a ZodError as a human-readable string in the following form.
 *
 * From
 *
 * ```ts
 * ZodError {
 *   issues: [
 *     {
 *       expected: 'string',
 *       code: 'invalid_type',
 *       path: [ 'username' ],
 *       message: 'Invalid input: expected string'
 *     },
 *     {
 *       expected: 'number',
 *       code: 'invalid_type',
 *       path: [ 'favoriteNumbers', 1 ],
 *       message: 'Invalid input: expected number'
 *     }
 *   ];
 * }
 * ```
 *
 * to
 *
 * ```
 * username
 *   ✖ Expected number, received string at "username
 * favoriteNumbers[0]
 *   ✖ Invalid input: expected number
 * ```
 */
function toDotPath(_path) {
  const segs = [];
  const path = _path.map(seg => (typeof seg === 'object' ? seg.key : seg));
  for (const seg of path) {
    if (typeof seg === 'number') segs.push(`[${seg}]`);
    else if (typeof seg === 'symbol') segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg)) segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length) segs.push('.');
      segs.push(seg);
    }
  }
  return segs.join('');
}
function prettifyError(error) {
  const lines = [];
  // sort by path length
  const issues = [...error.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  // Process each issue
  for (const issue of issues) {
    lines.push(`✖ ${issue.message}`);
    if (issue.path?.length) lines.push(`  → at ${toDotPath(issue.path)}`);
  }
  // Convert Map to formatted string
  return lines.join('\n');
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/parse.js

const _parse = _Err => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map(iss => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
const parse_parse = /* @__PURE__*/ _parse($ZodRealError);
const _parseAsync = _Err => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map(iss => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
const parse_parseAsync = /* @__PURE__*/ _parseAsync($ZodRealError);
const _safeParse = _Err => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length
    ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map(iss => finalizeIssue(iss, ctx, config()))),
      }
    : { success: true, data: result.value };
};
const safeParse = /* @__PURE__*/ _safeParse($ZodRealError);
const _safeParseAsync = _Err => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) result = await result;
  return result.issues.length
    ? {
        success: false,
        error: new _Err(result.issues.map(iss => finalizeIssue(iss, ctx, config()))),
      }
    : { success: true, data: result.value };
};
const safeParseAsync = /* @__PURE__*/ _safeParseAsync($ZodRealError);
const _encode = _Err => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: 'backward' }) : { direction: 'backward' };
  return _parse(_Err)(schema, value, ctx);
};
const encode = /* @__PURE__*/ _encode($ZodRealError);
const _decode = _Err => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
const decode = /* @__PURE__*/ _decode($ZodRealError);
const _encodeAsync = _Err => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: 'backward' }) : { direction: 'backward' };
  return _parseAsync(_Err)(schema, value, ctx);
};
const encodeAsync = /* @__PURE__*/ _encodeAsync($ZodRealError);
const _decodeAsync = _Err => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
const decodeAsync = /* @__PURE__*/ _decodeAsync($ZodRealError);
const _safeEncode = _Err => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: 'backward' }) : { direction: 'backward' };
  return _safeParse(_Err)(schema, value, ctx);
};
const safeEncode = /* @__PURE__*/ _safeEncode($ZodRealError);
const _safeDecode = _Err => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
const safeDecode = /* @__PURE__*/ _safeDecode($ZodRealError);
const _safeEncodeAsync = _Err => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: 'backward' }) : { direction: 'backward' };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
const safeEncodeAsync = /* @__PURE__*/ _safeEncodeAsync($ZodRealError);
const _safeDecodeAsync = _Err => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
const safeDecodeAsync = /* @__PURE__*/ _safeDecodeAsync($ZodRealError); // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/versions.js

const version = {
  major: 4,
  minor: 1,
  patch: 5,
}; // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/schemas.js

const $ZodType = /*@__PURE__*/ $constructor('$ZodType', (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def; // set _def property
  inst._zod.bag = inst._zod.bag || {}; // initialize _bag object
  inst._zod.version = version;
  const checks = [...(inst._zod.def.checks ?? [])];
  // if inst is itself a checks.$ZodCheck, run it as a check
  if (inst._zod.traits.has('$ZodCheck')) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    // deferred initializer
    // inst._zod.parse is not yet defined
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun) continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen) return;
            if (!isAborted) isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen) continue;
          if (!isAborted) isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    // const handleChecksResult = (
    //   checkResult: ParsePayload,
    //   originalResult: ParsePayload,
    //   ctx: ParseContextInternal
    // ): util.MaybeAsync<ParsePayload> => {
    //   // if the checks mutated the value && there are no issues, re-parse the result
    //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)
    //     return inst._zod.parse(checkResult, ctx);
    //   return originalResult;
    // };
    const handleCanaryResult = (canary, payload, ctx) => {
      // abort if the canary is aborted
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      // run checks first, then
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError();
        return checkResult.then(checkResult => inst._zod.parse(checkResult, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === 'backward') {
        // run canary
        // initial pass (no checks)
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then(canary => {
            return handleCanaryResult(canary, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      // forward
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false) throw new $ZodAsyncError();
        return result.then(result => runChecks(result, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst['~standard'] = {
    validate: value => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then(r => (r.success ? { value: r.data } : { issues: r.error?.issues }));
      }
    },
    vendor: 'zod',
    version: 1,
  };
});

const $ZodString = /*@__PURE__*/ $constructor('$ZodString', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_) {}
    if (typeof payload.value === 'string') return payload;
    payload.issues.push({
      expected: 'string',
      code: 'invalid_type',
      input: payload.value,
      inst,
    });
    return payload;
  };
});
const $ZodStringFormat = /*@__PURE__*/ $constructor('$ZodStringFormat', (inst, def) => {
  // check initialization must come first
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
const $ZodGUID = /*@__PURE__*/ $constructor('$ZodGUID', (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /*@__PURE__*/ $constructor('$ZodUUID', (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8,
    };
    const v = versionMap[def.version];
    if (v === undefined) throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /*@__PURE__*/ $constructor('$ZodEmail', (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
const $ZodURL = /*@__PURE__*/ $constructor('$ZodURL', (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = payload => {
    try {
      // Trim whitespace from input
      const trimmed = payload.value.trim();
      // @ts-ignore
      const url = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: 'invalid_format',
            format: 'url',
            note: 'Invalid hostname',
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort,
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(':') ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: 'invalid_format',
            format: 'url',
            note: 'Invalid protocol',
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort,
          });
        }
      }
      // Set the output value based on normalize flag
      if (def.normalize) {
        // Use normalized URL
        payload.value = url.href;
      } else {
        // Preserve the original input (trimmed)
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: 'invalid_format',
        format: 'url',
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
const $ZodEmoji = /*@__PURE__*/ $constructor('$ZodEmoji', (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /*@__PURE__*/ $constructor('$ZodNanoID', (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /*@__PURE__*/ $constructor('$ZodCUID', (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /*@__PURE__*/ $constructor('$ZodCUID2', (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
const $ZodULID = /*@__PURE__*/ $constructor('$ZodULID', (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
const $ZodXID = /*@__PURE__*/ $constructor('$ZodXID', (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /*@__PURE__*/ $constructor('$ZodKSUID', (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /*@__PURE__*/ $constructor('$ZodISODateTime', (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /*@__PURE__*/ $constructor('$ZodISODate', (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /*@__PURE__*/ $constructor('$ZodISOTime', (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /*@__PURE__*/ $constructor('$ZodISODuration', (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /*@__PURE__*/ $constructor('$ZodIPv4', (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    bag.format = `ipv4`;
  });
});
const $ZodIPv6 = /*@__PURE__*/ $constructor('$ZodIPv6', (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push(inst => {
    const bag = inst._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = payload => {
    try {
      // @ts-ignore
      new URL(`http://[${payload.value}]`);
      // return;
    } catch {
      payload.issues.push({
        code: 'invalid_format',
        format: 'ipv6',
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
const $ZodCIDRv4 = /*@__PURE__*/ $constructor('$ZodCIDRv4', (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /*@__PURE__*/ $constructor('$ZodCIDRv6', (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6); // not used for validation
  $ZodStringFormat.init(inst, def);
  inst._zod.check = payload => {
    const [address, prefix] = payload.value.split('/');
    try {
      if (!prefix) throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix) throw new Error();
      if (prefixNum < 0 || prefixNum > 128) throw new Error();
      // @ts-ignore
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: 'invalid_format',
        format: 'cidrv6',
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    }
  };
});
//////////////////////////////   ZodBase64   //////////////////////////////
function isValidBase64(data) {
  if (data === '') return true;
  if (data.length % 4 !== 0) return false;
  try {
    // @ts-ignore
    atob(data);
    return true;
  } catch {
    return false;
  }
}
const $ZodBase64 = /*@__PURE__*/ $constructor('$ZodBase64', (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push(inst => {
    inst._zod.bag.contentEncoding = 'base64';
  });
  inst._zod.check = payload => {
    if (isValidBase64(payload.value)) return;
    payload.issues.push({
      code: 'invalid_format',
      format: 'base64',
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
//////////////////////////////   ZodBase64   //////////////////////////////
function isValidBase64URL(data) {
  if (!base64url.test(data)) return false;
  const base64 = data.replace(/[-_]/g, c => (c === '-' ? '+' : '/'));
  const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, '=');
  return isValidBase64(padded);
}
const $ZodBase64URL = /*@__PURE__*/ $constructor('$ZodBase64URL', (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push(inst => {
    inst._zod.bag.contentEncoding = 'base64url';
  });
  inst._zod.check = payload => {
    if (isValidBase64URL(payload.value)) return;
    payload.issues.push({
      code: 'invalid_format',
      format: 'base64url',
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodE164 = /*@__PURE__*/ $constructor('$ZodE164', (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
//////////////////////////////   ZodJWT   //////////////////////////////
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split('.');
    if (tokensParts.length !== 3) return false;
    const [header] = tokensParts;
    if (!header) return false;
    // @ts-ignore
    const parsedHeader = JSON.parse(atob(header));
    if ('typ' in parsedHeader && parsedHeader?.typ !== 'JWT') return false;
    if (!parsedHeader.alg) return false;
    if (algorithm && (!('alg' in parsedHeader) || parsedHeader.alg !== algorithm)) return false;
    return true;
  } catch {
    return false;
  }
}
const $ZodJWT = /*@__PURE__*/ $constructor('$ZodJWT', (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = payload => {
    if (isValidJWT(payload.value, def.alg)) return;
    payload.issues.push({
      code: 'invalid_format',
      format: 'jwt',
      input: payload.value,
      inst,
      continue: !def.abort,
    });
  };
});
const $ZodCustomStringFormat =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodCustomStringFormat', (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = payload => {
      if (def.fn(payload.value)) return;
      payload.issues.push({
        code: 'invalid_format',
        format: def.format,
        input: payload.value,
        inst,
        continue: !def.abort,
      });
    };
  });
const $ZodNumber = /*@__PURE__*/ $constructor('$ZodNumber', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === 'number' && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received =
      typeof input === 'number'
        ? Number.isNaN(input)
          ? 'NaN'
          : !Number.isFinite(input)
            ? 'Infinity'
            : undefined
        : undefined;
    payload.issues.push({
      expected: 'number',
      code: 'invalid_type',
      input,
      inst,
      ...(received ? { received } : {}),
    });
    return payload;
  };
});
const $ZodNumberFormat = /*@__PURE__*/ $constructor('$ZodNumber', (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def); // no format checksp
});
const $ZodBoolean = /*@__PURE__*/ $constructor('$ZodBoolean', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = regexes_boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {}
    const input = payload.value;
    if (typeof input === 'boolean') return payload;
    payload.issues.push({
      expected: 'boolean',
      code: 'invalid_type',
      input,
      inst,
    });
    return payload;
  };
});
const $ZodBigInt =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodBigInt', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = regexes.bigint;
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce)
        try {
          payload.value = BigInt(payload.value);
        } catch (_) {}
      if (typeof payload.value === 'bigint') return payload;
      payload.issues.push({
        expected: 'bigint',
        code: 'invalid_type',
        input: payload.value,
        inst,
      });
      return payload;
    };
  });
const $ZodBigIntFormat =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodBigInt', (inst, def) => {
    checks.$ZodCheckBigIntFormat.init(inst, def);
    $ZodBigInt.init(inst, def); // no format checks
  });
const $ZodSymbol =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodSymbol', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === 'symbol') return payload;
      payload.issues.push({
        expected: 'symbol',
        code: 'invalid_type',
        input,
        inst,
      });
      return payload;
    };
  });
const $ZodUndefined =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodUndefined', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = regexes.undefined;
    inst._zod.values = new Set([undefined]);
    inst._zod.optin = 'optional';
    inst._zod.optout = 'optional';
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (typeof input === 'undefined') return payload;
      payload.issues.push({
        expected: 'undefined',
        code: 'invalid_type',
        input,
        inst,
      });
      return payload;
    };
  });
const $ZodNull =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodNull', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = regexes.null;
    inst._zod.values = new Set([null]);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      if (input === null) return payload;
      payload.issues.push({
        expected: 'null',
        code: 'invalid_type',
        input,
        inst,
      });
      return payload;
    };
  });
const $ZodAny = /*@__PURE__*/ $constructor('$ZodAny', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = payload => payload;
});
const $ZodUnknown = /*@__PURE__*/ $constructor('$ZodUnknown', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = payload => payload;
});
const $ZodNever = /*@__PURE__*/ $constructor('$ZodNever', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: 'never',
      code: 'invalid_type',
      input: payload.value,
      inst,
    });
    return payload;
  };
});
const $ZodVoid = /*@__PURE__*/ $constructor('$ZodVoid', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === 'undefined') return payload;
    payload.issues.push({
      expected: 'void',
      code: 'invalid_type',
      input,
      inst,
    });
    return payload;
  };
});
const $ZodDate =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodDate', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (def.coerce) {
        try {
          payload.value = new Date(payload.value);
        } catch (_err) {}
      }
      const input = payload.value;
      const isDate = input instanceof Date;
      const isValidDate = isDate && !Number.isNaN(input.getTime());
      if (isValidDate) return payload;
      payload.issues.push({
        expected: 'date',
        code: 'invalid_type',
        input,
        ...(isDate ? { received: 'Invalid Date' } : {}),
        inst,
      });
      return payload;
    };
  });
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
const $ZodArray = /*@__PURE__*/ $constructor('$ZodArray', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: 'array',
        code: 'invalid_type',
        input,
        inst,
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run(
        {
          value: item,
          issues: [],
        },
        ctx,
      );
      if (result instanceof Promise) {
        proms.push(result.then(result => handleArrayResult(result, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload; //handleArrayResultsAsync(parseResults, final);
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === undefined) {
    if (key in input) {
      final.value[key] = undefined;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape[k]._zod.traits.has('$ZodType')) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys),
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  // iterate over input keys
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key of Object.keys(input)) {
    if (keySet.has(key)) continue;
    if (t === 'never') {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then(r => handlePropertyResult(r, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: 'unrecognized_keys',
      keys: unrecognized,
      input,
      inst,
    });
  }
  if (!proms.length) return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
const $ZodObject = /*@__PURE__*/ $constructor('$ZodObject', (inst, def) => {
  // requires cast because technically $ZodObject doesn't extend
  $ZodType.init(inst, def);
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, 'propValues', () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = new Set());
        for (const v of field.values) propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject = util_isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        expected: 'object',
        code: 'invalid_type',
        input,
        inst,
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then(r => handlePropertyResult(r, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
const $ZodObjectJIT = /*@__PURE__*/ $constructor('$ZodObjectJIT', (inst, def) => {
  // requires cast because technically $ZodObject doesn't extend
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = shape => {
    const doc = new Doc(['shape', 'payload', 'ctx']);
    const normalized = _normalized.value;
    const parseStr = key => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    // A: preserve key order {
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject = util_isObject;
  const jit = !globalConfig.jitless;
  const allowsEval = util_allowsEval;
  const fastEnabled = jit && allowsEval.value; // && !def.catchall;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        expected: 'object',
        code: 'invalid_type',
        input,
        inst,
      });
      return payload;
    }
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      // always synchronous
      if (!fastpass) fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall) return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter(r => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: 'invalid_union',
    input: final.value,
    inst,
    errors: results.map(result => result.issues.map(iss => finalizeIssue(iss, ctx, config()))),
  });
  return final;
}
const $ZodUnion = /*@__PURE__*/ $constructor('$ZodUnion', (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, 'optin', () => (def.options.some(o => o._zod.optin === 'optional') ? 'optional' : undefined));
  defineLazy(inst._zod, 'optout', () => (def.options.some(o => o._zod.optout === 'optional') ? 'optional' : undefined));
  defineLazy(inst._zod, 'values', () => {
    if (def.options.every(o => o._zod.values)) {
      return new Set(def.options.flatMap(option => Array.from(option._zod.values)));
    }
    return undefined;
  });
  defineLazy(inst._zod, 'pattern', () => {
    if (def.options.every(o => o._zod.pattern)) {
      const patterns = def.options.map(o => o._zod.pattern);
      return new RegExp(`^(${patterns.map(p => cleanRegex(p.source)).join('|')})$`);
    }
    return undefined;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run(
        {
          value: payload.value,
          issues: [],
        },
        ctx,
      );
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0) return result;
        results.push(result);
      }
    }
    if (!async) return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then(results => {
      return handleUnionResults(results, payload, inst, ctx);
    });
  };
});
const $ZodDiscriminatedUnion =
  /*@__PURE__*/
  /* unused pure expression or super */ null &&
  core.$constructor('$ZodDiscriminatedUnion', (inst, def) => {
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    util.defineLazy(inst._zod, 'propValues', () => {
      const propValues = {};
      for (const option of def.options) {
        const pv = option._zod.propValues;
        if (!pv || Object.keys(pv).length === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
        for (const [k, v] of Object.entries(pv)) {
          if (!propValues[k]) propValues[k] = new Set();
          for (const val of v) {
            propValues[k].add(val);
          }
        }
      }
      return propValues;
    });
    const disc = util.cached(() => {
      const opts = def.options;
      const map = new Map();
      for (const o of opts) {
        const values = o._zod.propValues?.[def.discriminator];
        if (!values || values.size === 0)
          throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
        for (const v of values) {
          if (map.has(v)) {
            throw new Error(`Duplicate discriminator value "${String(v)}"`);
          }
          map.set(v, o);
        }
      }
      return map;
    });
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!util.isObject(input)) {
        payload.issues.push({
          code: 'invalid_type',
          expected: 'object',
          input,
          inst,
        });
        return payload;
      }
      const opt = disc.value.get(input?.[def.discriminator]);
      if (opt) {
        return opt._zod.run(payload, ctx);
      }
      if (def.unionFallback) {
        return _super(payload, ctx);
      }
      // no matching discriminator
      payload.issues.push({
        code: 'invalid_union',
        errors: [],
        note: 'No matching discriminator',
        discriminator: def.discriminator,
        input,
        path: [def.discriminator],
        inst,
      });
      return payload;
    };
  });
const $ZodIntersection = /*@__PURE__*/ $constructor('$ZodIntersection', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left, right]) => {
        return handleIntersectionResults(payload, left, right);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  // const aType = parse.t(a);
  // const bType = parse.t(b);
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter(key => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result)) return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
const $ZodTuple =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodTuple', (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    const optStart = items.length - [...items].reverse().findIndex(item => item._zod.optin !== 'optional');
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!Array.isArray(input)) {
        payload.issues.push({
          input,
          inst,
          expected: 'tuple',
          code: 'invalid_type',
        });
        return payload;
      }
      payload.value = [];
      const proms = [];
      if (!def.rest) {
        const tooBig = input.length > items.length;
        const tooSmall = input.length < optStart - 1;
        if (tooBig || tooSmall) {
          payload.issues.push({
            ...(tooBig ? { code: 'too_big', maximum: items.length } : { code: 'too_small', minimum: items.length }),
            input,
            inst,
            origin: 'array',
          });
          return payload;
        }
      }
      let i = -1;
      for (const item of items) {
        i++;
        if (i >= input.length) if (i >= optStart) continue;
        const result = item._zod.run(
          {
            value: input[i],
            issues: [],
          },
          ctx,
        );
        if (result instanceof Promise) {
          proms.push(result.then(result => handleTupleResult(result, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
      if (def.rest) {
        const rest = input.slice(items.length);
        for (const el of rest) {
          i++;
          const result = def.rest._zod.run(
            {
              value: el,
              issues: [],
            },
            ctx,
          );
          if (result instanceof Promise) {
            proms.push(result.then(result => handleTupleResult(result, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
      }
      if (proms.length) return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...util.prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
const $ZodRecord = /*@__PURE__*/ $constructor('$ZodRecord', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: 'record',
        code: 'invalid_type',
        input,
        inst,
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === 'string' || typeof key === 'number' || typeof key === 'symbol') {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(
              result.then(result => {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key, result.issues));
                }
                payload.value[key] = result.value;
              }),
            );
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: 'unrecognized_keys',
          input,
          inst,
          keys: unrecognized,
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === '__proto__') continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error('Async schemas not supported in object keys currently');
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: 'invalid_key',
            origin: 'record',
            issues: keyResult.issues.map(iss => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst,
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(
            result.then(result => {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }),
          );
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
const $ZodMap =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodMap', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Map)) {
        payload.issues.push({
          expected: 'map',
          code: 'invalid_type',
          input,
          inst,
        });
        return payload;
      }
      const proms = [];
      payload.value = new Map();
      for (const [key, value] of input) {
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        const valueResult = def.valueType._zod.run({ value: value, issues: [] }, ctx);
        if (keyResult instanceof Promise || valueResult instanceof Promise) {
          proms.push(
            Promise.all([keyResult, valueResult]).then(([keyResult, valueResult]) => {
              handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
            }),
          );
        } else {
          handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
        }
      }
      if (proms.length) return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (util.propertyKeyTypes.has(typeof key)) {
      final.issues.push(...util.prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: 'invalid_key',
        origin: 'map',
        input,
        inst,
        issues: keyResult.issues.map(iss => util.finalizeIssue(iss, ctx, core.config())),
      });
    }
  }
  if (valueResult.issues.length) {
    if (util.propertyKeyTypes.has(typeof key)) {
      final.issues.push(...util.prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: 'map',
        code: 'invalid_element',
        input,
        inst,
        key: key,
        issues: valueResult.issues.map(iss => util.finalizeIssue(iss, ctx, core.config())),
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
const $ZodSet =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodSet', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      const input = payload.value;
      if (!(input instanceof Set)) {
        payload.issues.push({
          input,
          inst,
          expected: 'set',
          code: 'invalid_type',
        });
        return payload;
      }
      const proms = [];
      payload.value = new Set();
      for (const item of input) {
        const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then(result => handleSetResult(result, payload)));
        } else handleSetResult(result, payload);
      }
      if (proms.length) return Promise.all(proms).then(() => payload);
      return payload;
    };
  });
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
const $ZodEnum = /*@__PURE__*/ $constructor('$ZodEnum', (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(
    `^(${values
      .filter(k => propertyKeyTypes.has(typeof k))
      .map(o => (typeof o === 'string' ? escapeRegex(o) : o.toString()))
      .join('|')})$`,
  );
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: 'invalid_value',
      values,
      input,
      inst,
    });
    return payload;
  };
});
const $ZodLiteral = /*@__PURE__*/ $constructor('$ZodLiteral', (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error('Cannot create literal schema with no valid values');
  }
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(
    `^(${def.values
      .map(o => (typeof o === 'string' ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)))
      .join('|')})$`,
  );
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: 'invalid_value',
      values: def.values,
      input,
      inst,
    });
    return payload;
  };
});
const $ZodFile =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodFile', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      const input = payload.value;
      // @ts-ignore
      if (input instanceof File) return payload;
      payload.issues.push({
        expected: 'file',
        code: 'invalid_type',
        input,
        inst,
      });
      return payload;
    };
  });
const $ZodTransform = /*@__PURE__*/ $constructor('$ZodTransform', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === 'backward') {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then(output => {
        payload.value = output;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === undefined) {
    return { issues: [], value: undefined };
  }
  return result;
}
const $ZodOptional = /*@__PURE__*/ $constructor('$ZodOptional', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = 'optional';
  inst._zod.optout = 'optional';
  defineLazy(inst._zod, 'values', () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
  });
  defineLazy(inst._zod, 'pattern', () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === 'optional') {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) return result.then(r => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === undefined) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNullable = /*@__PURE__*/ $constructor('$ZodNullable', (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, 'optin', () => def.innerType._zod.optin);
  defineLazy(inst._zod, 'optout', () => def.innerType._zod.optout);
  defineLazy(inst._zod, 'pattern', () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
  });
  defineLazy(inst._zod, 'values', () => {
    return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    // Forward direction (decode): allow null to pass through
    if (payload.value === null) return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodDefault = /*@__PURE__*/ $constructor('$ZodDefault', (inst, def) => {
  $ZodType.init(inst, def);
  // inst._zod.qin = "true";
  inst._zod.optin = 'optional';
  defineLazy(inst._zod, 'values', () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === 'backward') {
      return def.innerType._zod.run(payload, ctx);
    }
    // Forward direction (decode): apply defaults for undefined input
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
      /**
       * $ZodDefault returns the default value immediately in forward direction.
       * It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
      return payload;
    }
    // Forward direction: continue with default handling
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(result => handleDefaultResult(result, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === undefined) {
    payload.value = def.defaultValue;
  }
  return payload;
}
const $ZodPrefault = /*@__PURE__*/ $constructor('$ZodPrefault', (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = 'optional';
  defineLazy(inst._zod, 'values', () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === 'backward') {
      return def.innerType._zod.run(payload, ctx);
    }
    // Forward direction (decode): apply prefault for undefined input
    if (payload.value === undefined) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
const $ZodNonOptional = /*@__PURE__*/ $constructor('$ZodNonOptional', (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, 'values', () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter(x => x !== undefined)) : undefined;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(result => handleNonOptionalResult(result, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === undefined) {
    payload.issues.push({
      code: 'invalid_type',
      expected: 'nonoptional',
      input: payload.value,
      inst,
    });
  }
  return payload;
}
const $ZodSuccess =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodSuccess', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      if (ctx.direction === 'backward') {
        throw new core.$ZodEncodeError('ZodSuccess');
      }
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise) {
        return result.then(result => {
          payload.value = result.issues.length === 0;
          return payload;
        });
      }
      payload.value = result.issues.length === 0;
      return payload;
    };
  });
const $ZodCatch = /*@__PURE__*/ $constructor('$ZodCatch', (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, 'optin', () => def.innerType._zod.optin);
  defineLazy(inst._zod, 'optout', () => def.innerType._zod.optout);
  defineLazy(inst._zod, 'values', () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === 'backward') {
      return def.innerType._zod.run(payload, ctx);
    }
    // Forward direction (decode): apply catch logic
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(result => {
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map(iss => finalizeIssue(iss, ctx, config())),
            },
            input: payload.value,
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map(iss => finalizeIssue(iss, ctx, config())),
        },
        input: payload.value,
      });
      payload.issues = [];
    }
    return payload;
  };
});
const $ZodNaN =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodNaN', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== 'number' || !Number.isNaN(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: 'nan',
          code: 'invalid_type',
        });
        return payload;
      }
      return payload;
    };
  });
const $ZodPipe = /*@__PURE__*/ $constructor('$ZodPipe', (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, 'values', () => def.in._zod.values);
  defineLazy(inst._zod, 'optin', () => def.in._zod.optin);
  defineLazy(inst._zod, 'optout', () => def.out._zod.optout);
  defineLazy(inst._zod, 'propValues', () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === 'backward') {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then(right => handlePipeResult(right, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then(left => handlePipeResult(left, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    // prevent further checks
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodCodec =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodCodec', (inst, def) => {
    $ZodType.init(inst, def);
    util.defineLazy(inst._zod, 'values', () => def.in._zod.values);
    util.defineLazy(inst._zod, 'optin', () => def.in._zod.optin);
    util.defineLazy(inst._zod, 'optout', () => def.out._zod.optout);
    util.defineLazy(inst._zod, 'propValues', () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
      const direction = ctx.direction || 'forward';
      if (direction === 'forward') {
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then(left => handleCodecAResult(left, def, ctx));
        }
        return handleCodecAResult(left, def, ctx);
      } else {
        const right = def.out._zod.run(payload, ctx);
        if (right instanceof Promise) {
          return right.then(right => handleCodecAResult(right, def, ctx));
        }
        return handleCodecAResult(right, def, ctx);
      }
    };
  });
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    // prevent further checks
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || 'forward';
  if (direction === 'forward') {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then(value => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then(value => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  // Check if transform added any issues
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
const $ZodReadonly = /*@__PURE__*/ $constructor('$ZodReadonly', (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, 'propValues', () => def.innerType._zod.propValues);
  defineLazy(inst._zod, 'values', () => def.innerType._zod.values);
  defineLazy(inst._zod, 'optin', () => def.innerType._zod.optin);
  defineLazy(inst._zod, 'optout', () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === 'backward') {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
const $ZodTemplateLiteral =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodTemplateLiteral', (inst, def) => {
    $ZodType.init(inst, def);
    const regexParts = [];
    for (const part of def.parts) {
      if (typeof part === 'object' && part !== null) {
        // is Zod schema
        if (!part._zod.pattern) {
          // if (!source)
          throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
        }
        const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
        if (!source) throw new Error(`Invalid template literal part: ${part._zod.traits}`);
        const start = source.startsWith('^') ? 1 : 0;
        const end = source.endsWith('$') ? source.length - 1 : source.length;
        regexParts.push(source.slice(start, end));
      } else if (part === null || util.primitiveTypes.has(typeof part)) {
        regexParts.push(util.escapeRegex(`${part}`));
      } else {
        throw new Error(`Invalid template literal part: ${part}`);
      }
    }
    inst._zod.pattern = new RegExp(`^${regexParts.join('')}$`);
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== 'string') {
        payload.issues.push({
          input: payload.value,
          inst,
          expected: 'template_literal',
          code: 'invalid_type',
        });
        return payload;
      }
      inst._zod.pattern.lastIndex = 0;
      if (!inst._zod.pattern.test(payload.value)) {
        payload.issues.push({
          input: payload.value,
          inst,
          code: 'invalid_format',
          format: def.format ?? 'template_literal',
          pattern: inst._zod.pattern.source,
        });
        return payload;
      }
      return payload;
    };
  });
const $ZodFunction =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodFunction', (inst, def) => {
    $ZodType.init(inst, def);
    inst._def = def;
    inst._zod.def = def;
    inst.implement = func => {
      if (typeof func !== 'function') {
        throw new Error('implement() must be called with a function');
      }
      return function (...args) {
        const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
        const result = Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return parse(inst._def.output, result);
        }
        return result;
      };
    };
    inst.implementAsync = func => {
      if (typeof func !== 'function') {
        throw new Error('implementAsync() must be called with a function');
      }
      return async function (...args) {
        const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
        const result = await Reflect.apply(func, this, parsedArgs);
        if (inst._def.output) {
          return await parseAsync(inst._def.output, result);
        }
        return result;
      };
    };
    inst._zod.parse = (payload, _ctx) => {
      if (typeof payload.value !== 'function') {
        payload.issues.push({
          code: 'invalid_type',
          expected: 'function',
          input: payload.value,
          inst,
        });
        return payload;
      }
      // Check if output is a promise type to determine if we should use async implementation
      const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === 'promise';
      if (hasPromiseOutput) {
        payload.value = inst.implementAsync(payload.value);
      } else {
        payload.value = inst.implement(payload.value);
      }
      return payload;
    };
    inst.input = (...args) => {
      const F = inst.constructor;
      if (Array.isArray(args[0])) {
        return new F({
          type: 'function',
          input: new $ZodTuple({
            type: 'tuple',
            items: args[0],
            rest: args[1],
          }),
          output: inst._def.output,
        });
      }
      return new F({
        type: 'function',
        input: args[0],
        output: inst._def.output,
      });
    };
    inst.output = output => {
      const F = inst.constructor;
      return new F({
        type: 'function',
        input: inst._def.input,
        output,
      });
    };
    return inst;
  });
const $ZodPromise =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodPromise', (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
      return Promise.resolve(payload.value).then(inner => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
    };
  });
const $ZodLazy =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('$ZodLazy', (inst, def) => {
    $ZodType.init(inst, def);
    // let _innerType!: any;
    // util.defineLazy(def, "getter", () => {
    //   if (!_innerType) {
    //     _innerType = def.getter();
    //   }
    //   return () => _innerType;
    // });
    util.defineLazy(inst._zod, 'innerType', () => def.getter());
    util.defineLazy(inst._zod, 'pattern', () => inst._zod.innerType._zod.pattern);
    util.defineLazy(inst._zod, 'propValues', () => inst._zod.innerType._zod.propValues);
    util.defineLazy(inst._zod, 'optin', () => inst._zod.innerType._zod.optin ?? undefined);
    util.defineLazy(inst._zod, 'optout', () => inst._zod.innerType._zod.optout ?? undefined);
    inst._zod.parse = (payload, ctx) => {
      const inner = inst._zod.innerType;
      return inner._zod.run(payload, ctx);
    };
  });
const $ZodCustom = /*@__PURE__*/ $constructor('$ZodCustom', (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = payload => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then(r => handleRefineResult(r, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: 'custom',
      input,
      inst, // incorporates params.error into issue reporting
      path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort,
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params) _iss.params = inst._zod.def.params;
    payload.issues.push(util_issue(_iss));
  }
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/registries.js

const $output = Symbol('ZodOutput');
const $input = Symbol('ZodInput');
class $ZodRegistry {
  constructor() {
    this._map = new Map();
    this._idmap = new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === 'object' && 'id' in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = new Map();
    this._idmap = new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === 'object' && 'id' in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    // return this._map.get(schema) as any;
    // inherit metadata
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...(this.get(p) ?? {}) };
      delete pm.id; // do not inherit id
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : undefined;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
}
// registries
function registry() {
  return new $ZodRegistry();
}
const globalRegistry = /*@__PURE__*/ registry(); // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/core/api.js

function _string(Class, params) {
  return new Class({
    type: 'string',
    ...normalizeParams(params),
  });
}
function _coercedString(Class, params) {
  return new Class({
    type: 'string',
    coerce: true,
    ...util.normalizeParams(params),
  });
}
function _email(Class, params) {
  return new Class({
    type: 'string',
    format: 'email',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _guid(Class, params) {
  return new Class({
    type: 'string',
    format: 'guid',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _uuid(Class, params) {
  return new Class({
    type: 'string',
    format: 'uuid',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _uuidv4(Class, params) {
  return new Class({
    type: 'string',
    format: 'uuid',
    check: 'string_format',
    abort: false,
    version: 'v4',
    ...normalizeParams(params),
  });
}
function _uuidv6(Class, params) {
  return new Class({
    type: 'string',
    format: 'uuid',
    check: 'string_format',
    abort: false,
    version: 'v6',
    ...normalizeParams(params),
  });
}
function _uuidv7(Class, params) {
  return new Class({
    type: 'string',
    format: 'uuid',
    check: 'string_format',
    abort: false,
    version: 'v7',
    ...normalizeParams(params),
  });
}
function _url(Class, params) {
  return new Class({
    type: 'string',
    format: 'url',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function api_emoji(Class, params) {
  return new Class({
    type: 'string',
    format: 'emoji',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _nanoid(Class, params) {
  return new Class({
    type: 'string',
    format: 'nanoid',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _cuid(Class, params) {
  return new Class({
    type: 'string',
    format: 'cuid',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _cuid2(Class, params) {
  return new Class({
    type: 'string',
    format: 'cuid2',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _ulid(Class, params) {
  return new Class({
    type: 'string',
    format: 'ulid',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _xid(Class, params) {
  return new Class({
    type: 'string',
    format: 'xid',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _ksuid(Class, params) {
  return new Class({
    type: 'string',
    format: 'ksuid',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _ipv4(Class, params) {
  return new Class({
    type: 'string',
    format: 'ipv4',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _ipv6(Class, params) {
  return new Class({
    type: 'string',
    format: 'ipv6',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _cidrv4(Class, params) {
  return new Class({
    type: 'string',
    format: 'cidrv4',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _cidrv6(Class, params) {
  return new Class({
    type: 'string',
    format: 'cidrv6',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _base64(Class, params) {
  return new Class({
    type: 'string',
    format: 'base64',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _base64url(Class, params) {
  return new Class({
    type: 'string',
    format: 'base64url',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _e164(Class, params) {
  return new Class({
    type: 'string',
    format: 'e164',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
function _jwt(Class, params) {
  return new Class({
    type: 'string',
    format: 'jwt',
    check: 'string_format',
    abort: false,
    ...normalizeParams(params),
  });
}
const TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6,
};
function _isoDateTime(Class, params) {
  return new Class({
    type: 'string',
    format: 'datetime',
    check: 'string_format',
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params),
  });
}
function _isoDate(Class, params) {
  return new Class({
    type: 'string',
    format: 'date',
    check: 'string_format',
    ...normalizeParams(params),
  });
}
function _isoTime(Class, params) {
  return new Class({
    type: 'string',
    format: 'time',
    check: 'string_format',
    precision: null,
    ...normalizeParams(params),
  });
}
function _isoDuration(Class, params) {
  return new Class({
    type: 'string',
    format: 'duration',
    check: 'string_format',
    ...normalizeParams(params),
  });
}
function _number(Class, params) {
  return new Class({
    type: 'number',
    checks: [],
    ...normalizeParams(params),
  });
}
function _coercedNumber(Class, params) {
  return new Class({
    type: 'number',
    coerce: true,
    checks: [],
    ...util.normalizeParams(params),
  });
}
function _int(Class, params) {
  return new Class({
    type: 'number',
    check: 'number_format',
    abort: false,
    format: 'safeint',
    ...normalizeParams(params),
  });
}
function _float32(Class, params) {
  return new Class({
    type: 'number',
    check: 'number_format',
    abort: false,
    format: 'float32',
    ...util.normalizeParams(params),
  });
}
function _float64(Class, params) {
  return new Class({
    type: 'number',
    check: 'number_format',
    abort: false,
    format: 'float64',
    ...util.normalizeParams(params),
  });
}
function _int32(Class, params) {
  return new Class({
    type: 'number',
    check: 'number_format',
    abort: false,
    format: 'int32',
    ...util.normalizeParams(params),
  });
}
function _uint32(Class, params) {
  return new Class({
    type: 'number',
    check: 'number_format',
    abort: false,
    format: 'uint32',
    ...util.normalizeParams(params),
  });
}
function _boolean(Class, params) {
  return new Class({
    type: 'boolean',
    ...normalizeParams(params),
  });
}
function _coercedBoolean(Class, params) {
  return new Class({
    type: 'boolean',
    coerce: true,
    ...util.normalizeParams(params),
  });
}
function _bigint(Class, params) {
  return new Class({
    type: 'bigint',
    ...util.normalizeParams(params),
  });
}
function _coercedBigint(Class, params) {
  return new Class({
    type: 'bigint',
    coerce: true,
    ...util.normalizeParams(params),
  });
}
function _int64(Class, params) {
  return new Class({
    type: 'bigint',
    check: 'bigint_format',
    abort: false,
    format: 'int64',
    ...util.normalizeParams(params),
  });
}
function _uint64(Class, params) {
  return new Class({
    type: 'bigint',
    check: 'bigint_format',
    abort: false,
    format: 'uint64',
    ...util.normalizeParams(params),
  });
}
function _symbol(Class, params) {
  return new Class({
    type: 'symbol',
    ...util.normalizeParams(params),
  });
}
function api_undefined(Class, params) {
  return new Class({
    type: 'undefined',
    ...util.normalizeParams(params),
  });
}
function api_null(Class, params) {
  return new Class({
    type: 'null',
    ...util.normalizeParams(params),
  });
}
function _any(Class) {
  return new Class({
    type: 'any',
  });
}
function _unknown(Class) {
  return new Class({
    type: 'unknown',
  });
}
function _never(Class, params) {
  return new Class({
    type: 'never',
    ...normalizeParams(params),
  });
}
function _void(Class, params) {
  return new Class({
    type: 'void',
    ...normalizeParams(params),
  });
}
function _date(Class, params) {
  return new Class({
    type: 'date',
    ...util.normalizeParams(params),
  });
}
function _coercedDate(Class, params) {
  return new Class({
    type: 'date',
    coerce: true,
    ...util.normalizeParams(params),
  });
}
function _nan(Class, params) {
  return new Class({
    type: 'nan',
    ...util.normalizeParams(params),
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: 'less_than',
    ...normalizeParams(params),
    value,
    inclusive: false,
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: 'less_than',
    ...normalizeParams(params),
    value,
    inclusive: true,
  });
}

function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: 'greater_than',
    ...normalizeParams(params),
    value,
    inclusive: false,
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: 'greater_than',
    ...normalizeParams(params),
    value,
    inclusive: true,
  });
}

function _positive(params) {
  return _gt(0, params);
}
// negative
function _negative(params) {
  return _lt(0, params);
}
// nonpositive
function _nonpositive(params) {
  return _lte(0, params);
}
// nonnegative
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: 'multiple_of',
    ...normalizeParams(params),
    value,
  });
}
function _maxSize(maximum, params) {
  return new checks.$ZodCheckMaxSize({
    check: 'max_size',
    ...util.normalizeParams(params),
    maximum,
  });
}
function _minSize(minimum, params) {
  return new checks.$ZodCheckMinSize({
    check: 'min_size',
    ...util.normalizeParams(params),
    minimum,
  });
}
function _size(size, params) {
  return new checks.$ZodCheckSizeEquals({
    check: 'size_equals',
    ...util.normalizeParams(params),
    size,
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: 'max_length',
    ...normalizeParams(params),
    maximum,
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: 'min_length',
    ...normalizeParams(params),
    minimum,
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: 'length_equals',
    ...normalizeParams(params),
    length,
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: 'string_format',
    format: 'regex',
    ...normalizeParams(params),
    pattern,
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: 'string_format',
    format: 'lowercase',
    ...normalizeParams(params),
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: 'string_format',
    format: 'uppercase',
    ...normalizeParams(params),
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: 'string_format',
    format: 'includes',
    ...normalizeParams(params),
    includes,
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: 'string_format',
    format: 'starts_with',
    ...normalizeParams(params),
    prefix,
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: 'string_format',
    format: 'ends_with',
    ...normalizeParams(params),
    suffix,
  });
}
function _property(property, schema, params) {
  return new checks.$ZodCheckProperty({
    check: 'property',
    property,
    schema,
    ...util.normalizeParams(params),
  });
}
function _mime(types, params) {
  return new checks.$ZodCheckMimeType({
    check: 'mime_type',
    mime: types,
    ...util.normalizeParams(params),
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: 'overwrite',
    tx,
  });
}
// normalize
function _normalize(form) {
  return _overwrite(input => input.normalize(form));
}
// trim
function _trim() {
  return _overwrite(input => input.trim());
}
// toLowerCase
function _toLowerCase() {
  return _overwrite(input => input.toLowerCase());
}
// toUpperCase
function _toUpperCase() {
  return _overwrite(input => input.toUpperCase());
}
function _array(Class, element, params) {
  return new Class({
    type: 'array',
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params),
  });
}
function _union(Class, options, params) {
  return new Class({
    type: 'union',
    options,
    ...util.normalizeParams(params),
  });
}
function _discriminatedUnion(Class, discriminator, options, params) {
  return new Class({
    type: 'union',
    options,
    discriminator,
    ...util.normalizeParams(params),
  });
}
function _intersection(Class, left, right) {
  return new Class({
    type: 'intersection',
    left,
    right,
  });
}
// export function _tuple(
//   Class: util.SchemaClass<schemas.$ZodTuple>,
//   items: [],
//   params?: string | $ZodTupleParams
// ): schemas.$ZodTuple<[], null>;
function _tuple(Class, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof schemas.$ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class({
    type: 'tuple',
    items,
    rest,
    ...util.normalizeParams(params),
  });
}
function _record(Class, keyType, valueType, params) {
  return new Class({
    type: 'record',
    keyType,
    valueType,
    ...util.normalizeParams(params),
  });
}
function _map(Class, keyType, valueType, params) {
  return new Class({
    type: 'map',
    keyType,
    valueType,
    ...util.normalizeParams(params),
  });
}
function _set(Class, valueType, params) {
  return new Class({
    type: 'set',
    valueType,
    ...util.normalizeParams(params),
  });
}
function _enum(Class, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map(v => [v, v])) : values;
  // if (Array.isArray(values)) {
  //   for (const value of values) {
  //     entries[value] = value;
  //   }
  // } else {
  //   Object.assign(entries, values);
  // }
  // const entries: util.EnumLike = {};
  // for (const val of values) {
  //   entries[val] = val;
  // }
  return new Class({
    type: 'enum',
    entries,
    ...util.normalizeParams(params),
  });
}
/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
 *
 * ```ts
 * enum Colors { red, green, blue }
 * z.enum(Colors);
 * ```
 */
function _nativeEnum(Class, entries, params) {
  return new Class({
    type: 'enum',
    entries,
    ...util.normalizeParams(params),
  });
}
function _literal(Class, value, params) {
  return new Class({
    type: 'literal',
    values: Array.isArray(value) ? value : [value],
    ...util.normalizeParams(params),
  });
}
function _file(Class, params) {
  return new Class({
    type: 'file',
    ...util.normalizeParams(params),
  });
}
function _transform(Class, fn) {
  return new Class({
    type: 'transform',
    transform: fn,
  });
}
function _optional(Class, innerType) {
  return new Class({
    type: 'optional',
    innerType,
  });
}
function _nullable(Class, innerType) {
  return new Class({
    type: 'nullable',
    innerType,
  });
}
function _default(Class, innerType, defaultValue) {
  return new Class({
    type: 'default',
    innerType,
    get defaultValue() {
      return typeof defaultValue === 'function' ? defaultValue() : util.shallowClone(defaultValue);
    },
  });
}
function _nonoptional(Class, innerType, params) {
  return new Class({
    type: 'nonoptional',
    innerType,
    ...util.normalizeParams(params),
  });
}
function _success(Class, innerType) {
  return new Class({
    type: 'success',
    innerType,
  });
}
function _catch(Class, innerType, catchValue) {
  return new Class({
    type: 'catch',
    innerType,
    catchValue: typeof catchValue === 'function' ? catchValue : () => catchValue,
  });
}
function _pipe(Class, in_, out) {
  return new Class({
    type: 'pipe',
    in: in_,
    out,
  });
}
function _readonly(Class, innerType) {
  return new Class({
    type: 'readonly',
    innerType,
  });
}
function _templateLiteral(Class, parts, params) {
  return new Class({
    type: 'template_literal',
    parts,
    ...util.normalizeParams(params),
  });
}
function _lazy(Class, getter) {
  return new Class({
    type: 'lazy',
    getter,
  });
}
function _promise(Class, innerType) {
  return new Class({
    type: 'promise',
    innerType,
  });
}
function _custom(Class, fn, _params) {
  const norm = util.normalizeParams(_params);
  norm.abort ?? (norm.abort = true); // default to abort:false
  const schema = new Class({
    type: 'custom',
    check: 'custom',
    fn: fn,
    ...norm,
  });
  return schema;
}
// same as _custom but defaults to abort:false
function _refine(Class, fn, _params) {
  const schema = new Class({
    type: 'custom',
    check: 'custom',
    fn: fn,
    ...normalizeParams(_params),
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check(payload => {
    payload.addIssue = issue => {
      if (typeof issue === 'string') {
        payload.issues.push(util_issue(issue, payload.value, ch._zod.def));
      } else {
        // for Zod 3 backwards compatibility
        const _issue = issue;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = 'custom');
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...
        payload.issues.push(util_issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: 'custom',
    ...normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function _stringbool(Classes, _params) {
  const params = util.normalizeParams(_params);
  let truthyArray = params.truthy ?? ['true', '1', 'yes', 'on', 'y', 'enabled'];
  let falsyArray = params.falsy ?? ['false', '0', 'no', 'off', 'n', 'disabled'];
  if (params.case !== 'sensitive') {
    truthyArray = truthyArray.map(v => (typeof v === 'string' ? v.toLowerCase() : v));
    falsyArray = falsyArray.map(v => (typeof v === 'string' ? v.toLowerCase() : v));
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? schemas.$ZodCodec;
  const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;
  const _String = Classes.String ?? schemas.$ZodString;
  const stringSchema = new _String({ type: 'string', error: params.error });
  const booleanSchema = new _Boolean({ type: 'boolean', error: params.error });
  const codec = new _Codec({
    type: 'pipe',
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== 'sensitive') data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: 'invalid_value',
          expected: 'stringbool',
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false,
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || 'true';
      } else {
        return falsyArray[0] || 'false';
      }
    },
    error: params.error,
  });
  return codec;
}
function _stringFormat(Class, format, fnOrRegex, _params = {}) {
  const params = util.normalizeParams(_params);
  const def = {
    ...util.normalizeParams(_params),
    check: 'string_format',
    type: 'string',
    format,
    fn: typeof fnOrRegex === 'function' ? fnOrRegex : val => fnOrRegex.test(val),
    ...params,
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class(def);
  return inst;
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/classic/iso.js

const ZodISODateTime = /*@__PURE__*/ $constructor('ZodISODateTime', (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function iso_datetime(params) {
  return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /*@__PURE__*/ $constructor('ZodISODate', (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function iso_date(params) {
  return _isoDate(ZodISODate, params);
}
const ZodISOTime = /*@__PURE__*/ $constructor('ZodISOTime', (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function iso_time(params) {
  return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /*@__PURE__*/ $constructor('ZodISODuration', (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function iso_duration(params) {
  return _isoDuration(ZodISODuration, params);
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/classic/errors.js

const errors_initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = 'ZodError';
  Object.defineProperties(inst, {
    format: {
      value: mapper => formatError(inst, mapper),
      // enumerable: false,
    },
    flatten: {
      value: mapper => flattenError(inst, mapper),
      // enumerable: false,
    },
    addIssue: {
      value: issue => {
        inst.issues.push(issue);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      },
      // enumerable: false,
    },
    addIssues: {
      value: issues => {
        inst.issues.push(...issues);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      },
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      },
      // enumerable: false,
    },
  });
  // Object.defineProperty(inst, "isEmpty", {
  //   get() {
  //     return inst.issues.length === 0;
  //   },
  // });
};
const ZodError = $constructor('ZodError', errors_initializer);
const ZodRealError = $constructor('ZodError', errors_initializer, {
  Parent: Error,
}); // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/classic/parse.js
// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */
// export type ErrorMapCtx = core.$ZodErrorMapCtx;

const classic_parse_parse = /* @__PURE__ */ _parse(ZodRealError);
const classic_parse_parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const parse_safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const parse_safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
// Codec functions
const parse_encode = /* @__PURE__ */ _encode(ZodRealError);
const parse_decode = /* @__PURE__ */ _decode(ZodRealError);
const parse_encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const parse_decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const parse_safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const parse_safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const parse_safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const parse_safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError); // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/classic/schemas.js

const ZodType = /*@__PURE__*/ $constructor('ZodType', (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, '_def', { value: def });
  // base methods
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...(def.checks ?? []),
          ...checks.map(ch =>
            typeof ch === 'function' ? { _zod: { check: ch, def: { check: 'custom' }, onattach: [] } } : ch,
          ),
        ],
      },
      // { parent: true }
    );
  };
  inst.clone = (def, params) => clone(inst, def, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  // parsing
  inst.parse = (data, params) => classic_parse_parse(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => parse_safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => classic_parse_parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => parse_safeParseAsync(inst, data, params);
  inst.spa = inst.safeParseAsync;
  // encoding/decoding
  inst.encode = (data, params) => parse_encode(inst, data, params);
  inst.decode = (data, params) => parse_decode(inst, data, params);
  inst.encodeAsync = async (data, params) => parse_encodeAsync(inst, data, params);
  inst.decodeAsync = async (data, params) => parse_decodeAsync(inst, data, params);
  inst.safeEncode = (data, params) => parse_safeEncode(inst, data, params);
  inst.safeDecode = (data, params) => parse_safeDecode(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => parse_safeEncodeAsync(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => parse_safeDecodeAsync(inst, data, params);
  // refinements
  inst.refine = (check, params) => inst.check(refine(check, params));
  inst.superRefine = refinement => inst.check(superRefine(refinement));
  inst.overwrite = fn => inst.check(_overwrite(fn));
  // wrappers
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = params => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = arg => union([inst, arg]);
  inst.and = arg => intersection(inst, arg);
  inst.transform = tx => pipe(inst, transform(tx));
  inst.default = def => schemas_default(inst, def);
  inst.prefault = def => prefault(inst, def);
  // inst.coalesce = (def, params) => coalesce(inst, def, params);
  inst.catch = params => schemas_catch(inst, params);
  inst.pipe = target => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  // meta
  inst.describe = description => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, 'description', {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true,
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  // helpers
  inst.isOptional = () => inst.safeParse(undefined).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
/** @internal */
const _ZodString = /*@__PURE__*/ $constructor('_ZodString', (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  // validations
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = params => inst.check(_lowercase(params));
  inst.uppercase = params => inst.check(_uppercase(params));
  // transforms
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
const ZodString = /*@__PURE__*/ $constructor('ZodString', (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = params => inst.check(_email(ZodEmail, params));
  inst.url = params => inst.check(_url(ZodURL, params));
  inst.jwt = params => inst.check(_jwt(ZodJWT, params));
  inst.emoji = params => inst.check(api_emoji(ZodEmoji, params));
  inst.guid = params => inst.check(_guid(ZodGUID, params));
  inst.uuid = params => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = params => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = params => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = params => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = params => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = params => inst.check(_guid(ZodGUID, params));
  inst.cuid = params => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = params => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = params => inst.check(_ulid(ZodULID, params));
  inst.base64 = params => inst.check(_base64(ZodBase64, params));
  inst.base64url = params => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = params => inst.check(_xid(ZodXID, params));
  inst.ksuid = params => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = params => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = params => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = params => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = params => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = params => inst.check(_e164(ZodE164, params));
  // iso
  inst.datetime = params => inst.check(iso_datetime(params));
  inst.date = params => inst.check(iso_date(params));
  inst.time = params => inst.check(iso_time(params));
  inst.duration = params => inst.check(iso_duration(params));
});
function schemas_string(params) {
  return _string(ZodString, params);
}
const ZodStringFormat = /*@__PURE__*/ $constructor('ZodStringFormat', (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
const ZodEmail = /*@__PURE__*/ $constructor('ZodEmail', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_email(params) {
  return core._email(ZodEmail, params);
}
const ZodGUID = /*@__PURE__*/ $constructor('ZodGUID', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_guid(params) {
  return core._guid(ZodGUID, params);
}
const ZodUUID = /*@__PURE__*/ $constructor('ZodUUID', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_uuid(params) {
  return core._uuid(ZodUUID, params);
}
function uuidv4(params) {
  return core._uuidv4(ZodUUID, params);
}
// ZodUUIDv6
function uuidv6(params) {
  return core._uuidv6(ZodUUID, params);
}
// ZodUUIDv7
function uuidv7(params) {
  return core._uuidv7(ZodUUID, params);
}
const ZodURL = /*@__PURE__*/ $constructor('ZodURL', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return core._url(ZodURL, params);
}
function httpUrl(params) {
  return core._url(ZodURL, {
    protocol: /^https?$/,
    hostname: core.regexes.domain,
    ...util.normalizeParams(params),
  });
}
const ZodEmoji = /*@__PURE__*/ $constructor('ZodEmoji', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_emoji(params) {
  return core._emoji(ZodEmoji, params);
}
const ZodNanoID = /*@__PURE__*/ $constructor('ZodNanoID', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_nanoid(params) {
  return core._nanoid(ZodNanoID, params);
}
const ZodCUID = /*@__PURE__*/ $constructor('ZodCUID', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_cuid(params) {
  return core._cuid(ZodCUID, params);
}
const ZodCUID2 = /*@__PURE__*/ $constructor('ZodCUID2', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_cuid2(params) {
  return core._cuid2(ZodCUID2, params);
}
const ZodULID = /*@__PURE__*/ $constructor('ZodULID', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_ulid(params) {
  return core._ulid(ZodULID, params);
}
const ZodXID = /*@__PURE__*/ $constructor('ZodXID', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_xid(params) {
  return core._xid(ZodXID, params);
}
const ZodKSUID = /*@__PURE__*/ $constructor('ZodKSUID', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_ksuid(params) {
  return core._ksuid(ZodKSUID, params);
}
const ZodIPv4 = /*@__PURE__*/ $constructor('ZodIPv4', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_ipv4(params) {
  return core._ipv4(ZodIPv4, params);
}
const ZodIPv6 = /*@__PURE__*/ $constructor('ZodIPv6', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_ipv6(params) {
  return core._ipv6(ZodIPv6, params);
}
const ZodCIDRv4 = /*@__PURE__*/ $constructor('ZodCIDRv4', (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_cidrv4(params) {
  return core._cidrv4(ZodCIDRv4, params);
}
const ZodCIDRv6 = /*@__PURE__*/ $constructor('ZodCIDRv6', (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_cidrv6(params) {
  return core._cidrv6(ZodCIDRv6, params);
}
const ZodBase64 = /*@__PURE__*/ $constructor('ZodBase64', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_base64(params) {
  return core._base64(ZodBase64, params);
}
const ZodBase64URL = /*@__PURE__*/ $constructor('ZodBase64URL', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_base64url(params) {
  return core._base64url(ZodBase64URL, params);
}
const ZodE164 = /*@__PURE__*/ $constructor('ZodE164', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function schemas_e164(params) {
  return core._e164(ZodE164, params);
}
const ZodJWT = /*@__PURE__*/ $constructor('ZodJWT', (inst, def) => {
  // ZodStringFormat.init(inst, def);
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return core._jwt(ZodJWT, params);
}
const ZodCustomStringFormat =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodCustomStringFormat', (inst, def) => {
    // ZodStringFormat.init(inst, def);
    core.$ZodCustomStringFormat.init(inst, def);
    ZodStringFormat.init(inst, def);
  });
function stringFormat(format, fnOrRegex, _params = {}) {
  return core._stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function schemas_hostname(_params) {
  return core._stringFormat(ZodCustomStringFormat, 'hostname', core.regexes.hostname, _params);
}
function schemas_hex(_params) {
  return core._stringFormat(ZodCustomStringFormat, 'hex', core.regexes.hex, _params);
}
function hash(alg, params) {
  const enc = params?.enc ?? 'hex';
  const format = `${alg}_${enc}`;
  const regex = core.regexes[format];
  if (!regex) throw new Error(`Unrecognized hash format: ${format}`);
  return core._stringFormat(ZodCustomStringFormat, format, regex, params);
}
const ZodNumber = /*@__PURE__*/ $constructor('ZodNumber', (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = params => inst.check(schemas_int(params));
  inst.safe = params => inst.check(schemas_int(params));
  inst.positive = params => inst.check(_gt(0, params));
  inst.nonnegative = params => inst.check(_gte(0, params));
  inst.negative = params => inst.check(_lt(0, params));
  inst.nonpositive = params => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  // inst.finite = (params) => inst.check(core.finite(params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue =
    Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue =
    Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? '').includes('int') || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function schemas_number(params) {
  return _number(ZodNumber, params);
}
const ZodNumberFormat = /*@__PURE__*/ $constructor('ZodNumberFormat', (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function schemas_int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return core._float32(ZodNumberFormat, params);
}
function float64(params) {
  return core._float64(ZodNumberFormat, params);
}
function int32(params) {
  return core._int32(ZodNumberFormat, params);
}
function uint32(params) {
  return core._uint32(ZodNumberFormat, params);
}
const ZodBoolean = /*@__PURE__*/ $constructor('ZodBoolean', (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function schemas_boolean(params) {
  return _boolean(ZodBoolean, params);
}
const ZodBigInt =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodBigInt', (inst, def) => {
    core.$ZodBigInt.init(inst, def);
    ZodType.init(inst, def);
    inst.gte = (value, params) => inst.check(checks.gte(value, params));
    inst.min = (value, params) => inst.check(checks.gte(value, params));
    inst.gt = (value, params) => inst.check(checks.gt(value, params));
    inst.gte = (value, params) => inst.check(checks.gte(value, params));
    inst.min = (value, params) => inst.check(checks.gte(value, params));
    inst.lt = (value, params) => inst.check(checks.lt(value, params));
    inst.lte = (value, params) => inst.check(checks.lte(value, params));
    inst.max = (value, params) => inst.check(checks.lte(value, params));
    inst.positive = params => inst.check(checks.gt(BigInt(0), params));
    inst.negative = params => inst.check(checks.lt(BigInt(0), params));
    inst.nonpositive = params => inst.check(checks.lte(BigInt(0), params));
    inst.nonnegative = params => inst.check(checks.gte(BigInt(0), params));
    inst.multipleOf = (value, params) => inst.check(checks.multipleOf(value, params));
    const bag = inst._zod.bag;
    inst.minValue = bag.minimum ?? null;
    inst.maxValue = bag.maximum ?? null;
    inst.format = bag.format ?? null;
  });
function schemas_bigint(params) {
  return core._bigint(ZodBigInt, params);
}
const ZodBigIntFormat =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodBigIntFormat', (inst, def) => {
    core.$ZodBigIntFormat.init(inst, def);
    ZodBigInt.init(inst, def);
  });
// int64
function int64(params) {
  return core._int64(ZodBigIntFormat, params);
}
// uint64
function uint64(params) {
  return core._uint64(ZodBigIntFormat, params);
}
const ZodSymbol =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodSymbol', (inst, def) => {
    core.$ZodSymbol.init(inst, def);
    ZodType.init(inst, def);
  });
function symbol(params) {
  return core._symbol(ZodSymbol, params);
}
const ZodUndefined =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodUndefined', (inst, def) => {
    core.$ZodUndefined.init(inst, def);
    ZodType.init(inst, def);
  });
function schemas_undefined(params) {
  return core._undefined(ZodUndefined, params);
}

const ZodNull =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodNull', (inst, def) => {
    core.$ZodNull.init(inst, def);
    ZodType.init(inst, def);
  });
function schemas_null(params) {
  return core._null(ZodNull, params);
}

const ZodAny = /*@__PURE__*/ $constructor('ZodAny', (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
const ZodUnknown = /*@__PURE__*/ $constructor('ZodUnknown', (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
const ZodNever = /*@__PURE__*/ $constructor('ZodNever', (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
const ZodVoid = /*@__PURE__*/ $constructor('ZodVoid', (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function schemas_void(params) {
  return _void(ZodVoid, params);
}

const ZodDate =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodDate', (inst, def) => {
    core.$ZodDate.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (value, params) => inst.check(checks.gte(value, params));
    inst.max = (value, params) => inst.check(checks.lte(value, params));
    const c = inst._zod.bag;
    inst.minDate = c.minimum ? new Date(c.minimum) : null;
    inst.maxDate = c.maximum ? new Date(c.maximum) : null;
  });
function schemas_date(params) {
  return core._date(ZodDate, params);
}
const ZodArray = /*@__PURE__*/ $constructor('ZodArray', (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = params => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
// .keyof
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return schemas_enum(Object.keys(shape));
}
const ZodObject = /*@__PURE__*/ $constructor('ZodObject', (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  defineLazy(inst, 'shape', () => def.shape);
  inst.keyof = () => schemas_enum(Object.keys(inst._zod.def.shape));
  inst.catchall = catchall => inst.clone({ ...inst._zod.def, catchall: catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
  inst.extend = incoming => {
    return extend(inst, incoming);
  };
  inst.safeExtend = incoming => {
    return safeExtend(inst, incoming);
  };
  inst.merge = other => merge(inst, other);
  inst.pick = mask => pick(inst, mask);
  inst.omit = mask => omit(inst, mask);
  inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: 'object',
    get shape() {
      assignProp(this, 'shape', shape ? objectClone(shape) : {});
      return this.shape;
    },
    ...normalizeParams(params),
  };
  return new ZodObject(def);
}
// strictObject
function strictObject(shape, params) {
  return new ZodObject({
    type: 'object',
    get shape() {
      assignProp(this, 'shape', objectClone(shape));
      return this.shape;
    },
    catchall: never(),
    ...normalizeParams(params),
  });
}
// looseObject
function looseObject(shape, params) {
  return new ZodObject({
    type: 'object',
    get shape() {
      util.assignProp(this, 'shape', util.objectClone(shape));
      return this.shape;
    },
    catchall: unknown(),
    ...util.normalizeParams(params),
  });
}
const ZodUnion = /*@__PURE__*/ $constructor('ZodUnion', (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: 'union',
    options: options,
    ...normalizeParams(params),
  });
}
const ZodDiscriminatedUnion =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodDiscriminatedUnion', (inst, def) => {
    ZodUnion.init(inst, def);
    core.$ZodDiscriminatedUnion.init(inst, def);
  });
function discriminatedUnion(discriminator, options, params) {
  // const [options, params] = args;
  return new ZodDiscriminatedUnion({
    type: 'union',
    options,
    discriminator,
    ...util.normalizeParams(params),
  });
}
const ZodIntersection = /*@__PURE__*/ $constructor('ZodIntersection', (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: 'intersection',
    left: left,
    right: right,
  });
}
const ZodTuple =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodTuple', (inst, def) => {
    core.$ZodTuple.init(inst, def);
    ZodType.init(inst, def);
    inst.rest = rest =>
      inst.clone({
        ...inst._zod.def,
        rest: rest,
      });
  });
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof core.$ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: 'tuple',
    items: items,
    rest,
    ...util.normalizeParams(params),
  });
}
const ZodRecord = /*@__PURE__*/ $constructor('ZodRecord', (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: 'record',
    keyType,
    valueType: valueType,
    ...normalizeParams(params),
  });
}
// type alksjf = core.output<core.$ZodRecordKey>;
function partialRecord(keyType, valueType, params) {
  const k = core.clone(keyType);
  k._zod.values = undefined;
  return new ZodRecord({
    type: 'record',
    keyType: k,
    valueType: valueType,
    ...util.normalizeParams(params),
  });
}
const ZodMap =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodMap', (inst, def) => {
    core.$ZodMap.init(inst, def);
    ZodType.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
  });
function map(keyType, valueType, params) {
  return new ZodMap({
    type: 'map',
    keyType: keyType,
    valueType: valueType,
    ...util.normalizeParams(params),
  });
}
const ZodSet =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodSet', (inst, def) => {
    core.$ZodSet.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (...args) => inst.check(core._minSize(...args));
    inst.nonempty = params => inst.check(core._minSize(1, params));
    inst.max = (...args) => inst.check(core._maxSize(...args));
    inst.size = (...args) => inst.check(core._size(...args));
  });
function set(valueType, params) {
  return new ZodSet({
    type: 'set',
    valueType: valueType,
    ...util.normalizeParams(params),
  });
}
const ZodEnum = /*@__PURE__*/ $constructor('ZodEnum', (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries,
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...normalizeParams(params),
      entries: newEntries,
    });
  };
});
function schemas_enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map(v => [v, v])) : values;
  return new ZodEnum({
    type: 'enum',
    entries,
    ...normalizeParams(params),
  });
}

/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
 *
 * ```ts
 * enum Colors { red, green, blue }
 * z.enum(Colors);
 * ```
 */
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: 'enum',
    entries,
    ...util.normalizeParams(params),
  });
}
const ZodLiteral = /*@__PURE__*/ $constructor('ZodLiteral', (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, 'value', {
    get() {
      if (def.values.length > 1) {
        throw new Error('This schema contains multiple valid literal values. Use `.values` instead.');
      }
      return def.values[0];
    },
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: 'literal',
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params),
  });
}
const ZodFile =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodFile', (inst, def) => {
    core.$ZodFile.init(inst, def);
    ZodType.init(inst, def);
    inst.min = (size, params) => inst.check(core._minSize(size, params));
    inst.max = (size, params) => inst.check(core._maxSize(size, params));
    inst.mime = (types, params) => inst.check(core._mime(Array.isArray(types) ? types : [types], params));
  });
function file(params) {
  return core._file(ZodFile, params);
}
const ZodTransform = /*@__PURE__*/ $constructor('ZodTransform', (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === 'backward') {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = issue => {
      if (typeof issue === 'string') {
        payload.issues.push(util_issue(issue, payload.value, def));
      } else {
        // for Zod 3 backwards compatibility
        const _issue = issue;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ?? (_issue.code = 'custom');
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        // _issue.continue ??= true;
        payload.issues.push(util_issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then(output => {
        payload.value = output;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: 'transform',
    transform: fn,
  });
}
const ZodOptional = /*@__PURE__*/ $constructor('ZodOptional', (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: 'optional',
    innerType: innerType,
  });
}
const ZodNullable = /*@__PURE__*/ $constructor('ZodNullable', (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: 'nullable',
    innerType: innerType,
  });
}
// nullish
function schemas_nullish(innerType) {
  return optional(nullable(innerType));
}
const ZodDefault = /*@__PURE__*/ $constructor('ZodDefault', (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function schemas_default(innerType, defaultValue) {
  return new ZodDefault({
    type: 'default',
    innerType: innerType,
    get defaultValue() {
      return typeof defaultValue === 'function' ? defaultValue() : shallowClone(defaultValue);
    },
  });
}
const ZodPrefault = /*@__PURE__*/ $constructor('ZodPrefault', (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: 'prefault',
    innerType: innerType,
    get defaultValue() {
      return typeof defaultValue === 'function' ? defaultValue() : shallowClone(defaultValue);
    },
  });
}
const ZodNonOptional = /*@__PURE__*/ $constructor('ZodNonOptional', (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: 'nonoptional',
    innerType: innerType,
    ...normalizeParams(params),
  });
}
const ZodSuccess =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodSuccess', (inst, def) => {
    core.$ZodSuccess.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
function success(innerType) {
  return new ZodSuccess({
    type: 'success',
    innerType: innerType,
  });
}
const ZodCatch = /*@__PURE__*/ $constructor('ZodCatch', (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function schemas_catch(innerType, catchValue) {
  return new ZodCatch({
    type: 'catch',
    innerType: innerType,
    catchValue: typeof catchValue === 'function' ? catchValue : () => catchValue,
  });
}

const ZodNaN =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodNaN', (inst, def) => {
    core.$ZodNaN.init(inst, def);
    ZodType.init(inst, def);
  });
function nan(params) {
  return core._nan(ZodNaN, params);
}
const ZodPipe = /*@__PURE__*/ $constructor('ZodPipe', (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: 'pipe',
    in: in_,
    out: out,
    // ...util.normalizeParams(params),
  });
}
const ZodCodec =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodCodec', (inst, def) => {
    ZodPipe.init(inst, def);
    core.$ZodCodec.init(inst, def);
  });
function codec(in_, out, params) {
  return new ZodCodec({
    type: 'pipe',
    in: in_,
    out: out,
    transform: params.decode,
    reverseTransform: params.encode,
  });
}
const ZodReadonly = /*@__PURE__*/ $constructor('ZodReadonly', (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: 'readonly',
    innerType: innerType,
  });
}
const ZodTemplateLiteral =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodTemplateLiteral', (inst, def) => {
    core.$ZodTemplateLiteral.init(inst, def);
    ZodType.init(inst, def);
  });
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: 'template_literal',
    parts,
    ...util.normalizeParams(params),
  });
}
const ZodLazy =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodLazy', (inst, def) => {
    core.$ZodLazy.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.getter();
  });
function lazy(getter) {
  return new ZodLazy({
    type: 'lazy',
    getter: getter,
  });
}
const ZodPromise =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodPromise', (inst, def) => {
    core.$ZodPromise.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
  });
function promise(innerType) {
  return new ZodPromise({
    type: 'promise',
    innerType: innerType,
  });
}
const ZodFunction =
  /*@__PURE__*/ /* unused pure expression or super */ null &&
  core.$constructor('ZodFunction', (inst, def) => {
    core.$ZodFunction.init(inst, def);
    ZodType.init(inst, def);
  });
function _function(params) {
  return new ZodFunction({
    type: 'function',
    input: Array.isArray(params?.input) ? tuple(params?.input) : (params?.input ?? array(unknown())),
    output: params?.output ?? unknown(),
  });
}

const ZodCustom = /*@__PURE__*/ $constructor('ZodCustom', (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
// custom checks
function check(fn) {
  const ch = new core.$ZodCheck({
    check: 'custom',
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return core._custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
// superRefine
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(
  cls,
  params = {
    error: `Input not instance of ${cls.name}`,
  },
) {
  const inst = new ZodCustom({
    type: 'custom',
    check: 'custom',
    fn: data => data instanceof cls,
    abort: true,
    ...util.normalizeParams(params),
  });
  inst._zod.bag.Class = cls;
  return inst;
}

// stringbool
const stringbool = (...args) =>
  core._stringbool(
    {
      Codec: ZodCodec,
      Boolean: ZodBoolean,
      String: ZodString,
    },
    ...args,
  );
function json(params) {
  const jsonSchema = lazy(() => {
    return union([
      schemas_string(params),
      schemas_number(),
      schemas_boolean(),
      schemas_null(),
      array(jsonSchema),
      record(schemas_string(), jsonSchema),
    ]);
  });
  return jsonSchema;
}
// preprocess
// /** @deprecated Use `z.pipe()` and `z.transform()` instead. */
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
} // ./src/type/settings.en.ts

const Config_type = schemas_enum(['worldbook', 'preset']);
const Config = strictObject({
  type: Config_type,
  name: schemas_string(),
  file: schemas_string()
    .regex(/^(?:(?:[a-zA-Z]:|\.|\.\.)?([\\/][^\\/]+)*|[^\\/]+)$/)
    .transform(string => (string.endsWith('.yaml') ? string : string + '.yaml')),
});
const Settings = strictObject({
  user_name: schemas_string().regex(/^\S+$/),
  configs: record(schemas_string(), Config),
}); // ./src/type/settings.zh.ts

const zh_to_en_map = {
  user名称: 'user_name',
  配置: 'configs',
  类型: 'type',
  世界书: 'worldbook',
  预设: 'preset',
  酒馆中的名称: 'name',
  本地文件路径: 'file',
};
function is_zh(data) {
  return _.has(data, '配置');
}
const settings_zh_Config_type = schemas_enum(['世界书', '预设']);
const settings_zh_Config = strictObject({
  类型: settings_zh_Config_type,
  酒馆中的名称: schemas_string(),
  本地文件路径: schemas_string()
    .regex(/^(?:(?:[a-zA-Z]:|\.|\.\.)?([\\/][^\\/]+)*|[^\\/]+)$/)
    .transform(string => (string.endsWith('.yaml') ? string : string + '.yaml')),
});
const settings_zh_Settings = strictObject({
  user名称: schemas_string().regex(/^\S+$/),
  配置: record(schemas_string(), settings_zh_Config),
});

// EXTERNAL MODULE: external "node:process"
var external_node_process_ = __webpack_require__(1708);
// EXTERNAL MODULE: ./node_modules/.pnpm/yaml@2.8.1/node_modules/yaml/dist/index.js
var dist = __webpack_require__(8452); // ./src/server/settings.ts
var settings_dirname = __webpack_fileURLToPath__(import.meta.url + '/..').slice(0, -1);

let settings = null;
function get_settings() {
  if (!settings) {
    const config_file = (0, external_node_path_.resolve)(settings_dirname, 'tavern_sync.yaml');
    if (!(0, external_node_fs_.existsSync)(config_file)) {
      write_file_recursively(settings_dirname, config_file, settings_defaultraw_namespaceObject);
      console.error(`配置文件不存在，已自动生成在 '${config_file}'，请填写配置文件后重新运行`);
      (0, external_node_process_.exit)(1);
    }
    const data = dist.parse((0, external_node_fs_.readFileSync)(config_file, 'utf8'));
    if (is_zh(data)) {
      settings = translate(settings_zh_Settings.parse(data), zh_to_en_map);
    } else {
      settings = Settings.parse(data);
    }
  }
  return settings;
} // ./src/server/component/beauingfy_configs.ts

function beauingfy_configs() {
  return `可用的配置有: (使用 'all' 或 '所有' 来选择所有配置)
${Object.entries(get_settings().configs)
  .map(([name, value]) => `- (${_.invert(zh_to_en_map)[value.type]}) ${name}`)
  .join('\n')}`;
}

// EXTERNAL MODULE: ./node_modules/.pnpm/commander@13.1.0/node_modules/commander/index.js
var commander = __webpack_require__(8915); // ./node_modules/.pnpm/commander@13.1.0/node_modules/commander/esm.mjs
// wrapper to provide named exports for ESM.
const {
  /* program */ DM: program,
  /* createCommand */ gu: createCommand,
  /* createArgument */ er: createArgument,
  /* createOption */ Ww: createOption,
  /* CommanderError */ b7: CommanderError,
  /* InvalidArgumentError */ Di: InvalidArgumentError,
  /* InvalidOptionArgumentError */ a2: InvalidOptionArgumentError, // deprecated old name
  /* Command */ uB: Command,
  /* Argument */ ef: Argument,
  /* Option */ c$: Option,
  /* Help */ _V: Help,
} = commander; // ./src/server/command/list.ts

function add_list_command() {
  const command = new Command('list').description('列出所有可用的配置');
  command.action(() => {
    console.info(beauingfy_configs());
  });
  return command;
} // ./src/server/component/collection_file.ts

function is_collection_file(file) {
  return ['合集', 'collection'].some(keyword => file.includes(keyword));
}
function parse_collection_file(content) {
  const lines = content.split('\n');
  const entry_anchors = _(lines)
    .map((line, index) => {
      const match = line.match(/^ *\# \^(.*)/);
      if (match) {
        return { name: match[1].trimEnd(), line_number: index };
      }
      return null;
    })
    .filter(value => value !== null)
    .push({ name: undefined, line_number: lines.length })
    .value();
  return _(entry_anchors.slice(0, -1))
    .zip(entry_anchors.slice(1))
    .map(([entry_anchor, next_entry_anchor]) => {
      return {
        name: entry_anchor.name,
        content: lines.slice(entry_anchor.line_number + 1, next_entry_anchor.line_number).join('\n'),
      };
    })
    .value();
} // ./src/server/component/replace_raw_string.ts

function replace_raw_string(text) {
  return text?.replaceAll(/\s*# :(?=.*$)/gm, '');
} // ./src/server/component/replace_user_name.ts

function replace_user_name(text) {
  return text?.replaceAll(get_settings().user_name, '<user>');
}

// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896); // external "fs/promises"
const promises_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('fs/promises');
// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(4434);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928); // external "node:fs/promises"
const external_node_fs_promises_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('node:fs/promises'); // external "node:stream"
const external_node_stream_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('node:stream'); // ./node_modules/.pnpm/readdirp@4.1.2/node_modules/readdirp/esm/index.js
const EntryTypes = {
  FILE_TYPE: 'files',
  DIR_TYPE: 'directories',
  FILE_DIR_TYPE: 'files_directories',
  EVERYTHING_TYPE: 'all',
};
const defaultOptions = {
  root: '.',
  fileFilter: _entryInfo => true,
  directoryFilter: _entryInfo => true,
  type: EntryTypes.FILE_TYPE,
  lstat: false,
  depth: 2147483648,
  alwaysStat: false,
  highWaterMark: 4096,
};
Object.freeze(defaultOptions);
const RECURSIVE_ERROR_CODE = 'READDIRP_RECURSIVE_ERROR';
const NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP', RECURSIVE_ERROR_CODE]);
const ALL_TYPES = [EntryTypes.DIR_TYPE, EntryTypes.EVERYTHING_TYPE, EntryTypes.FILE_DIR_TYPE, EntryTypes.FILE_TYPE];
const DIR_TYPES = new Set([EntryTypes.DIR_TYPE, EntryTypes.EVERYTHING_TYPE, EntryTypes.FILE_DIR_TYPE]);
const FILE_TYPES = new Set([EntryTypes.EVERYTHING_TYPE, EntryTypes.FILE_DIR_TYPE, EntryTypes.FILE_TYPE]);
const isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);
const wantBigintFsStats = process.platform === 'win32';
const emptyFn = _entryInfo => true;
const normalizeFilter = filter => {
  if (filter === undefined) return emptyFn;
  if (typeof filter === 'function') return filter;
  if (typeof filter === 'string') {
    const fl = filter.trim();
    return entry => entry.basename === fl;
  }
  if (Array.isArray(filter)) {
    const trItems = filter.map(item => item.trim());
    return entry => trItems.some(f => entry.basename === f);
  }
  return emptyFn;
};
/** Readable readdir stream, emitting new files as they're being listed. */
class ReaddirpStream extends external_node_stream_namespaceObject.Readable {
  constructor(options = {}) {
    super({
      objectMode: true,
      autoDestroy: true,
      highWaterMark: options.highWaterMark,
    });
    const opts = { ...defaultOptions, ...options };
    const { root, type } = opts;
    this._fileFilter = normalizeFilter(opts.fileFilter);
    this._directoryFilter = normalizeFilter(opts.directoryFilter);
    const statMethod = opts.lstat
      ? external_node_fs_promises_namespaceObject.lstat
      : external_node_fs_promises_namespaceObject.stat;
    // Use bigint stats if it's windows and stat() supports options (node 10+).
    if (wantBigintFsStats) {
      this._stat = path => statMethod(path, { bigint: true });
    } else {
      this._stat = statMethod;
    }
    this._maxDepth = opts.depth ?? defaultOptions.depth;
    this._wantsDir = type ? DIR_TYPES.has(type) : false;
    this._wantsFile = type ? FILE_TYPES.has(type) : false;
    this._wantsEverything = type === EntryTypes.EVERYTHING_TYPE;
    this._root = (0, external_node_path_.resolve)(root);
    this._isDirent = !opts.alwaysStat;
    this._statsProp = this._isDirent ? 'dirent' : 'stats';
    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };
    // Launch stream with one parent, the root dir.
    this.parents = [this._exploreDir(root, 1)];
    this.reading = false;
    this.parent = undefined;
  }
  async _read(batch) {
    if (this.reading) return;
    this.reading = true;
    try {
      while (!this.destroyed && batch > 0) {
        const par = this.parent;
        const fil = par && par.files;
        if (fil && fil.length > 0) {
          const { path, depth } = par;
          const slice = fil.splice(0, batch).map(dirent => this._formatEntry(dirent, path));
          const awaited = await Promise.all(slice);
          for (const entry of awaited) {
            if (!entry) continue;
            if (this.destroyed) return;
            const entryType = await this._getEntryType(entry);
            if (entryType === 'directory' && this._directoryFilter(entry)) {
              if (depth <= this._maxDepth) {
                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
              }
              if (this._wantsDir) {
                this.push(entry);
                batch--;
              }
            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {
              if (this._wantsFile) {
                this.push(entry);
                batch--;
              }
            }
          }
        } else {
          const parent = this.parents.pop();
          if (!parent) {
            this.push(null);
            break;
          }
          this.parent = await parent;
          if (this.destroyed) return;
        }
      }
    } catch (error) {
      this.destroy(error);
    } finally {
      this.reading = false;
    }
  }
  async _exploreDir(path, depth) {
    let files;
    try {
      files = await (0, external_node_fs_promises_namespaceObject.readdir)(path, this._rdOptions);
    } catch (error) {
      this._onError(error);
    }
    return { files, depth, path };
  }
  async _formatEntry(dirent, path) {
    let entry;
    const basename = this._isDirent ? dirent.name : dirent;
    try {
      const fullPath = (0, external_node_path_.resolve)((0, external_node_path_.join)(path, basename));
      entry = { path: (0, external_node_path_.relative)(this._root, fullPath), fullPath, basename };
      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
    } catch (err) {
      this._onError(err);
      return;
    }
    return entry;
  }
  _onError(err) {
    if (isNormalFlowError(err) && !this.destroyed) {
      this.emit('warn', err);
    } else {
      this.destroy(err);
    }
  }
  async _getEntryType(entry) {
    // entry may be undefined, because a warning or an error were emitted
    // and the statsProp is undefined
    if (!entry && this._statsProp in entry) {
      return '';
    }
    const stats = entry[this._statsProp];
    if (stats.isFile()) return 'file';
    if (stats.isDirectory()) return 'directory';
    if (stats && stats.isSymbolicLink()) {
      const full = entry.fullPath;
      try {
        const entryRealPath = await (0, external_node_fs_promises_namespaceObject.realpath)(full);
        const entryRealPathStats = await (0, external_node_fs_promises_namespaceObject.lstat)(entryRealPath);
        if (entryRealPathStats.isFile()) {
          return 'file';
        }
        if (entryRealPathStats.isDirectory()) {
          const len = entryRealPath.length;
          if (full.startsWith(entryRealPath) && full.substr(len, 1) === external_node_path_.sep) {
            const recursiveError = new Error(`Circular symlink detected: "${full}" points to "${entryRealPath}"`);
            // @ts-ignore
            recursiveError.code = RECURSIVE_ERROR_CODE;
            return this._onError(recursiveError);
          }
          return 'directory';
        }
      } catch (error) {
        this._onError(error);
        return '';
      }
    }
  }
  _includeAsFile(entry) {
    const stats = entry && entry[this._statsProp];
    return stats && this._wantsEverything && !stats.isDirectory();
  }
}
/**
 * Streaming version: Reads all files and directories in given root recursively.
 * Consumes ~constant small amount of RAM.
 * @param root Root directory
 * @param options Options to specify root (start directory), filters and recursion depth
 */
function readdirp(root, options = {}) {
  // @ts-ignore
  let type = options.entryType || options.type;
  if (type === 'both') type = EntryTypes.FILE_DIR_TYPE; // backwards-compatibility
  if (type) options.type = type;
  if (!root) {
    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');
  } else if (typeof root !== 'string') {
    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');
  } else if (type && !ALL_TYPES.includes(type)) {
    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);
  }
  options.root = root;
  return new ReaddirpStream(options);
}
/**
 * Promise version: Reads all files and directories in given root recursively.
 * Compared to streaming version, will consume a lot of RAM e.g. when 1 million files are listed.
 * @returns array of paths and their entry infos
 */
function readdirpPromise(root, options = {}) {
  return new Promise((resolve, reject) => {
    const files = [];
    readdirp(root, options)
      .on('data', entry => files.push(entry))
      .on('end', () => resolve(files))
      .on('error', error => reject(error));
  });
}
/* harmony default export */ const esm = /* unused pure expression or super */ null && readdirp;

// EXTERNAL MODULE: external "os"
var external_os_ = __webpack_require__(857); // ./node_modules/.pnpm/chokidar@4.0.3/node_modules/chokidar/esm/handler.js
const STR_DATA = 'data';
const STR_END = 'end';
const STR_CLOSE = 'close';
const EMPTY_FN = () => {};
const IDENTITY_FN = val => val;
const pl = process.platform;
const isWindows = pl === 'win32';
const isMacos = pl === 'darwin';
const isLinux = pl === 'linux';
const isFreeBSD = pl === 'freebsd';
const isIBMi = (0, external_os_.type)() === 'OS400';
const EVENTS = {
  ALL: 'all',
  READY: 'ready',
  ADD: 'add',
  CHANGE: 'change',
  ADD_DIR: 'addDir',
  UNLINK: 'unlink',
  UNLINK_DIR: 'unlinkDir',
  RAW: 'raw',
  ERROR: 'error',
};
const EV = EVENTS;
const THROTTLE_MODE_WATCH = 'watch';
const statMethods = { lstat: promises_namespaceObject.lstat, stat: promises_namespaceObject.stat };
const KEY_LISTENERS = 'listeners';
const KEY_ERR = 'errHandlers';
const KEY_RAW = 'rawEmitters';
const HANDLER_KEYS = [KEY_LISTENERS, KEY_ERR, KEY_RAW];
// prettier-ignore
const binaryExtensions = new Set([
    '3dm', '3ds', '3g2', '3gp', '7z', 'a', 'aac', 'adp', 'afdesign', 'afphoto', 'afpub', 'ai',
    'aif', 'aiff', 'alz', 'ape', 'apk', 'appimage', 'ar', 'arj', 'asf', 'au', 'avi',
    'bak', 'baml', 'bh', 'bin', 'bk', 'bmp', 'btif', 'bz2', 'bzip2',
    'cab', 'caf', 'cgm', 'class', 'cmx', 'cpio', 'cr2', 'cur', 'dat', 'dcm', 'deb', 'dex', 'djvu',
    'dll', 'dmg', 'dng', 'doc', 'docm', 'docx', 'dot', 'dotm', 'dra', 'DS_Store', 'dsk', 'dts',
    'dtshd', 'dvb', 'dwg', 'dxf',
    'ecelp4800', 'ecelp7470', 'ecelp9600', 'egg', 'eol', 'eot', 'epub', 'exe',
    'f4v', 'fbs', 'fh', 'fla', 'flac', 'flatpak', 'fli', 'flv', 'fpx', 'fst', 'fvt',
    'g3', 'gh', 'gif', 'graffle', 'gz', 'gzip',
    'h261', 'h263', 'h264', 'icns', 'ico', 'ief', 'img', 'ipa', 'iso',
    'jar', 'jpeg', 'jpg', 'jpgv', 'jpm', 'jxr', 'key', 'ktx',
    'lha', 'lib', 'lvp', 'lz', 'lzh', 'lzma', 'lzo',
    'm3u', 'm4a', 'm4v', 'mar', 'mdi', 'mht', 'mid', 'midi', 'mj2', 'mka', 'mkv', 'mmr', 'mng',
    'mobi', 'mov', 'movie', 'mp3',
    'mp4', 'mp4a', 'mpeg', 'mpg', 'mpga', 'mxu',
    'nef', 'npx', 'numbers', 'nupkg',
    'o', 'odp', 'ods', 'odt', 'oga', 'ogg', 'ogv', 'otf', 'ott',
    'pages', 'pbm', 'pcx', 'pdb', 'pdf', 'pea', 'pgm', 'pic', 'png', 'pnm', 'pot', 'potm',
    'potx', 'ppa', 'ppam',
    'ppm', 'pps', 'ppsm', 'ppsx', 'ppt', 'pptm', 'pptx', 'psd', 'pya', 'pyc', 'pyo', 'pyv',
    'qt',
    'rar', 'ras', 'raw', 'resources', 'rgb', 'rip', 'rlc', 'rmf', 'rmvb', 'rpm', 'rtf', 'rz',
    's3m', 's7z', 'scpt', 'sgi', 'shar', 'snap', 'sil', 'sketch', 'slk', 'smv', 'snk', 'so',
    'stl', 'suo', 'sub', 'swf',
    'tar', 'tbz', 'tbz2', 'tga', 'tgz', 'thmx', 'tif', 'tiff', 'tlz', 'ttc', 'ttf', 'txz',
    'udf', 'uvh', 'uvi', 'uvm', 'uvp', 'uvs', 'uvu',
    'viv', 'vob',
    'war', 'wav', 'wax', 'wbmp', 'wdp', 'weba', 'webm', 'webp', 'whl', 'wim', 'wm', 'wma',
    'wmv', 'wmx', 'woff', 'woff2', 'wrm', 'wvx',
    'xbm', 'xif', 'xla', 'xlam', 'xls', 'xlsb', 'xlsm', 'xlsx', 'xlt', 'xltm', 'xltx', 'xm',
    'xmind', 'xpi', 'xpm', 'xwd', 'xz',
    'z', 'zip', 'zipx',
]);
const isBinaryPath = filePath => binaryExtensions.has(external_path_.extname(filePath).slice(1).toLowerCase());
// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn) => {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};
const addAndConvert = (main, prop, item) => {
  let container = main[prop];
  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }
  container.add(item);
};
const clearItem = cont => key => {
  const set = cont[key];
  if (set instanceof Set) {
    set.clear();
  } else {
    delete cont[key];
  }
};
const delFromSet = (main, prop, item) => {
  const container = main[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main[prop];
  }
};
const isEmptySet = val => (val instanceof Set ? val.size === 0 : !val);
const FsWatchInstances = new Map();
/**
 * Instantiates the fs_watch interface
 * @param path to be watched
 * @param options to be passed to fs_watch
 * @param listener main event handler
 * @param errHandler emits info about errors
 * @param emitRaw emits raw event data
 * @returns {NativeFsWatcher}
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener(path);
    emitRaw(rawEvent, evPath, { watchedPath: path });
    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(external_path_.resolve(path, evPath), KEY_LISTENERS, external_path_.join(path, evPath));
    }
  };
  try {
    return (0, external_fs_.watch)(
      path,
      {
        persistent: options.persistent,
      },
      handleEvent,
    );
  } catch (error) {
    errHandler(error);
    return undefined;
  }
}
/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param fullPath absolute path bound to fs_watch instance
 */
const fsWatchBroadcast = (fullPath, listenerType, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[listenerType], listener => {
    listener(val1, val2, val3);
  });
};
/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param path
 * @param fullPath absolute path
 * @param options to be passed to fs_watch
 * @param handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) => {
  const { listener, errHandler, rawEmitter } = handlers;
  let cont = FsWatchInstances.get(fullPath);
  let watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);
    if (!watcher) return;
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW),
    );
    if (!watcher) return;
    watcher.on(EV.ERROR, async error => {
      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
      if (cont) cont.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (isWindows && error.code === 'EPERM') {
        try {
          const fd = await (0, promises_namespaceObject.open)(path, 'r');
          await fd.close();
          broadcastErr(error);
        } catch (err) {
          // do nothing
        }
      } else {
        broadcastErr(error);
      }
    });
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher,
    };
    FsWatchInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);
  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close();
      // }
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      // @ts-ignore
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};
// fs_watchFile helpers
// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();
/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param path to be watched
 * @param fullPath absolute path
 * @param options options to be passed to fs_watchFile
 * @param handlers container for event listener functions
 * @returns closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) => {
  const { listener, rawEmitter } = handlers;
  let cont = FsWatchFileInstances.get(fullPath);
  // let listeners = new Set();
  // let rawEmitters = new Set();
  const copts = cont && cont.options;
  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    // listeners = cont.listeners;
    // rawEmitters = cont.rawEmitters;
    (0, external_fs_.unwatchFile)(fullPath);
    cont = undefined;
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options,
      watcher: (0, external_fs_.watchFile)(fullPath, options, (curr, prev) => {
        foreach(cont.rawEmitters, rawEmitter => {
          rawEmitter(EV.CHANGE, fullPath, { curr, prev });
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, listener => listener(path, curr));
        }
      }),
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);
  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      (0, external_fs_.unwatchFile)(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};
/**
 * @mixin
 */
class NodeFsHandler {
  constructor(fsW) {
    this.fsw = fsW;
    this._boundHandleError = error => fsW._handleError(error);
  }
  /**
   * Watch file for changes with fs_watchFile or fs_watch.
   * @param path to file or dir
   * @param listener on fs change
   * @returns closer for the watcher instance
   */
  _watchWithNodeFs(path, listener) {
    const opts = this.fsw.options;
    const directory = external_path_.dirname(path);
    const basename = external_path_.basename(path);
    const parent = this.fsw._getWatchedDir(directory);
    parent.add(basename);
    const absolutePath = external_path_.resolve(path);
    const options = {
      persistent: opts.persistent,
    };
    if (!listener) listener = EMPTY_FN;
    let closer;
    if (opts.usePolling) {
      const enableBin = opts.interval !== opts.binaryInterval;
      options.interval = enableBin && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;
      closer = setFsWatchFileListener(path, absolutePath, options, {
        listener,
        rawEmitter: this.fsw._emitRaw,
      });
    } else {
      closer = setFsWatchListener(path, absolutePath, options, {
        listener,
        errHandler: this._boundHandleError,
        rawEmitter: this.fsw._emitRaw,
      });
    }
    return closer;
  }
  /**
   * Watch a file and emit add event if warranted.
   * @returns closer for the watcher instance
   */
  _handleFile(file, stats, initialAdd) {
    if (this.fsw.closed) {
      return;
    }
    const dirname = external_path_.dirname(file);
    const basename = external_path_.basename(file);
    const parent = this.fsw._getWatchedDir(dirname);
    // stats is always present
    let prevStats = stats;
    // if the file is already being watched, do nothing
    if (parent.has(basename)) return;
    const listener = async (path, newStats) => {
      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
      if (!newStats || newStats.mtimeMs === 0) {
        try {
          const newStats = await (0, promises_namespaceObject.stat)(file);
          if (this.fsw.closed) return;
          // Check that change event was not fired because of changed only accessTime.
          const at = newStats.atimeMs;
          const mt = newStats.mtimeMs;
          if (!at || at <= mt || mt !== prevStats.mtimeMs) {
            this.fsw._emit(EV.CHANGE, file, newStats);
          }
          if ((isMacos || isLinux || isFreeBSD) && prevStats.ino !== newStats.ino) {
            this.fsw._closeFile(path);
            prevStats = newStats;
            const closer = this._watchWithNodeFs(file, listener);
            if (closer) this.fsw._addPathCloser(path, closer);
          } else {
            prevStats = newStats;
          }
        } catch (error) {
          // Fix issues where mtime is null but file is still present
          this.fsw._remove(dirname, basename);
        }
        // add is about to be emitted if file not already tracked in parent
      } else if (parent.has(basename)) {
        // Check that change event was not fired because of changed only accessTime.
        const at = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at || at <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit(EV.CHANGE, file, newStats);
        }
        prevStats = newStats;
      }
    };
    // kick off the watcher
    const closer = this._watchWithNodeFs(file, listener);
    // emit an add event if we're supposed to
    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
      if (!this.fsw._throttle(EV.ADD, file, 0)) return;
      this.fsw._emit(EV.ADD, file, stats);
    }
    return closer;
  }
  /**
   * Handle symlinks encountered while reading a dir.
   * @param entry returned by readdirp
   * @param directory path of dir being read
   * @param path of this item
   * @param item basename of this item
   * @returns true if no more processing is needed for this entry.
   */
  async _handleSymlink(entry, directory, path, item) {
    if (this.fsw.closed) {
      return;
    }
    const full = entry.fullPath;
    const dir = this.fsw._getWatchedDir(directory);
    if (!this.fsw.options.followSymlinks) {
      // watch symlink directly (don't follow) and detect changes
      this.fsw._incrReadyCount();
      let linkPath;
      try {
        linkPath = await (0, promises_namespaceObject.realpath)(path);
      } catch (e) {
        this.fsw._emitReady();
        return true;
      }
      if (this.fsw.closed) return;
      if (dir.has(item)) {
        if (this.fsw._symlinkPaths.get(full) !== linkPath) {
          this.fsw._symlinkPaths.set(full, linkPath);
          this.fsw._emit(EV.CHANGE, path, entry.stats);
        }
      } else {
        dir.add(item);
        this.fsw._symlinkPaths.set(full, linkPath);
        this.fsw._emit(EV.ADD, path, entry.stats);
      }
      this.fsw._emitReady();
      return true;
    }
    // don't follow the same symlink more than once
    if (this.fsw._symlinkPaths.has(full)) {
      return true;
    }
    this.fsw._symlinkPaths.set(full, true);
  }
  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
    // Normalize the directory name on Windows
    directory = external_path_.join(directory, '');
    throttler = this.fsw._throttle('readdir', directory, 1000);
    if (!throttler) return;
    const previous = this.fsw._getWatchedDir(wh.path);
    const current = new Set();
    let stream = this.fsw._readdirp(directory, {
      fileFilter: entry => wh.filterPath(entry),
      directoryFilter: entry => wh.filterDir(entry),
    });
    if (!stream) return;
    stream
      .on(STR_DATA, async entry => {
        if (this.fsw.closed) {
          stream = undefined;
          return;
        }
        const item = entry.path;
        let path = external_path_.join(directory, item);
        current.add(item);
        if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {
          return;
        }
        if (this.fsw.closed) {
          stream = undefined;
          return;
        }
        // Files that present in current directory snapshot
        // but absent in previous are added to watch list and
        // emit `add` event.
        if (item === target || (!target && !previous.has(item))) {
          this.fsw._incrReadyCount();
          // ensure relativeness of path is preserved in case of watcher reuse
          path = external_path_.join(dir, external_path_.relative(dir, path));
          this._addToNodeFs(path, initialAdd, wh, depth + 1);
        }
      })
      .on(EV.ERROR, this._boundHandleError);
    return new Promise((resolve, reject) => {
      if (!stream) return reject();
      stream.once(STR_END, () => {
        if (this.fsw.closed) {
          stream = undefined;
          return;
        }
        const wasThrottled = throttler ? throttler.clear() : false;
        resolve(undefined);
        // Files that absent in current directory snapshot
        // but present in previous emit `remove` event
        // and are removed from @watched[directory].
        previous
          .getChildren()
          .filter(item => {
            return item !== directory && !current.has(item);
          })
          .forEach(item => {
            this.fsw._remove(directory, item);
          });
        stream = undefined;
        // one more time for any missed in case changes came in extremely quickly
        if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
      });
    });
  }
  /**
   * Read directory to add / remove files from `@watched` list and re-read it on change.
   * @param dir fs path
   * @param stats
   * @param initialAdd
   * @param depth relative to user-supplied path
   * @param target child path targeted for watch
   * @param wh Common watch helpers for this path
   * @param realpath
   * @returns closer for the watcher instance.
   */
  async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {
    const parentDir = this.fsw._getWatchedDir(external_path_.dirname(dir));
    const tracked = parentDir.has(external_path_.basename(dir));
    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
      this.fsw._emit(EV.ADD_DIR, dir, stats);
    }
    // ensure dir is tracked (harmless if redundant)
    parentDir.add(external_path_.basename(dir));
    this.fsw._getWatchedDir(dir);
    let throttler;
    let closer;
    const oDepth = this.fsw.options.depth;
    if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {
      if (!target) {
        await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
        if (this.fsw.closed) return;
      }
      closer = this._watchWithNodeFs(dir, (dirPath, stats) => {
        // if current directory is removed, do nothing
        if (stats && stats.mtimeMs === 0) return;
        this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
      });
    }
    return closer;
  }
  /**
   * Handle added file, directory, or glob pattern.
   * Delegates call to _handleFile / _handleDir after checks.
   * @param path to file or ir
   * @param initialAdd was the file added at watch instantiation?
   * @param priorWh depth relative to user-supplied path
   * @param depth Child path actually targeted for watch
   * @param target Child path actually targeted for watch
   */
  async _addToNodeFs(path, initialAdd, priorWh, depth, target) {
    const ready = this.fsw._emitReady;
    if (this.fsw._isIgnored(path) || this.fsw.closed) {
      ready();
      return false;
    }
    const wh = this.fsw._getWatchHelpers(path);
    if (priorWh) {
      wh.filterPath = entry => priorWh.filterPath(entry);
      wh.filterDir = entry => priorWh.filterDir(entry);
    }
    // evaluate what is at the path we're being asked to watch
    try {
      const stats = await statMethods[wh.statMethod](wh.watchPath);
      if (this.fsw.closed) return;
      if (this.fsw._isIgnored(wh.watchPath, stats)) {
        ready();
        return false;
      }
      const follow = this.fsw.options.followSymlinks;
      let closer;
      if (stats.isDirectory()) {
        const absPath = external_path_.resolve(path);
        const targetPath = follow ? await (0, promises_namespaceObject.realpath)(path) : path;
        if (this.fsw.closed) return;
        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
        if (this.fsw.closed) return;
        // preserve this symlink's target path
        if (absPath !== targetPath && targetPath !== undefined) {
          this.fsw._symlinkPaths.set(absPath, targetPath);
        }
      } else if (stats.isSymbolicLink()) {
        const targetPath = follow ? await (0, promises_namespaceObject.realpath)(path) : path;
        if (this.fsw.closed) return;
        const parent = external_path_.dirname(wh.watchPath);
        this.fsw._getWatchedDir(parent).add(wh.watchPath);
        this.fsw._emit(EV.ADD, wh.watchPath, stats);
        closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);
        if (this.fsw.closed) return;
        // preserve this symlink's target path
        if (targetPath !== undefined) {
          this.fsw._symlinkPaths.set(external_path_.resolve(path), targetPath);
        }
      } else {
        closer = this._handleFile(wh.watchPath, stats, initialAdd);
      }
      ready();
      if (closer) this.fsw._addPathCloser(path, closer);
      return false;
    } catch (error) {
      if (this.fsw._handleError(error)) {
        ready();
        return path;
      }
    }
  }
} // ./node_modules/.pnpm/chokidar@4.0.3/node_modules/chokidar/esm/index.js

/*! chokidar - MIT License (c) 2012 Paul Miller (paulmillr.com) */

const SLASH = '/';
const SLASH_SLASH = '//';
const ONE_DOT = '.';
const TWO_DOTS = '..';
const STRING_TYPE = 'string';
const BACK_SLASH_RE = /\\/g;
const DOUBLE_SLASH_RE = /\/\//;
const DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
const REPLACER_RE = /^\.[/\\]/;
function arrify(item) {
  return Array.isArray(item) ? item : [item];
}
const isMatcherObject = matcher => typeof matcher === 'object' && matcher !== null && !(matcher instanceof RegExp);
function createPattern(matcher) {
  if (typeof matcher === 'function') return matcher;
  if (typeof matcher === 'string') return string => matcher === string;
  if (matcher instanceof RegExp) return string => matcher.test(string);
  if (typeof matcher === 'object' && matcher !== null) {
    return string => {
      if (matcher.path === string) return true;
      if (matcher.recursive) {
        const relative = external_path_.relative(matcher.path, string);
        if (!relative) {
          return false;
        }
        return !relative.startsWith('..') && !external_path_.isAbsolute(relative);
      }
      return false;
    };
  }
  return () => false;
}
function normalizePath(path) {
  if (typeof path !== 'string') throw new Error('string expected');
  path = external_path_.normalize(path);
  path = path.replace(/\\/g, '/');
  let prepend = false;
  if (path.startsWith('//')) prepend = true;
  const DOUBLE_SLASH_RE = /\/\//;
  while (path.match(DOUBLE_SLASH_RE)) path = path.replace(DOUBLE_SLASH_RE, '/');
  if (prepend) path = '/' + path;
  return path;
}
function matchPatterns(patterns, testString, stats) {
  const path = normalizePath(testString);
  for (let index = 0; index < patterns.length; index++) {
    const pattern = patterns[index];
    if (pattern(path, stats)) {
      return true;
    }
  }
  return false;
}
function anymatch(matchers, testString) {
  if (matchers == null) {
    throw new TypeError('anymatch: specify first argument');
  }
  // Early cache for matchers.
  const matchersArray = arrify(matchers);
  const patterns = matchersArray.map(matcher => createPattern(matcher));
  if (testString == null) {
    return (testString, stats) => {
      return matchPatterns(patterns, testString, stats);
    };
  }
  return matchPatterns(patterns, testString);
}
const unifyPaths = paths_ => {
  const paths = arrify(paths_).flat();
  if (!paths.every(p => typeof p === STRING_TYPE)) {
    throw new TypeError(`Non-string provided as watch path: ${paths}`);
  }
  return paths.map(normalizePathToUnix);
};
// If SLASH_SLASH occurs at the beginning of path, it is not replaced
//     because "//StoragePC/DrivePool/Movies" is a valid network path
const toUnix = string => {
  let str = string.replace(BACK_SLASH_RE, SLASH);
  let prepend = false;
  if (str.startsWith(SLASH_SLASH)) {
    prepend = true;
  }
  while (str.match(DOUBLE_SLASH_RE)) {
    str = str.replace(DOUBLE_SLASH_RE, SLASH);
  }
  if (prepend) {
    str = SLASH + str;
  }
  return str;
};
// Our version of upath.normalize
// TODO: this is not equal to path-normalize module - investigate why
const normalizePathToUnix = path => toUnix(external_path_.normalize(toUnix(path)));
// TODO: refactor
const normalizeIgnored =
  (cwd = '') =>
  path => {
    if (typeof path === 'string') {
      return normalizePathToUnix(external_path_.isAbsolute(path) ? path : external_path_.join(cwd, path));
    } else {
      return path;
    }
  };
const getAbsolutePath = (path, cwd) => {
  if (external_path_.isAbsolute(path)) {
    return path;
  }
  return external_path_.join(cwd, path);
};
const EMPTY_SET = Object.freeze(new Set());
/**
 * Directory entry.
 */
class DirEntry {
  constructor(dir, removeWatcher) {
    this.path = dir;
    this._removeWatcher = removeWatcher;
    this.items = new Set();
  }
  add(item) {
    const { items } = this;
    if (!items) return;
    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
  }
  async remove(item) {
    const { items } = this;
    if (!items) return;
    items.delete(item);
    if (items.size > 0) return;
    const dir = this.path;
    try {
      await (0, promises_namespaceObject.readdir)(dir);
    } catch (err) {
      if (this._removeWatcher) {
        this._removeWatcher(external_path_.dirname(dir), external_path_.basename(dir));
      }
    }
  }
  has(item) {
    const { items } = this;
    if (!items) return;
    return items.has(item);
  }
  getChildren() {
    const { items } = this;
    if (!items) return [];
    return [...items.values()];
  }
  dispose() {
    this.items.clear();
    this.path = '';
    this._removeWatcher = EMPTY_FN;
    this.items = EMPTY_SET;
    Object.freeze(this);
  }
}
const STAT_METHOD_F = 'stat';
const STAT_METHOD_L = 'lstat';
class WatchHelper {
  constructor(path, follow, fsw) {
    this.fsw = fsw;
    const watchPath = path;
    this.path = path = path.replace(REPLACER_RE, '');
    this.watchPath = watchPath;
    this.fullWatchPath = external_path_.resolve(watchPath);
    this.dirParts = [];
    this.dirParts.forEach(parts => {
      if (parts.length > 1) parts.pop();
    });
    this.followSymlinks = follow;
    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
  }
  entryPath(entry) {
    return external_path_.join(this.watchPath, external_path_.relative(this.watchPath, entry.fullPath));
  }
  filterPath(entry) {
    const { stats } = entry;
    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);
    const resolvedPath = this.entryPath(entry);
    // TODO: what if stats is undefined? remove !
    return this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
  }
  filterDir(entry) {
    return this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
  }
}
/**
 * Watches files & directories for changes. Emitted events:
 * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`
 *
 *     new FSWatcher()
 *       .add(directories)
 *       .on('add', path => log('File', path, 'was added'))
 */
class FSWatcher extends external_events_.EventEmitter {
  // Not indenting methods for history sake; for now.
  constructor(_opts = {}) {
    super();
    this.closed = false;
    this._closers = new Map();
    this._ignoredPaths = new Set();
    this._throttled = new Map();
    this._streams = new Set();
    this._symlinkPaths = new Map();
    this._watched = new Map();
    this._pendingWrites = new Map();
    this._pendingUnlinks = new Map();
    this._readyCount = 0;
    this._readyEmitted = false;
    const awf = _opts.awaitWriteFinish;
    const DEF_AWF = { stabilityThreshold: 2000, pollInterval: 100 };
    const opts = {
      // Defaults
      persistent: true,
      ignoreInitial: false,
      ignorePermissionErrors: false,
      interval: 100,
      binaryInterval: 300,
      followSymlinks: true,
      usePolling: false,
      // useAsync: false,
      atomic: true, // NOTE: overwritten later (depends on usePolling)
      ..._opts,
      // Change format
      ignored: _opts.ignored ? arrify(_opts.ignored) : arrify([]),
      awaitWriteFinish: awf === true ? DEF_AWF : typeof awf === 'object' ? { ...DEF_AWF, ...awf } : false,
    };
    // Always default to polling on IBM i because fs.watch() is not available on IBM i.
    if (isIBMi) opts.usePolling = true;
    // Editor atomic write normalization enabled by default with fs.watch
    if (opts.atomic === undefined) opts.atomic = !opts.usePolling;
    // opts.atomic = typeof _opts.atomic === 'number' ? _opts.atomic : 100;
    // Global override. Useful for developers, who need to force polling for all
    // instances of chokidar, regardless of usage / dependency depth
    const envPoll = process.env.CHOKIDAR_USEPOLLING;
    if (envPoll !== undefined) {
      const envLower = envPoll.toLowerCase();
      if (envLower === 'false' || envLower === '0') opts.usePolling = false;
      else if (envLower === 'true' || envLower === '1') opts.usePolling = true;
      else opts.usePolling = !!envLower;
    }
    const envInterval = process.env.CHOKIDAR_INTERVAL;
    if (envInterval) opts.interval = Number.parseInt(envInterval, 10);
    // This is done to emit ready only once, but each 'add' will increase that?
    let readyCalls = 0;
    this._emitReady = () => {
      readyCalls++;
      if (readyCalls >= this._readyCount) {
        this._emitReady = EMPTY_FN;
        this._readyEmitted = true;
        // use process.nextTick to allow time for listener to be bound
        process.nextTick(() => this.emit(EVENTS.READY));
      }
    };
    this._emitRaw = (...args) => this.emit(EVENTS.RAW, ...args);
    this._boundRemove = this._remove.bind(this);
    this.options = opts;
    this._nodeFsHandler = new NodeFsHandler(this);
    // You’re frozen when your heart’s not open.
    Object.freeze(opts);
  }
  _addIgnoredPath(matcher) {
    if (isMatcherObject(matcher)) {
      // return early if we already have a deeply equal matcher object
      for (const ignored of this._ignoredPaths) {
        if (isMatcherObject(ignored) && ignored.path === matcher.path && ignored.recursive === matcher.recursive) {
          return;
        }
      }
    }
    this._ignoredPaths.add(matcher);
  }
  _removeIgnoredPath(matcher) {
    this._ignoredPaths.delete(matcher);
    // now find any matcher objects with the matcher as path
    if (typeof matcher === 'string') {
      for (const ignored of this._ignoredPaths) {
        // TODO (43081j): make this more efficient.
        // probably just make a `this._ignoredDirectories` or some
        // such thing.
        if (isMatcherObject(ignored) && ignored.path === matcher) {
          this._ignoredPaths.delete(ignored);
        }
      }
    }
  }
  // Public methods
  /**
   * Adds paths to be watched on an existing FSWatcher instance.
   * @param paths_ file or file list. Other arguments are unused
   */
  add(paths_, _origAdd, _internal) {
    const { cwd } = this.options;
    this.closed = false;
    this._closePromise = undefined;
    let paths = unifyPaths(paths_);
    if (cwd) {
      paths = paths.map(path => {
        const absPath = getAbsolutePath(path, cwd);
        // Check `path` instead of `absPath` because the cwd portion can't be a glob
        return absPath;
      });
    }
    paths.forEach(path => {
      this._removeIgnoredPath(path);
    });
    this._userIgnored = undefined;
    if (!this._readyCount) this._readyCount = 0;
    this._readyCount += paths.length;
    Promise.all(
      paths.map(async path => {
        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, undefined, 0, _origAdd);
        if (res) this._emitReady();
        return res;
      }),
    ).then(results => {
      if (this.closed) return;
      results.forEach(item => {
        if (item) this.add(external_path_.dirname(item), external_path_.basename(_origAdd || item));
      });
    });
    return this;
  }
  /**
   * Close watchers or start ignoring events from specified paths.
   */
  unwatch(paths_) {
    if (this.closed) return this;
    const paths = unifyPaths(paths_);
    const { cwd } = this.options;
    paths.forEach(path => {
      // convert to absolute path unless relative path already matches
      if (!external_path_.isAbsolute(path) && !this._closers.has(path)) {
        if (cwd) path = external_path_.join(cwd, path);
        path = external_path_.resolve(path);
      }
      this._closePath(path);
      this._addIgnoredPath(path);
      if (this._watched.has(path)) {
        this._addIgnoredPath({
          path,
          recursive: true,
        });
      }
      // reset the cached userIgnored anymatch fn
      // to make ignoredPaths changes effective
      this._userIgnored = undefined;
    });
    return this;
  }
  /**
   * Close watchers and remove all listeners from watched paths.
   */
  close() {
    if (this._closePromise) {
      return this._closePromise;
    }
    this.closed = true;
    // Memory management.
    this.removeAllListeners();
    const closers = [];
    this._closers.forEach(closerList =>
      closerList.forEach(closer => {
        const promise = closer();
        if (promise instanceof Promise) closers.push(promise);
      }),
    );
    this._streams.forEach(stream => stream.destroy());
    this._userIgnored = undefined;
    this._readyCount = 0;
    this._readyEmitted = false;
    this._watched.forEach(dirent => dirent.dispose());
    this._closers.clear();
    this._watched.clear();
    this._streams.clear();
    this._symlinkPaths.clear();
    this._throttled.clear();
    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();
    return this._closePromise;
  }
  /**
   * Expose list of watched paths
   * @returns for chaining
   */
  getWatched() {
    const watchList = {};
    this._watched.forEach((entry, dir) => {
      const key = this.options.cwd ? external_path_.relative(this.options.cwd, dir) : dir;
      const index = key || ONE_DOT;
      watchList[index] = entry.getChildren().sort();
    });
    return watchList;
  }
  emitWithAll(event, args) {
    this.emit(event, ...args);
    if (event !== EVENTS.ERROR) this.emit(EVENTS.ALL, event, ...args);
  }
  // Common helpers
  // --------------
  /**
   * Normalize and emit events.
   * Calling _emit DOES NOT MEAN emit() would be called!
   * @param event Type of event
   * @param path File or directory path
   * @param stats arguments to be passed with event
   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
   */
  async _emit(event, path, stats) {
    if (this.closed) return;
    const opts = this.options;
    if (isWindows) path = external_path_.normalize(path);
    if (opts.cwd) path = external_path_.relative(opts.cwd, path);
    const args = [path];
    if (stats != null) args.push(stats);
    const awf = opts.awaitWriteFinish;
    let pw;
    if (awf && (pw = this._pendingWrites.get(path))) {
      pw.lastChange = new Date();
      return this;
    }
    if (opts.atomic) {
      if (event === EVENTS.UNLINK) {
        this._pendingUnlinks.set(path, [event, ...args]);
        setTimeout(
          () => {
            this._pendingUnlinks.forEach((entry, path) => {
              this.emit(...entry);
              this.emit(EVENTS.ALL, ...entry);
              this._pendingUnlinks.delete(path);
            });
          },
          typeof opts.atomic === 'number' ? opts.atomic : 100,
        );
        return this;
      }
      if (event === EVENTS.ADD && this._pendingUnlinks.has(path)) {
        event = EVENTS.CHANGE;
        this._pendingUnlinks.delete(path);
      }
    }
    if (awf && (event === EVENTS.ADD || event === EVENTS.CHANGE) && this._readyEmitted) {
      const awfEmit = (err, stats) => {
        if (err) {
          event = EVENTS.ERROR;
          args[0] = err;
          this.emitWithAll(event, args);
        } else if (stats) {
          // if stats doesn't exist the file must have been deleted
          if (args.length > 1) {
            args[1] = stats;
          } else {
            args.push(stats);
          }
          this.emitWithAll(event, args);
        }
      };
      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);
      return this;
    }
    if (event === EVENTS.CHANGE) {
      const isThrottled = !this._throttle(EVENTS.CHANGE, path, 50);
      if (isThrottled) return this;
    }
    if (
      opts.alwaysStat &&
      stats === undefined &&
      (event === EVENTS.ADD || event === EVENTS.ADD_DIR || event === EVENTS.CHANGE)
    ) {
      const fullPath = opts.cwd ? external_path_.join(opts.cwd, path) : path;
      let stats;
      try {
        stats = await (0, promises_namespaceObject.stat)(fullPath);
      } catch (err) {
        // do nothing
      }
      // Suppress event when fs_stat fails, to avoid sending undefined 'stat'
      if (!stats || this.closed) return;
      args.push(stats);
    }
    this.emitWithAll(event, args);
    return this;
  }
  /**
   * Common handler for errors
   * @returns The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
   */
  _handleError(error) {
    const code = error && error.code;
    if (
      error &&
      code !== 'ENOENT' &&
      code !== 'ENOTDIR' &&
      (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))
    ) {
      this.emit(EVENTS.ERROR, error);
    }
    return error || this.closed;
  }
  /**
   * Helper utility for throttling
   * @param actionType type being throttled
   * @param path being acted upon
   * @param timeout duration of time to suppress duplicate actions
   * @returns tracking object or false if action should be suppressed
   */
  _throttle(actionType, path, timeout) {
    if (!this._throttled.has(actionType)) {
      this._throttled.set(actionType, new Map());
    }
    const action = this._throttled.get(actionType);
    if (!action) throw new Error('invalid throttle');
    const actionPath = action.get(path);
    if (actionPath) {
      actionPath.count++;
      return false;
    }

    let timeoutObject;
    const clear = () => {
      const item = action.get(path);
      const count = item ? item.count : 0;
      action.delete(path);
      clearTimeout(timeoutObject);
      if (item) clearTimeout(item.timeoutObject);
      return count;
    };
    timeoutObject = setTimeout(clear, timeout);
    const thr = { timeoutObject, clear, count: 0 };
    action.set(path, thr);
    return thr;
  }
  _incrReadyCount() {
    return this._readyCount++;
  }
  /**
   * Awaits write operation to finish.
   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
   * @param path being acted upon
   * @param threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
   * @param event
   * @param awfEmit Callback to be called when ready for event to be emitted.
   */
  _awaitWriteFinish(path, threshold, event, awfEmit) {
    const awf = this.options.awaitWriteFinish;
    if (typeof awf !== 'object') return;
    const pollInterval = awf.pollInterval;
    let timeoutHandler;
    let fullPath = path;
    if (this.options.cwd && !external_path_.isAbsolute(path)) {
      fullPath = external_path_.join(this.options.cwd, path);
    }
    const now = new Date();
    const writes = this._pendingWrites;
    function awaitWriteFinishFn(prevStat) {
      (0, external_fs_.stat)(fullPath, (err, curStat) => {
        if (err || !writes.has(path)) {
          if (err && err.code !== 'ENOENT') awfEmit(err);
          return;
        }
        const now = Number(new Date());
        if (prevStat && curStat.size !== prevStat.size) {
          writes.get(path).lastChange = now;
        }
        const pw = writes.get(path);
        const df = now - pw.lastChange;
        if (df >= threshold) {
          writes.delete(path);
          awfEmit(undefined, curStat);
        } else {
          timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval, curStat);
        }
      });
    }
    if (!writes.has(path)) {
      writes.set(path, {
        lastChange: now,
        cancelWait: () => {
          writes.delete(path);
          clearTimeout(timeoutHandler);
          return event;
        },
      });
      timeoutHandler = setTimeout(awaitWriteFinishFn, pollInterval);
    }
  }
  /**
   * Determines whether user has asked to ignore this path.
   */
  _isIgnored(path, stats) {
    if (this.options.atomic && DOT_RE.test(path)) return true;
    if (!this._userIgnored) {
      const { cwd } = this.options;
      const ign = this.options.ignored;
      const ignored = (ign || []).map(normalizeIgnored(cwd));
      const ignoredPaths = [...this._ignoredPaths];
      const list = [...ignoredPaths.map(normalizeIgnored(cwd)), ...ignored];
      this._userIgnored = anymatch(list, undefined);
    }
    return this._userIgnored(path, stats);
  }
  _isntIgnored(path, stat) {
    return !this._isIgnored(path, stat);
  }
  /**
   * Provides a set of common helpers and properties relating to symlink handling.
   * @param path file or directory pattern being watched
   */
  _getWatchHelpers(path) {
    return new WatchHelper(path, this.options.followSymlinks, this);
  }
  // Directory helpers
  // -----------------
  /**
   * Provides directory tracking objects
   * @param directory path of the directory
   */
  _getWatchedDir(directory) {
    const dir = external_path_.resolve(directory);
    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
    return this._watched.get(dir);
  }
  // File helpers
  // ------------
  /**
   * Check for read permissions: https://stackoverflow.com/a/11781404/1358405
   */
  _hasReadPermissions(stats) {
    if (this.options.ignorePermissionErrors) return true;
    return Boolean(Number(stats.mode) & 0o400);
  }
  /**
   * Handles emitting unlink events for
   * files and directories, and via recursion, for
   * files and directories within directories that are unlinked
   * @param directory within which the following item is located
   * @param item      base path of item/directory
   */
  _remove(directory, item, isDirectory) {
    // if what is being deleted is a directory, get that directory's paths
    // for recursive deleting and cleaning of watched object
    // if it is not a directory, nestedDirectoryChildren will be empty array
    const path = external_path_.join(directory, item);
    const fullPath = external_path_.resolve(path);
    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath);
    // prevent duplicate handling in case of arriving here nearly simultaneously
    // via multiple paths (such as _handleFile and _handleDir)
    if (!this._throttle('remove', path, 100)) return;
    // if the only watched file is removed, watch for its return
    if (!isDirectory && this._watched.size === 1) {
      this.add(directory, item, true);
    }
    // This will create a new entry in the watched object in either case
    // so we got to do the directory check beforehand
    const wp = this._getWatchedDir(path);
    const nestedDirectoryChildren = wp.getChildren();
    // Recursively remove children directories / files.
    nestedDirectoryChildren.forEach(nested => this._remove(path, nested));
    // Check if item was on the watched list and remove it
    const parent = this._getWatchedDir(directory);
    const wasTracked = parent.has(item);
    parent.remove(item);
    // Fixes issue #1042 -> Relative paths were detected and added as symlinks
    // (https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L612),
    // but never removed from the map in case the path was deleted.
    // This leads to an incorrect state if the path was recreated:
    // https://github.com/paulmillr/chokidar/blob/e1753ddbc9571bdc33b4a4af172d52cb6e611c10/lib/nodefs-handler.js#L553
    if (this._symlinkPaths.has(fullPath)) {
      this._symlinkPaths.delete(fullPath);
    }
    // If we wait for this file to be fully written, cancel the wait.
    let relPath = path;
    if (this.options.cwd) relPath = external_path_.relative(this.options.cwd, path);
    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
      const event = this._pendingWrites.get(relPath).cancelWait();
      if (event === EVENTS.ADD) return;
    }
    // The Entry will either be a directory that just got removed
    // or a bogus entry to a file, in either case we have to remove it
    this._watched.delete(path);
    this._watched.delete(fullPath);
    const eventName = isDirectory ? EVENTS.UNLINK_DIR : EVENTS.UNLINK;
    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path);
    // Avoid conflicts if we later create another file with the same name
    this._closePath(path);
  }
  /**
   * Closes all watchers for a path
   */
  _closePath(path) {
    this._closeFile(path);
    const dir = external_path_.dirname(path);
    this._getWatchedDir(dir).remove(external_path_.basename(path));
  }
  /**
   * Closes only file-specific watchers
   */
  _closeFile(path) {
    const closers = this._closers.get(path);
    if (!closers) return;
    closers.forEach(closer => closer());
    this._closers.delete(path);
  }
  _addPathCloser(path, closer) {
    if (!closer) return;
    let list = this._closers.get(path);
    if (!list) {
      list = [];
      this._closers.set(path, list);
    }
    list.push(closer);
  }
  _readdirp(root, opts) {
    if (this.closed) return;
    const options = { type: EVENTS.ALL, alwaysStat: true, lstat: true, ...opts, depth: 0 };
    let stream = readdirp(root, options);
    this._streams.add(stream);
    stream.once(STR_CLOSE, () => {
      stream = undefined;
    });
    stream.once(STR_END, () => {
      if (stream) {
        this._streams.delete(stream);
        stream = undefined;
      }
    });
    return stream;
  }
}
/**
 * Instantiates watcher with paths to be tracked.
 * @param paths file / directory paths
 * @param options opts, such as `atomic`, `awaitWriteFinish`, `ignored`, and others
 * @returns an instance of FSWatcher for chaining.
 * @example
 * const watcher = watch('.').on('all', (event, path) => { console.log(event, path); });
 * watch('.', { atomic: true, awaitWriteFinish: true, ignored: (f, stats) => stats?.isFile() && !f.endsWith('.js') })
 */
function watch(paths, options = {}) {
  const watcher = new FSWatcher(options);
  watcher.add(paths);
  return watcher;
}
/* harmony default export */ const chokidar_esm = { watch, FSWatcher }; // ./src/server/component/watch_on.ts

function watch_on(path) {
  return chokidar_esm.watch(path, {
    awaitWriteFinish: true,
    ignoreInitial: true,
    alwaysStat: true,
    ignored: ['.DS_Store'],
  });
} // external "node:http"

const external_node_http_namespaceObject = __WEBPACK_EXTERNAL_createRequire(import.meta.url)('node:http');
// EXTERNAL MODULE: ./node_modules/.pnpm/socket.io@4.8.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/socket.io/dist/index.js
var socket_io_dist = __webpack_require__(5263); // ./node_modules/.pnpm/socket.io@4.8.1_bufferutil@4.0.9_utf-8-validate@6.0.5/node_modules/socket.io/wrapper.mjs
const { Server, Namespace, Socket } = socket_io_dist; // ./src/server/server.ts

const port = 6620;
let io = null;
async function wait_socket() {
  if (!io) {
    const server = (0, external_node_http_namespaceObject.createServer)();
    server.listen(port, () => {
      console.info(
        `酒馆同步脚本服务器正运行在端口: ${port}, 请打开酒馆网页, 等待脚本连接... (如果等待时间超过 10 秒, 请刷新酒馆网页或检查酒馆助手脚本库里的脚本是否开启)`,
      );
    });
    io = new Server(server, {
      maxHttpBufferSize: 1e11,
      cors: {
        origin: '*',
      },
    });
    io.on('connect', socket => {
      console.info(`服务器成功连接到酒馆网页 '${socket.id}'`);
      socket.on('disconnect', reason => {
        console.info(`服务器与酒馆网页 '${socket.id}' 断开连接: ${reason}`);
      });
    });
  }
  if (io.sockets.sockets.size > 0) {
    if (io.sockets.sockets.size > 1) {
      console.warn('目前连接到了多个酒馆网页, 为了保证数据同步, 请只打开、连接一个酒馆页面');
    }
    return io.sockets.sockets.values().next().value;
  }
  return new Promise(resolve => {
    io.once('connect', socket => {
      if (io.sockets.sockets.size > 1) {
        console.warn('目前连接到了多个酒馆网页, 为了保证数据同步, 请只打开、连接一个酒馆页面');
      }
      resolve(socket);
    });
  });
}
async function close_server() {
  await io?.close();
  (0, external_node_process_.exit)(0);
} // ./src/server/util/exit_on_error.ts

function exit_on_error(error) {
  if (error instanceof Error) {
    console.error(error.message);
  } else {
    console.error(error);
  }
  (0, external_node_process_.exit)(1);
} // ./src/server/syncer/interface.ts

var interface_dirname = __webpack_fileURLToPath__(import.meta.url + '/..').slice(0, -1);

class Syncer_interface {
  type;
  type_zh;
  config_name;
  name;
  file;
  dir;
  en_type;
  zh_type;
  zh_to_en_map;
  is_zh;
  tavern_type;
  constructor(type, type_zh, config_name, name, file, en_type, zh_type, zh_to_en_map, is_zh, tavern_type) {
    this.type = type;
    this.type_zh = type_zh;
    this.config_name = config_name;
    this.name = name;
    this.file = (0, external_node_path_.resolve)(interface_dirname, file);
    this.dir = (0, external_node_path_.dirname)(this.file);
    this.en_type = en_type;
    this.zh_type = zh_type;
    this.zh_to_en_map = zh_to_en_map;
    this.is_zh = is_zh;
    this.tavern_type = tavern_type;
  }
  async get_parsed_tavern() {
    const socket = await wait_socket();
    const data = await socket.emitWithAck(`pull_${this.type}`, { name: this.name });
    return typeof data === 'string' ? data : this.tavern_type.parse(data);
  }
  async get_parsed_local() {
    if (!(0, external_node_fs_.existsSync)(this.file)) {
      return `配置文件 '${this.file}' 不存在`;
    }
    const content = (0, external_node_fs_.readFileSync)(this.file, 'utf-8');
    if (!/\S/.test(content)) {
      return `配置文件 '${this.file}' 为空`;
    }
    const data = dist.parse(content, { merge: true });
    return this.is_zh(data) ? translate(this.zh_type.parse(data), this.zh_to_en_map) : this.en_type.parse(data);
  }
  check_safe(local_data, tavern_data) {
    const { local_only_data, tavern_only_data } = this.do_check_safe(local_data, tavern_data);
    let error_data = lodash_default()({});
    if (local_only_data.length > 0) {
      error_data = error_data.set([`本地文件 '${this.file}' 中存在以下条目, 但酒馆中不存在`], local_only_data);
    }
    if (tavern_only_data.length > 0) {
      error_data = error_data.set([`酒馆中存在以下条目, 但本地文件 '${this.file}' 中不存在`], tavern_only_data);
    }
    return { local_only_data, tavern_only_data, error_data: error_data.value() };
  }
  beautify_config(tavern_data, language) {
    return `# yaml-language-server: $schema=https://testingcf.jsdelivr.net/gh/StageDog/tavern_sync/dist/schema/${this.type}.${language}.json
${this.do_beautify_config(tavern_data, language)}`;
  }
  async pull({ language, should_force, should_split }) {
    const tavern_data = await this.get_parsed_tavern();
    if (typeof tavern_data === 'string') {
      exit_on_error(`拉取${this.type_zh} '${this.name}' 失败: ${tavern_data}`);
    }
    const local_data = await this.get_parsed_local();
    if (typeof local_data !== 'string' && !should_force) {
      const { error_data } = this.check_safe(local_data, tavern_data);
      if (!lodash_default().isEmpty(error_data)) {
        exit_on_error(
          dist.stringify({ [`拉取${this.type_zh} '${this.name}' 失败`]: error_data }) +
            `如果想无视条目差异, 请在命令尾部添加 '-f' 或 '--force' 选项, 如: 'node tavern_sync.js pull 猴子打字机 -f'`,
        );
      }
    }
    const { result_data, files } = this.do_pull(typeof local_data === 'string' ? null : local_data, tavern_data, {
      language,
      should_split,
    });
    const collection_files = lodash_default()(files)
      .remove(file => is_collection_file(file.path))
      .groupBy(file => (0, external_node_path_.resolve)(this.dir, file.path))
      .map((files, path) => {
        let content = files.map(file => `# ^${file.name}\n` + file.content).join('\n');
        try {
          content = String(dist.parseDocument(content));
        } catch (error) {
          // TODO: 如何报错
        }
        return {
          path,
          content: content,
        };
      })
      .value();
    write_file_recursively(this.dir, this.file, this.beautify_config(result_data, language));
    [...files, ...collection_files].forEach(({ path, content }) => {
      write_file_recursively(this.dir, path, content);
    });
    console.info(`成功将${this.type_zh} '${this.name}' 拉取到本地文件 '${this.file}' 中`);
  }
  async push_once({ should_force }) {
    const local_data = await this.get_parsed_local();
    if (typeof local_data === 'string') {
      throw Error(`推送${this.type_zh} '${this.name}' 失败: ${local_data}`);
    }
    if (!should_force) {
      const tavern_data = await this.get_parsed_tavern();
      if (typeof tavern_data === 'string') {
        throw Error(`推送${this.type_zh} '${this.name}' 失败: ${tavern_data}`);
      }
      const { error_data } = this.check_safe(local_data, tavern_data);
      if (!lodash_default().isEmpty(error_data)) {
        throw Error(
          dist.stringify({ [`推送${this.type_zh} '${this.name}' 失败`]: error_data }) +
            `如果想无视条目差异, 请在命令尾部添加 '-f' 或 '--force' 选项, 如: 'node tavern_sync.js push 猴子打字机 -f'`,
        );
      }
    }
    const { result_data, error_data } = this.do_push(local_data);
    if (!lodash_default().isEmpty(error_data)) {
      throw Error(dist.stringify({ [`推送${this.type_zh} '${this.name}' 失败`]: error_data }));
    }
    const socket = await wait_socket();
    await socket.emitWithAck(`push_${this.type}`, {
      name: this.name,
      data: result_data,
    });
  }
  async push(options) {
    try {
      await this.push_once(options);
    } catch (err) {
      const error = err;
      exit_on_error(error.message);
    }
    console.info(`成功将${this.type_zh} '${this.name}' 在 '${this.file}' 中的本地内容推送到酒馆`);
  }
  async watch(options) {
    const get_watch_files_from_data = async () => {
      const local_data = await this.get_parsed_local();
      if (typeof local_data === 'string') {
        exit_on_error(`监听${this.type_zh} '${this.name}' 失败: ${local_data}`);
      }
      return this.do_watch(local_data);
    };
    const watcher = watch_on(await get_watch_files_from_data());
    await this.push_once(options);
    console.info(`初始化推送完毕, 开始监听${this.type_zh} '${this.name}'`);
    watcher.on('all', async (_event, path) => {
      console.info(`检测到文件 '${path}' 发生变化, 进行推送...`);
      try {
        await this.push_once(options);
        console.info(`推送成功`);
      } catch (err) {
        const error = err;
        console.error(`${error.message}`);
      }
    });
  }
} // ./node_modules/.pnpm/dedent@1.6.0/node_modules/dedent/dist/dedent.mjs

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    (enumerableOnly &&
      (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })),
      keys.push.apply(keys, symbols));
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2
      ? ownKeys(Object(source), !0).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        })
      : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source))
        : ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, 'string');
  return typeof key === 'symbol' ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== 'object' || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || 'default');
    if (typeof res !== 'object') return res;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (hint === 'string' ? String : Number)(input);
}
const dedent = createDedent({});
/* harmony default export */ const dist_dedent = dedent;
function createDedent(options) {
  dedent.withOptions = newOptions => createDedent(_objectSpread(_objectSpread({}, options), newOptions));
  return dedent;
  function dedent(strings, ...values) {
    const raw = typeof strings === 'string' ? [strings] : strings.raw;
    const { escapeSpecialCharacters = Array.isArray(strings), trimWhitespace = true } = options;

    // first, perform interpolation
    let result = '';
    for (let i = 0; i < raw.length; i++) {
      let next = raw[i];
      if (escapeSpecialCharacters) {
        // handle escaped newlines, backticks, and interpolation characters
        next = next
          .replace(/\\\n[ \t]*/g, '')
          .replace(/\\`/g, '`')
          .replace(/\\\$/g, '$')
          .replace(/\\\{/g, '{');
      }
      result += next;
      if (i < values.length) {
        // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
        result += values[i];
      }
    }

    // now strip indentation
    const lines = result.split('\n');
    let mindent = null;
    for (const l of lines) {
      const m = l.match(/^(\s+)\S+/);
      if (m) {
        const indent = m[1].length;
        if (!mindent) {
          // this is the first indented line
          mindent = indent;
        } else {
          mindent = Math.min(mindent, indent);
        }
      }
    }
    if (mindent !== null) {
      const m = mindent; // appease TypeScript
      result = lines
        // https://github.com/typescript-eslint/typescript-eslint/issues/7140
        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with
        .map(l => (l[0] === ' ' || l[0] === '\t' ? l.slice(m) : l))
        .join('\n');
    }

    // dedent eats leading and trailing whitespace too
    if (trimWhitespace) {
      result = result.trim();
    }

    // handle escaped newlines at the end to ensure they don't get stripped too
    if (escapeSpecialCharacters) {
      result = result.replace(/\\n/g, '\n');
    }
    return result;
  }
} // ./src/type/preset.en.ts

const Prompt_normal = strictObject({
  name: schemas_string(),
  id: never().optional(),
  enabled: schemas_boolean(),
  position: strictObject({
    type: schemas_enum(['relative', 'in_chat']),
    depth: schemas_number().optional(),
    order: schemas_number().optional(),
  })
    .optional()
    .default({ type: 'relative' })
    .superRefine((data, context) => {
      if (data.type === 'in_chat' && (data.depth === undefined || data.order === undefined)) {
        context.addIssue({
          code: 'custom',
          path: ['position'],
          message: '当插入位置设置为`in_chat`时, 必须设置`depth`和`order`',
        });
      }
    })
    .describe('插入位置: `relative` 则按提示词相对位置插入, `in_chat` 则插入到聊天记录中的对应深度'),
  role: schemas_enum(['system', 'user', 'assistant']).default('system').optional(),
  content: schemas_string().optional().describe('内嵌的提示词内容'),
  file: schemas_string().optional().describe('外链的提示词文件路径'),
  extra: record(schemas_string(), any()).optional().describe('额外字段: 用于为预设提示词绑定额外数据'),
})
  .superRefine((data, context) => {
    if (data.content === undefined && data.file === undefined) {
      ['content', 'file'].forEach(key =>
        context.addIssue({
          code: 'custom',
          path: [key],
          message: '必须填写 `content` 或 `file`',
        }),
      );
    }
    if (data.content !== undefined && data.file !== undefined) {
      ['content', 'file'].forEach(key =>
        context.addIssue({
          code: 'custom',
          path: [key],
          message: '不能同时填写 `content` 和 `file`',
        }),
      );
    }
  })
  .transform(data => ({
    ...data,
    id: lodash_default().uniqueId(),
  }))
  .describe('手动在预设中添加的提示词');
const prompt_rolable_placeholder_ids = [
  'world_info_before',
  'persona_description',
  'char_description',
  'char_personality',
  'scenario',
  'world_info_after',
];
const prompt_unrolable_placeholder_ids = ['dialogue_examples', 'chat_history'];
const prompt_placeholder_ids = [...prompt_rolable_placeholder_ids, ...prompt_unrolable_placeholder_ids];
const Prompt_placeholder = strictObject({
  name: never().optional(),
  id: schemas_enum(prompt_placeholder_ids).describe(
    dist_dedent(`
        预设提示词中的占位符提示词, 对应于世界书条目、角色卡、玩家角色、聊天记录等提示词
        - world_info_before: 角色定义之前
        - persona_description: 玩家描述. 创建 user 时填写的提示词
        - char_description: 角色描述. 角色卡侧边栏中填写的提示词
        - char_personality: 角色性格. 角色卡高级定义中的提示词, 一般没人用了
        - scenario: 情景. 角色卡高级定义中的提示词, 一般没人用了
        - world_info_after: 角色定义之后
        - dialogue_examples: 对话示例. 角色卡高级定义中的提示词, 一般没人用了
        - chat_history: 聊天记录
      `),
  ),
  enabled: schemas_boolean(),
  position: strictObject({
    type: schemas_enum(['relative', 'in_chat']),
    depth: schemas_number().optional(),
    order: schemas_number().optional(),
  })
    .optional()
    .default({ type: 'relative' })
    .superRefine((data, context) => {
      if (data?.type === 'in_chat' && (data.depth === undefined || data.order === undefined)) {
        context.addIssue({
          code: 'custom',
          path: ['position'],
          message: '当插入位置设置为`in_chat`时, 必须设置`depth`和`order`',
        });
      }
    })
    .describe('插入位置: `relative` 则按提示词相对位置插入, `in_chat` 则插入到聊天记录中的对应深度'),
  role: schemas_enum(['system', 'user', 'assistant']).default('system').optional(),
  content: never().optional(),
  file: never().optional(),
  extra: record(schemas_string(), any()).optional().describe('额外字段: 用于为预设提示词绑定额外数据'),
})
  .superRefine((data, context) => {
    if (lodash_default().includes(prompt_unrolable_placeholder_ids, data.id) && data.role !== undefined) {
      context.addIssue({
        code: 'custom',
        message: `占位符提示词 '${data.id}' 不能设置自定义角色 (\`role\`)`,
        path: ['role'],
      });
    }
  })
  .transform(data => ({
    ...data,
    role: data.role ?? 'system',
    name: {
      world_info_before: 'World Info (before) - 角色定义之前',
      persona_description: 'Persona Description - 玩家描述',
      char_description: 'Char Description - 角色描述',
      char_personality: 'Char Personality - 角色性格',
      scenario: 'Scenario - 情景',
      world_info_after: 'World Info (after) - 角色定义之后',
      dialogue_examples: 'Chat Examples - 对话示例',
      chat_history: 'Chat History - 聊天记录',
    }[data.id],
  }))
  .describe('预设提示词中的占位符提示词, 对应于世界书条目、角色卡、玩家角色、聊天记录等提示词');
const Prompt = union([Prompt_normal, Prompt_placeholder]);
const Preset = strictObject({
  settings: strictObject({
    max_context: schemas_number()
      .min(0)
      .max(2000000)
      .describe(
        '最大上下文 token 数. 酒馆计算出的上下文 token 数虚高, 容易在上下文 token 数没有达到限制时就报错, 因此建议调到最大 2000000',
      ),
    max_completion_tokens: schemas_number().min(0).describe('最大回复 token 数'),
    reply_count: schemas_number().min(1).default(1).optional().describe('每次生成几个回复'),
    should_stream: schemas_boolean().describe('是否流式传输'),
    temperature: schemas_number().min(0).max(2).describe('温度'),
    frequency_penalty: schemas_number().min(-2).max(2).describe('频率惩罚'),
    presence_penalty: schemas_number().min(-2).max(2).describe('存在惩罚'),
    top_p: schemas_number().min(0).max(1),
    repetition_penalty: schemas_number().min(1).max(2).default(1).optional().describe('重复惩罚'),
    min_p: schemas_number().min(0).max(1).default(0).optional(),
    top_k: schemas_number().min(0).max(500).default(0).optional(),
    top_a: schemas_number().min(0).max(1).default(0).optional(),
    seed: schemas_number().default(-1).optional().describe('种子, -1 表示随机'),
    squash_system_messages: schemas_boolean().describe('压缩系统消息: 将连续的系统消息合并为一条消息'),
    reasoning_effort: schemas_enum(['auto', 'min', 'low', 'medium', 'high', 'max']).describe(
      '推理强度, 即内置思维链的投入程度. 例如, 如果酒馆直连 gemini-2.5-flash, 则 `min` 将会不使用内置思维链',
    ),
    request_thoughts: schemas_boolean()
      .default(true)
      .optional()
      .describe(
        '请求思维链: 允许模型返回内置思维链的思考过程; 注意这只影响内置思维链显不显示, 不决定模型是否使用内置思维链',
      ),
    request_images: schemas_boolean().default(true).optional().describe('请求图片: 允许模型在回复中返回图片'),
    enable_function_calling: schemas_boolean()
      .default(true)
      .optional()
      .describe('启用函数调用: 允许模型使用函数调用功能; 比如 cursor 借此在回复中读写文件、运行命令'),
    enable_web_search: schemas_boolean().default(true).optional().describe('启用网络搜索: 允许模型使用网络搜索功能'),
    allow_sending_images: schemas_enum(['disabled', 'auto', 'low', 'high'])
      .default('auto')
      .optional()
      .describe('是否允许发送图片作为提示词'),
    allow_sending_videos: schemas_boolean().default(true).optional().describe('是否允许发送视频作为提示词'),
    character_name_prefix: schemas_enum(['none', 'default', 'content', 'completion'])
      .default('none')
      .optional()
      .describe(
        dist_dedent(`
        角色名称前缀: 是否要为消息添加角色名称前缀, 以及怎么添加
        - none: 不添加
        - default: 为与角色卡不同名的消息添加角色名称前缀, 添加到 \`content\` 字段开头 (即发送的消息内容是 \`角色名: 消息内容\`)
        - content: 为所有消息添加角色名称前缀, 添加到 \`content\` 字段开头 (即发送的消息内容是 \`角色名: 消息内容\`)
        - completion: 在发送给模型时, 将角色名称写入到 \`name\` 字段; 仅支持字母数字和下划线, 不适用于 Claude、Google 等模型
      `),
      ),
    wrap_user_messages_in_quotes: schemas_boolean()
      .default(false)
      .optional()
      .describe('用引号包裹用户消息: 在发送给模型之前, 将所有用户消息用引号包裹'),
  }),
  anchors: any().optional().describe('用于存放 YAML 锚点, 不会被实际使用'),
  prompts: array(Prompt)
    .superRefine((data, context) => {
      const duplicate_ids = lodash_default()(data)
        .filter(prompt => lodash_default().includes(prompt_placeholder_ids, prompt.id))
        .groupBy('id')
        .filter(group => group.length > 1)
        .keys()
        .value();
      if (duplicate_ids.length > 0) {
        context.addIssue({
          code: 'custom',
          message: `提示词列表中出现了重复的占位符提示词 id: ${duplicate_ids.join(', ')}`,
        });
      }
      const unused_ids = lodash_default().reject(prompt_placeholder_ids, id =>
        data.some(prompt => lodash_default().get(prompt, 'id') === id),
      );
      if (unused_ids.length > 0) {
        context.addIssue({
          code: 'custom',
          message: `提示词列表中缺少了这些必须添加的占位符提示词 id: ${unused_ids.join(', ')}`,
        });
      }
    })
    .describe('提示词列表里已经添加的提示词'),
  prompts_unused: array(Prompt).describe('下拉框里的, 没有添加进提示词列表的提示词'),
  extensions: record(schemas_string(), any()).optional().describe('额外字段: 用于为预设绑定额外数据'),
}); // ./src/server/tavern/preset.ts

const preset_Prompt = object({
  name: schemas_string(),
  id: schemas_string().transform(lodash_default().snakeCase),
  enabled: schemas_boolean(),
  position: object({
    type: schemas_enum(['relative', 'in_chat']),
    depth: schemas_number().optional(),
    order: schemas_number().optional(),
  }).optional(),
  role: schemas_enum(['system', 'user', 'assistant']),
  content: schemas_string().optional(),
  extra: record(schemas_string(), any()).optional(),
}).transform(data => {
  if (lodash_default().includes(prompt_placeholder_ids, data.id)) {
    lodash_default().unset(data, 'name');
    lodash_default().unset(data, 'content');
    if (data.position?.type === 'relative') {
      lodash_default().unset(data, 'position');
    }
    if (lodash_default().includes(prompt_unrolable_placeholder_ids, data.id) || data.role === 'system') {
      lodash_default().unset(data, 'role');
    }
    return data;
  }
  lodash_default().unset(data, 'id');
  return data;
});
const preset_Preset = object({
  settings: object({
    max_context: schemas_number().min(0).max(2000000),
    max_completion_tokens: schemas_number().min(0),
    reply_count: schemas_number().min(1),
    should_stream: schemas_boolean(),
    temperature: schemas_number().min(0).max(2),
    frequency_penalty: schemas_number().min(-2).max(2),
    presence_penalty: schemas_number().min(-2).max(2),
    top_p: schemas_number().min(0).max(1),
    repetition_penalty: schemas_number().min(1).max(2),
    min_p: schemas_number().min(0).max(1),
    top_k: schemas_number().min(0).max(500),
    top_a: schemas_number().min(0).max(1),
    seed: schemas_number(),
    squash_system_messages: schemas_boolean(),
    reasoning_effort: schemas_enum(['auto', 'min', 'low', 'medium', 'high', 'max']),
    request_thoughts: schemas_boolean(),
    request_images: schemas_boolean(),
    enable_function_calling: schemas_boolean(),
    enable_web_search: schemas_boolean(),
    allow_sending_images: schemas_enum(['disabled', 'auto', 'low', 'high']),
    allow_sending_videos: schemas_boolean(),
    character_name_prefix: schemas_enum(['none', 'default', 'content', 'completion']),
    wrap_user_messages_in_quotes: schemas_boolean(),
  }),
  anchors: schemas_void().transform(() => ({})),
  prompts: array(preset_Prompt),
  prompts_unused: array(preset_Prompt).transform(prompts =>
    prompts.filter(
      prompt =>
        !lodash_default().includes(
          ['Main Prompt', 'Auxiliary Prompt', 'Post-History Instructions', 'Enhance Definitions'],
          prompt.name,
        ) && !lodash_default().includes(prompt_placeholder_ids, prompt.id),
    ),
  ),
  extensions: record(schemas_string(), any()).optional(),
}).transform(data => {
  if (data.settings.reply_count === 1) {
    lodash_default().unset(data, 'settings.reply_count');
  }
  if (data.settings.repetition_penalty === 1) {
    lodash_default().unset(data, 'settings.repetition_penalty');
  }
  if (data.settings.min_p === 0) {
    lodash_default().unset(data, 'settings.min_p');
  }
  if (data.settings.top_a === 0) {
    lodash_default().unset(data, 'settings.top_a');
  }
  if (data.settings.top_k === 0) {
    lodash_default().unset(data, 'settings.top_k');
  }
  if (data.settings.seed === -1) {
    lodash_default().unset(data, 'settings.seed');
  }
  if (data.settings.wrap_user_messages_in_quotes === false) {
    lodash_default().unset(data, 'settings.wrap_user_messages_in_quotes');
  }
  if (lodash_default().isEmpty(data.extensions)) {
    lodash_default().unset(data, 'extensions');
  }
  return data;
}); // ./src/server/util/is_yaml.ts

function is_yaml(content) {
  try {
    dist.parse(content);
    return true;
  } catch (error) {
    return false;
  }
} // ./src/server/util/detect_extension.ts

function detect_extension(content) {
  if (is_yaml(content)) {
    return '.yaml';
  }
  return '.md';
} // ./src/server/util/extract_file_content.ts

function extract_file_content(path) {
  return (0, external_node_fs_.readFileSync)(path, 'utf-8');
} // ./src/server/util/glob_file.ts

function glob_file(base, file) {
  return (0, external_node_fs_.globSync)((0, external_node_path_.resolve)(base, file) + '{.*,}');
} // ./src/server/util/is_parent.ts

function is_parent(parent_path, possible_child_path) {
  const result = (0, external_path_.relative)(parent_path, possible_child_path);
  return Boolean(result) && !result.startsWith('..') && !(0, external_path_.isAbsolute)(result);
} // ./src/server/util/sanitize_filename.ts

function sanitize_filename(filename) {
  switch (process.platform) {
    case 'win32':
    case 'cygwin':
      return filename.replace(/[\s<>:"/\\|?*\x00-\x1F\x7F]/g, '_');
    case 'darwin':
    case 'linux':
      return filename.replace(/[:\/]/g, '_');
    default:
      return filename;
  }
} // ./src/type/preset.zh.ts

const preset_zh_zh_to_en_map = {
  名称: 'name',
  启用: 'enabled',
  插入位置: 'position',
  类型: 'type',
  相对: 'relative',
  聊天中: 'in_chat',
  深度: 'depth',
  顺序: 'order',
  角色: 'role',
  系统: 'system',
  用户: 'user',
  AI: 'assistant',
  内容: 'content',
  文件: 'file',
  额外字段: 'extra',
  角色定义之前: 'world_info_before',
  玩家描述: 'persona_description',
  角色描述: 'char_description',
  角色性格: 'char_personality',
  情景: 'scenario',
  角色定义之后: 'world_info_after',
  对话示例: 'dialogue_examples',
  聊天记录: 'chat_history',
  设置: 'settings',
  上下文长度: 'max_context',
  最大回复token数: 'max_completion_tokens',
  每次回复数: 'reply_count',
  流式传输: 'should_stream',
  温度: 'temperature',
  频率惩罚: 'frequency_penalty',
  存在惩罚: 'presence_penalty',
  重复惩罚: 'repetition_penalty',
  种子: 'seed',
  压缩系统消息: 'squash_system_messages',
  推理强度: 'reasoning_effort',
  自动: 'auto',
  最小: 'min',
  低: 'low',
  中: 'medium',
  高: 'high',
  最大: 'max',
  请求思维链: 'request_thoughts',
  请求图片: 'request_images',
  启用函数调用: 'enable_function_calling',
  启用网络搜索: 'enable_web_search',
  允许发送图片: 'allow_sending_images',
  禁用: 'disabled',
  允许发送视频: 'allow_sending_videos',
  角色名称前缀: 'character_name_prefix',
  无: 'none',
  默认: 'default',
  补全对象: 'completion',
  用引号包裹用户消息: 'wrap_user_messages_in_quotes',
  锚点: 'anchors',
  提示词: 'prompts',
  未添加的提示词: 'prompts_unused',
  扩展字段: 'extensions',
};
function preset_zh_is_zh(data) {
  return lodash_default().has(data, '提示词');
}
const preset_zh_Prompt_normal = strictObject({
  名称: schemas_string(),
  id: never().optional(),
  启用: schemas_boolean(),
  插入位置: strictObject({
    类型: schemas_enum(['相对', '聊天中']),
    深度: schemas_number().optional(),
    顺序: schemas_number().optional(),
  })
    .optional()
    .default({ 类型: '相对' })
    .superRefine((data, context) => {
      if (data.类型 === '聊天中' && (data.深度 === undefined || data.顺序 === undefined)) {
        context.addIssue({
          code: 'custom',
          path: ['插入位置'],
          message: '当插入位置设置为`聊天中`时, 必须设置`深度`和`顺序`',
        });
      }
    })
    .describe('插入位置: `相对`则按提示词相对位置插入, `聊天中`则插入到聊天记录中的对应深度'),
  角色: schemas_enum(['系统', '用户', 'AI']).default('系统').optional(),
  内容: schemas_string().optional().describe('内嵌的提示词内容'),
  文件: schemas_string().optional().describe('外链的提示词文件路径'),
  额外字段: record(schemas_string(), any()).optional().describe('额外字段: 用于为预设提示词绑定额外数据'),
})
  .superRefine((data, context) => {
    if (data.内容 === undefined && data.文件 === undefined) {
      ['内容', '文件'].forEach(key =>
        context.addIssue({
          code: 'custom',
          path: [key],
          message: '必须填写`内容`或`文件`',
        }),
      );
    }
    if (data.内容 !== undefined && data.文件 !== undefined) {
      ['内容', '文件'].forEach(key =>
        context.addIssue({
          code: 'custom',
          path: [key],
          message: '不能同时填写`内容`和`文件`',
        }),
      );
    }
  })
  .transform(data => ({
    ...data,
    id: lodash_default().uniqueId(),
  }))
  .describe('手动在预设中添加的提示词');
const preset_zh_prompt_rolable_placeholder_ids = [
  '角色定义之前',
  '玩家描述',
  '角色描述',
  '角色性格',
  '情景',
  '角色定义之后',
];
const preset_zh_prompt_unrolable_placeholder_ids = ['对话示例', '聊天记录'];
const preset_zh_prompt_placeholder_ids = [
  ...preset_zh_prompt_rolable_placeholder_ids,
  ...preset_zh_prompt_unrolable_placeholder_ids,
];
const preset_zh_Prompt_placeholder = strictObject({
  名称: never().optional(),
  id: schemas_enum(preset_zh_prompt_placeholder_ids).describe(
    dist_dedent(`
        预设提示词中的占位符提示词, 对应于世界书条目、角色卡、玩家角色、聊天记录等提示词
        - 角色定义之前: world_info_before
        - 玩家描述: persona_description. 创建 user 时填写的提示词
        - 角色描述: char_description. 角色卡侧边栏中填写的提示词
        - 角色性格: char_personality. 角色卡高级定义中的提示词, 一般没人用了
        - 情景: scenario. 角色卡高级定义中的提示词, 一般没人用了
        - 角色定义之后: world_info_after
        - 对话示例: dialogue_examples. 角色卡高级定义中的提示词, 一般没人用了
        - 聊天记录: chat_history
      `),
  ),
  启用: schemas_boolean(),
  插入位置: strictObject({
    类型: schemas_enum(['相对', '聊天中']),
    深度: schemas_number().optional(),
    顺序: schemas_number().optional(),
  })
    .optional()
    .default({ 类型: '相对' })
    .superRefine((data, context) => {
      if (data.类型 === '聊天中' && (data.深度 === undefined || data.顺序 === undefined)) {
        context.addIssue({
          code: 'custom',
          path: ['插入位置'],
          message: '当插入位置设置为`聊天中`时, 必须设置`深度`和`顺序`',
        });
      }
    })
    .describe('插入位置: `相对`则按提示词相对位置插入, `聊天中`则插入到聊天记录中的对应深度'),
  角色: schemas_enum(['系统', '用户', 'AI']).optional(),
  内容: never().optional(),
  文件: never().optional(),
  额外字段: record(schemas_string(), any()).optional().describe('额外字段: 用于为预设提示词绑定额外数据'),
})
  .superRefine((data, context) => {
    if (lodash_default().includes(preset_zh_prompt_unrolable_placeholder_ids, data.id) && data.角色 !== undefined) {
      context.addIssue({
        code: 'custom',
        message: `占位符提示词 '${data.id}' 不能设置自定义\`角色\``,
        path: ['角色'],
      });
    }
  })
  .transform(data => ({
    ...data,
    角色: data.角色 ?? '系统',
    名称: {
      角色定义之前: 'World Info (before) - 角色定义之前',
      玩家描述: 'Persona Description - 玩家描述',
      角色描述: 'Char Description - 角色描述',
      角色性格: 'Char Personality - 角色性格',
      情景: 'Scenario - 情景',
      角色定义之后: 'World Info (after) - 角色定义之后',
      对话示例: 'Chat Examples - 对话示例',
      聊天记录: 'Chat History - 聊天记录',
    }[data.id],
  }))
  .describe('预设提示词中的占位符提示词, 对应于世界书条目、角色卡、玩家角色、聊天记录等提示词');
const preset_zh_Prompt = union([preset_zh_Prompt_normal, preset_zh_Prompt_placeholder]);
const preset_zh_Preset = strictObject({
  设置: strictObject({
    上下文长度: schemas_number()
      .min(0)
      .max(2000000)
      .describe(
        '最大上下文 token 数. 酒馆计算出的上下文 token 数虚高, 容易在上下文 token 数没有达到限制时就报错, 因此建议调到最大 2000000',
      ),
    最大回复token数: schemas_number().min(0).describe('最大回复 token 数'),
    每次回复数: schemas_number().min(1).default(1).optional().describe('每次生成几个回复'),
    流式传输: schemas_boolean().describe('是否流式传输'),
    温度: schemas_number().min(0).max(2).describe('温度'),
    频率惩罚: schemas_number().min(-2).max(2).describe('频率惩罚'),
    存在惩罚: schemas_number().min(-2).max(2).describe('存在惩罚'),
    top_p: schemas_number().min(0).max(1),
    重复惩罚: schemas_number().min(1).max(2).default(1).optional().describe('重复惩罚'),
    min_p: schemas_number().min(0).max(1).default(0).optional(),
    top_k: schemas_number().min(0).max(500).default(0).optional(),
    top_a: schemas_number().min(0).max(1).default(0).optional(),
    种子: schemas_number().default(-1).optional().describe('种子, -1 表示随机'),
    压缩系统消息: schemas_boolean().describe('压缩系统消息: 将连续的系统消息合并为一条消息'),
    推理强度: schemas_enum(['自动', '最小', '低', '中', '高', '最大']).describe(
      '推理强度, 即内置思维链的投入程度. 例如, 如果酒馆直连 gemini-2.5-flash, 则`最小`将会不使用内置思维链',
    ),
    请求思维链: schemas_boolean()
      .default(true)
      .optional()
      .describe(
        '请求思维链: 允许模型返回内置思维链的思考过程; 注意这只影响内置思维链显不显示, 不决定模型是否使用内置思维链',
      ),
    请求图片: schemas_boolean().default(true).optional().describe('请求图片: 允许模型在回复中返回图片'),
    启用函数调用: schemas_boolean()
      .default(true)
      .optional()
      .describe('启用函数调用: 允许模型使用函数调用功能; 比如 cursor 借此在回复中读写文件、运行命令'),
    启用网络搜索: schemas_boolean().default(true).optional().describe('启用网络搜索: 允许模型使用网络搜索功能'),
    允许发送图片: schemas_enum(['禁用', '自动', '低', '高'])
      .default('自动')
      .optional()
      .describe('是否允许发送图片作为提示词'),
    允许发送视频: schemas_boolean().default(true).optional().describe('是否允许发送视频作为提示词'),
    角色名称前缀: schemas_enum(['无', '默认', '内容', '补全'])
      .default('无')
      .optional()
      .describe(
        dist_dedent(`
        角色名称前缀: 是否要为消息添加角色名称前缀, 以及怎么添加
        - 无: 不添加
        - 默认: 为与角色卡不同名的消息添加角色名称前缀, 添加到 \`content\` 字段开头 (即发送的消息内容是 \`角色名: 消息内容\`)
        - 内容: 为所有消息添加角色名称前缀, 添加到 \`content\` 字段开头 (即发送的消息内容是 \`角色名: 消息内容\`)
        - 补全: 在发送给模型时, 将角色名称写入到 \`name\` 字段; 仅支持字母数字和下划线, 不适用于 Claude、Google 等模型
      `),
      ),
    用引号包裹用户消息: schemas_boolean()
      .default(false)
      .optional()
      .describe('用引号包裹用户消息: 在发送给模型之前, 将所有用户消息用引号包裹'),
  }),
  锚点: record(schemas_string(), any()).optional().describe('用于存放 YAML 锚点, 不会被实际使用'),
  提示词: array(preset_zh_Prompt)
    .superRefine((data, context) => {
      const duplicate_ids = lodash_default()(data)
        .filter(prompt => lodash_default().includes(preset_zh_prompt_placeholder_ids, prompt.id))
        .groupBy('id')
        .filter(group => group.length > 1)
        .keys()
        .value();
      if (duplicate_ids.length > 0) {
        context.addIssue({
          code: 'custom',
          message: `提示词列表中出现了重复的占位符提示词 id: ${duplicate_ids.join(', ')}`,
        });
      }
      const unused_ids = lodash_default().reject(preset_zh_prompt_placeholder_ids, id =>
        data.some(prompt => lodash_default().get(prompt, 'id') === id),
      );
      if (unused_ids.length > 0) {
        context.addIssue({
          code: 'custom',
          message: `提示词列表中缺少了这些必须添加的占位符提示词 id: ${unused_ids.join(', ')}`,
        });
      }
    })
    .describe('提示词列表里已经添加的提示词'),
  未添加的提示词: array(preset_zh_Prompt).describe('下拉框里的, 没有添加进提示词列表的提示词'),
  扩展字段: any().optional().describe('扩展字段: 用于为预设绑定额外数据'),
}); // ./src/server/syncer/preset.ts

class Preset_syncer extends Syncer_interface {
  constructor(config_name, name, file) {
    super(
      'preset',
      lodash_default().invert(zh_to_en_map)['preset'],
      config_name,
      name,
      file,
      Preset,
      preset_zh_Preset,
      preset_zh_zh_to_en_map,
      preset_zh_is_zh,
      preset_Preset,
    );
  }
  // TODO: 拆分 component
  do_check_safe(local_data, tavern_data) {
    const get_names = data => {
      return lodash_default()(data.prompts)
        .concat(data.prompts_unused)
        .filter(prompt => !lodash_default().includes(prompt_placeholder_ids, lodash_default().get(prompt, 'id', '')))
        .map(prompt => prompt.name)
        .value();
    };
    const local_names = get_names(local_data);
    const tavern_names = get_names(tavern_data);
    return {
      local_only_data: lodash_default().difference(local_names, tavern_names),
      tavern_only_data: lodash_default().difference(tavern_names, local_names),
    };
  }
  // TODO: 拆分 component
  do_pull(local_data, tavern_data, { language, should_split }) {
    let files = [];
    const prompts_state =
      local_data === null
        ? []
        : [...local_data.prompts, ...local_data.prompts_unused].filter(prompt => !lodash_default().has(prompt, 'id'));
    const convert_prompts = (prompts, { used }) =>
      prompts.forEach(prompt => {
        if (lodash_default().has(prompt, 'id')) {
          return;
        }
        const handle_file = (prompt, file) => {
          let file_to_write = '';
          let file_to_set = '';
          const glob_files = glob_file(this.dir, file);
          if (glob_files.length === 0) {
            file_to_write = file.replace(/\.[^\\/]+$|$/, detect_extension(prompt.content));
            file_to_set = file.replace(/\.[^\\/]+$/, '');
          } else if (glob_files.length === 1) {
            file_to_write = glob_files[0];
            file_to_set = (0, external_node_path_.relative)(this.dir, glob_files[0]).replace(/\.[^\\/]+$/, '');
          } else {
            file_to_write = file;
            file_to_set = file;
          }
          files.push({ name: prompt.name, path: file_to_write, content: prompt.content });
          lodash_default().unset(prompt, 'content');
          lodash_default().set(prompt, 'file', file_to_set);
        };
        const state = prompts_state.find(state => state.name === prompt.name);
        if (state === undefined && should_split) {
          const file = (0, external_node_path_.join)(
            sanitize_filename(this.config_name),
            used ? '' : language === 'zh' ? '未使用' : 'unused',
            sanitize_filename(prompt.name),
          );
          handle_file(prompt, file);
          return;
        }
        if (state?.file !== undefined) {
          handle_file(prompt, state.file);
          return;
        }
      });
    convert_prompts(tavern_data.prompts, { used: true });
    convert_prompts(tavern_data.prompts_unused, { used: false });
    return { result_data: tavern_data, files };
  }
  do_beautify_config(tavern_data, language) {
    const document = new dist.Document(
      language === 'zh' ? translate(tavern_data, lodash_default().invert(this.zh_to_en_map)) : tavern_data,
    );
    ['提示词', '未添加的提示词', 'prompts', 'prompts_unused'].forEach(key =>
      dist.visit(document.get(key), (key, node) => {
        if (key === null) {
          return;
        }
        if (key > 0) {
          node.spaceBefore = true;
        }
        return dist.visit.SKIP;
      }),
    );
    dist.visit(document, (key, node) => {
      if (key === null) {
        return;
      }
      if (dist.isPair(node) && key > 0) {
        node.key.spaceBefore = true;
      }
      return dist.visit.SKIP;
    });
    return document.toString({ blockQuote: 'literal' });
  }
  // TODO: 拆分 component
  do_push(local_data) {
    let error_data = {
      未能找到以下外链提示词文件: [],
      通过补全文件后缀找到了多个文件: [],
      未能从合集文件中找到以下条目: [],
    };
    const handle_placeholder_id = prompts => {
      prompts.forEach(prompt => {
        if (lodash_default().includes(prompt_placeholder_ids, prompt.id)) {
          lodash_default().set(prompt, 'id', lodash_default().camelCase(prompt.id));
        }
      });
    };
    handle_placeholder_id(local_data.prompts);
    handle_placeholder_id(local_data.prompts_unused);
    const handle_file = (prompts, source) => {
      prompts.forEach((prompt, index) => {
        if (!lodash_default().has(prompt, 'file') || prompt.file === undefined) {
          return;
        }
        const paths = glob_file(this.dir, prompt.file);
        if (paths.length === 0) {
          error_data.未能找到以下外链提示词文件.push(`${source}条目 '${index}' 的 '${prompt.file}'`);
          return;
        }
        if (paths.length > 1) {
          error_data.通过补全文件后缀找到了多个文件.push(`${source}条目 '${index}' 的 '${prompt.file}'`);
        }
        const content = extract_file_content(paths[0]);
        if (is_collection_file(prompt.file)) {
          const collection_file = parse_collection_file(content);
          const collection_entry = collection_file.find(value => value.name === prompt.name);
          if (collection_entry === undefined) {
            error_data.未能从合集文件中找到以下条目.push(`'${prompt.file}': 第 '${index}' 条目 '${prompt.name}'`);
            return;
          }
          lodash_default().set(prompt, 'content', collection_entry.content);
          lodash_default().unset(prompt, 'file');
          return;
        }
        lodash_default().set(prompt, 'content', content);
        lodash_default().unset(prompt, 'file');
      });
    };
    handle_file(local_data.prompts, '提示词');
    handle_file(local_data.prompts_unused, '未添加的提示词');
    const handle_user_name = prompts => {
      prompts.forEach(prompt => {
        lodash_default().set(prompt, 'content', replace_user_name(prompt.content));
      });
    };
    handle_user_name(local_data.prompts);
    handle_user_name(local_data.prompts_unused);
    const handle_raw_string = prompts => {
      prompts.forEach(prompt => {
        lodash_default().set(prompt, 'content', replace_raw_string(prompt.content));
      });
    };
    handle_raw_string(local_data.prompts);
    handle_raw_string(local_data.prompts_unused);
    return {
      result_data: local_data,
      error_data: lodash_default().pickBy(error_data, value => value.length > 0),
    };
  }
  do_watch(local_data) {
    return lodash_default()(
      lodash_default()(local_data.prompts)
        .concat(local_data.prompts_unused)
        .filter(prompt => prompt.file !== undefined)
        .map(prompt => (0, external_node_path_.resolve)(this.dir, prompt.file))
        .value(),
    )
      .map(path => (0, external_node_path_.dirname)(path))
      .reduce((result, path) => {
        if (result.some(parent => is_parent(parent, path))) {
          return result;
        }
        result.push(path);
        return result;
      }, [])
      .concat(this.file);
  }
} // ./src/server/tavern/worldbook.ts

const Worldbook_entry = object({
  name: schemas_string(),
  uid: schemas_number(),
  enabled: schemas_boolean(),
  strategy: object({
    type: schemas_enum(['constant', 'selective', 'vectorized']),
    keys: array(schemas_string()),
    keys_secondary: object({
      logic: schemas_enum(['and_any', 'and_all', 'not_all', 'not_any']),
      keys: array(schemas_string()),
    }),
    scan_depth: union([literal('same_as_global'), schemas_number()]),
  }),
  position: object({
    type: schemas_enum([
      'before_character_definition',
      'after_character_definition',
      'before_example_messages',
      'after_example_messages',
      'before_author_note',
      'after_author_note',
      'at_depth',
    ]),
    role: schemas_enum(['system', 'assistant', 'user']),
    depth: schemas_number(),
    order: schemas_number(),
  }),
  probability: schemas_number().min(0).max(100),
  recursion: object({
    prevent_incoming: schemas_boolean(),
    prevent_outgoing: schemas_boolean(),
    delay_until: schemas_number().min(1).nullable(),
  }),
  effect: object({
    sticky: schemas_number().nullable(),
    cooldown: schemas_number().nullable(),
    delay: schemas_number().nullable(),
  }),
  extra: record(schemas_string(), any()).optional(),
  content: schemas_string(),
}).transform(data => {
  _.unset(data, 'uid');
  if (data.strategy.keys.length === 0) {
    _.unset(data, 'strategy.keys');
  }
  if (data.strategy.keys_secondary.keys.length === 0) {
    _.unset(data, 'strategy.keys_secondary');
  }
  if (data.strategy.scan_depth === 'same_as_global') {
    _.unset(data, 'strategy.scan_depth');
  }
  if (data.position.type !== 'at_depth') {
    _.unset(data, 'position.role');
    _.unset(data, 'position.depth');
  }
  if (!data.recursion.delay_until) {
    _.unset(data, 'recursion.delay_until');
  }
  if (!data.effect.sticky) {
    _.unset(data, 'effect.sticky');
  }
  if (!data.effect.cooldown) {
    _.unset(data, 'effect.cooldown');
  }
  if (!data.effect.delay) {
    _.unset(data, 'effect.delay');
  }
  if (_.isEmpty(data.effect)) {
    _.unset(data, 'effect');
  }
  if (_.isEmpty(data.extra)) {
    _.unset(data, 'extra');
  }
  return data;
});
const Worldbook = array(Worldbook_entry)
  .min(1)
  .transform(entries => ({
    anchors: {},
    entries,
  })); // ./src/type/worldbook.en.ts

const worldbook_en_Worldbook_entry = strictObject({
  name: schemas_string(),
  uid: schemas_number().optional().describe('该条目的唯一标识符, 如果不设置或有重复则会自动分配一个新的'),
  enabled: schemas_boolean(),
  strategy: strictObject({
    type: schemas_enum(['constant', 'selective', 'vectorized']).describe(
      dist_dedent(`
          激活策略类型:
          - constant: 常量🔵, 俗称蓝灯. 只需要满足 "启用"、"激活概率%" 等别的要求即可.
          - selective: 可选项🟢, 俗称绿灯. 除了蓝灯条件, 还需要满足 \`keys\` 扫描条件
          - vectorized: 向量化🔗. 一般不使用
        `),
    ),
    keys: array(schemas_string())
      .min(1)
      .optional()
      .describe('关键字: 绿灯条目必须在欲扫描文本中扫描到其中任意一个关键字才能激活'),
    keys_secondary: strictObject({
      logic: schemas_enum(['and_any', 'and_all', 'not_all', 'not_any']).describe(
        dist_dedent(`
              次要关键字逻辑:
              - and_any: 次要关键字中任意一个关键字能在欲扫描文本中匹配到
              - and_all: 次要关键字中所有关键字都能在欲扫描文本中匹配到
              - not_all: 次要关键字中至少有一个关键字没能在欲扫描文本中匹配到
              - not_any: 次要关键字中所有关键字都没能欲扫描文本中匹配到
            `),
      ),
      keys: array(schemas_string()).min(1),
    })
      .optional()
      .describe(
        '次要关键字: 如果设置了次要关键字, 则条目除了在 `keys` 中匹配到任意一个关键字外, 还需要按次要关键字的 `logic` 满足次要关键字的 `keys`',
      ),
    scan_depth: union([literal('same_as_global'), schemas_number().min(1)])
      .optional()
      .describe('扫描深度: 1 为仅扫描最后一个楼层, 2 为扫描最后两个楼层, 以此类推'),
  })
    .superRefine((data, context) => {
      if (data.type === 'selective' && data.keys === undefined) {
        context.addIssue({
          code: 'custom',
          path: ['keys'],
          message: "当激活策略为绿灯 (`'selective'`) 时, `keys` 中有必须至少一个主要关键字",
        });
      }
    })
    .describe('激活策略: 条目应该何时激活'),
  position: strictObject({
    type: schemas_enum([
      'before_character_definition',
      'after_character_definition',
      'before_example_messages',
      'after_example_messages',
      'before_author_note',
      'after_author_note',
      'at_depth',
    ]).describe(
      dist_dedent(`
            插入位置类型:
            - before_character_definition: 角色定义之前
            - after_character_definition: 角色定义之后
            - before_example_messages: 示例消息之前
            - after_example_messages: 示例消息之后
            - before_author_note: 作者注释之前
            - after_author_note: 作者注释之后
            - at_depth: 插入到指定深度
          `),
    ),
    role: schemas_enum(['system', 'assistant', 'user'])
      .optional()
      .describe("该条目的消息身份, 仅位置类型为 `'at_depth'` 时有效"),
    depth: schemas_number().optional().describe("该条目要插入的深度, 仅位置类型为 `'at_depth'` 时有效"),
    order: schemas_number(),
  })
    .describe('插入位置: 如果条目激活应该插入到什么地方')
    .superRefine((data, context) => {
      if (data.type === 'at_depth') {
        if (data.role === undefined) {
          context.addIssue({
            code: 'custom',
            path: ['role'],
            message: "当插入位置 (`position`) 为 `'at_depth'` 时, 必须填写 `role`",
          });
        }
        if (data.depth === undefined) {
          context.addIssue({
            code: 'custom',
            path: ['depth'],
            message: "当插入位置 (`position`)为 `'at_depth'` 时, 必须填写 `depth`",
          });
        }
      } else {
        if (data.role !== undefined) {
          context.addIssue({
            code: 'custom',
            path: ['role'],
            message: "当插入位置 (`position`) 不为 `'at_depth'` 时, `role` 不起作用, 不要填写",
          });
        }
        if (data.depth !== undefined) {
          context.addIssue({
            code: 'custom',
            path: ['depth'],
            message: "当插入位置 (`position`) 不为 `'at_depth'` 时, `depth` 不起作用, 不要填写",
          });
        }
      }
    }),
  probability: schemas_number().min(0).max(100).optional(),
  recursion: strictObject({
    prevent_incoming: schemas_boolean().describe('禁止其他条目递归激活本条目'),
    prevent_outgoing: schemas_boolean().describe('禁止本条目递归激活其他条目'),
    delay_until: schemas_number().min(1).nullable().describe('延迟到第 n 级递归检查时才能激活本条目'),
  })
    .partial()
    .optional()
    .describe('递归表示某世界书条目被激活后, 该条目的提示词又激活了其他条目'),
  effect: strictObject({
    sticky: schemas_number()
      .min(1)
      .nullable()
      .describe('黏性: 条目激活后, 在之后 n 条消息内始终激活, 无视激活策略、激活概率%'),
    cooldown: schemas_number().min(1).nullable().describe('冷却: 条目激活后, 在之后 n 条消息内不能再激活'),
    delay: schemas_number().min(1).nullable().describe('延迟: 聊天中至少有 n 楼消息时, 才能激活条目'),
  })
    .partial()
    .optional(),
  extra: record(schemas_string(), any()).optional().describe('额外字段: 用于为预设提示词绑定额外数据'),
  content: schemas_string().optional().describe('内嵌的提示词内容'),
  file: schemas_string().optional().describe('外链的提示词文件路径'),
}).superRefine((data, context) => {
  if (data.content === undefined && data.file === undefined) {
    ['content', 'file'].forEach(key =>
      context.addIssue({
        code: 'custom',
        path: [key],
        message: '必须填写 `content` 或 `file`',
      }),
    );
  }
  if (data.content !== undefined && data.file !== undefined) {
    ['content', 'file'].forEach(key =>
      context.addIssue({
        code: 'custom',
        path: [key],
        message: '不能同时填写 `content` 和 `file`',
      }),
    );
  }
});
const worldbook_en_Worldbook = strictObject({
  anchors: any().optional().describe('用于存放 YAML 锚点, 不会被实际使用'),
  entries: array(worldbook_en_Worldbook_entry).min(1),
}); // ./src/type/worldbook.zh.ts

const worldbook_zh_zh_to_en_map = {
  锚点: 'anchors',
  条目: 'entries',
  名称: 'name',
  启用: 'enabled',
  激活策略: 'strategy',
  类型: 'type',
  蓝灯: 'constant',
  绿灯: 'selective',
  向量化: 'vectorized',
  关键字: 'keys',
  次要关键字: 'keys_secondary',
  逻辑: 'logic',
  与任意: 'and_any',
  与所有: 'and_all',
  非所有: 'not_all',
  非任意: 'not_any',
  扫描深度: 'scan_depth',
  与全局设置相同: 'same_as_global',
  插入位置: 'position',
  角色定义之前: 'before_character_definition',
  角色定义之后: 'after_character_definition',
  示例消息之前: 'before_example_messages',
  示例消息之后: 'after_example_messages',
  作者注释之前: 'before_author_note',
  作者注释之后: 'after_author_note',
  指定深度: 'at_depth',
  角色: 'role',
  系统: 'system',
  AI: 'assistant',
  用户: 'user',
  深度: 'depth',
  顺序: 'order',
  激活概率: 'probability',
  递归: 'recursion',
  不可被其他条目激活: 'prevent_incoming',
  不可激活其他条目: 'prevent_outgoing',
  延迟递归: 'delay_until',
  特殊效果: 'effect',
  黏性: 'sticky',
  冷却: 'cooldown',
  延迟: 'delay',
  额外字段: 'extra',
  内容: 'content',
  文件: 'file',
};
function worldbook_zh_is_zh(data) {
  return _.has(data, '条目');
}
const worldbook_zh_Worldbook_entry = strictObject({
  名称: schemas_string(),
  uid: schemas_number().optional().describe('该条目的唯一标识符, 如果不设置或有重复则会自动分配一个新的'),
  启用: schemas_boolean(),
  激活策略: strictObject({
    类型: schemas_enum(['蓝灯', '绿灯', '向量化']).describe(
      dist_dedent(`
          激活策略类型:
          - 蓝灯: 常量🔵 (constant). 只需要满足 "启用"、"激活概率%" 等别的要求即可.
          - 绿灯: 可选项🟢 (selective). 除了蓝灯条件, 还需要满足 \`关键字\` 扫描条件
          - 向量化: 向量化🔗 (vectorized). 一般不使用
        `),
    ),
    关键字: array(schemas_string())
      .min(1)
      .optional()
      .describe('关键字: 绿灯条目必须在欲扫描文本中扫描到其中任意一个关键字才能激活'),
    次要关键字: strictObject({
      逻辑: schemas_enum(['与任意', '与所有', '非所有', '非任意']).describe(
        dist_dedent(`
              次要关键字逻辑:
              - 与任意 (and_any): 次要关键字中任意一个关键字能在欲扫描文本中匹配到
              - 与所有 (and_all): 次要关键字中所有关键字都能在欲扫描文本中匹配到
              - 非所有 (not_all): 次要关键字中至少有一个关键字没能在欲扫描文本中匹配到
              - 非任意 (not_any): 次要关键字中所有关键字都没能欲扫描文本中匹配到
            `),
      ),
      关键字: array(schemas_string()).min(1),
    })
      .optional()
      .describe(
        '次要关键字: 如果设置了次要关键字, 则条目除了在`关键字`中匹配到任意一个关键字外, 还需要按次要关键字的`逻辑`满足次要关键字的`关键字`',
      ),
    扫描深度: union([literal('与全局设置相同'), schemas_number().min(1)])
      .optional()
      .describe('扫描深度: 1 为仅扫描最后一个楼层, 2 为扫描最后两个楼层, 以此类推'),
  })
    .superRefine((data, context) => {
      if (data.类型 === '绿灯' && data.关键字 === undefined) {
        context.addIssue({
          code: 'custom',
          path: ['关键字'],
          message: '当激活策略为`绿灯`时, `关键字`中有必须至少一个主要关键字',
        });
      }
    })
    .describe('激活策略: 条目应该何时激活'),
  插入位置: strictObject({
    类型: schemas_enum([
      '角色定义之前',
      '角色定义之后',
      '示例消息之前',
      '示例消息之后',
      '作者注释之前',
      '作者注释之后',
      '指定深度',
    ]),
    角色: schemas_enum(['系统', 'AI', '用户']).optional().describe("该条目的消息身份, 仅位置类型为`'指定深度'`时有效"),
    深度: schemas_number().optional().describe("该条目要插入的深度, 仅位置类型为`'指定深度'`时有效"),
    顺序: schemas_number(),
  })
    .describe('插入位置: 如果条目激活应该插入到什么地方')
    .superRefine((data, context) => {
      if (data.类型 === '指定深度') {
        if (data.角色 === undefined) {
          context.addIssue({
            code: 'custom',
            path: ['角色'],
            message: "当`插入位置`为`'指定深度'`时, 必须填写`角色`",
          });
        }
        if (data.深度 === undefined) {
          context.addIssue({
            code: 'custom',
            path: ['深度'],
            message: "当`插入位置`为`'指定深度'`时, 必须填写`深度`",
          });
        }
      } else {
        if (data.角色 !== undefined) {
          context.addIssue({
            code: 'custom',
            path: ['角色'],
            message: "当`插入位置`不为`'指定深度'`时, `角色`不起作用, 不要填写",
          });
        }
        if (data.深度 !== undefined) {
          context.addIssue({
            code: 'custom',
            path: ['深度'],
            message: "当`插入位置`不为`'指定深度'`时, `深度`不起作用, 不要填写",
          });
        }
      }
    }),
  激活概率: schemas_number().min(0).max(100).optional(),
  递归: strictObject({
    不可被其他条目激活: schemas_boolean().describe('禁止其他条目递归激活本条目'),
    不可激活其他条目: schemas_boolean().describe('禁止本条目递归激活其他条目'),
    延迟递归: schemas_number().min(1).nullable().describe('延迟到第 n 级递归检查时才能激活本条目'),
  })
    .partial()
    .optional()
    .describe('递归表示某世界书条目被激活后, 该条目的提示词又激活了其他条目'),
  特殊效果: strictObject({
    黏性: schemas_number()
      .min(1)
      .nullable()
      .describe('黏性: 条目激活后, 在之后 n 条消息内始终激活, 无视激活策略、激活概率%'),
    冷却: schemas_number().min(1).nullable().describe('冷却: 条目激活后, 在之后 n 条消息内不能再激活'),
    延迟: schemas_number().min(1).nullable().describe('延迟: 聊天中至少有 n 楼消息时, 才能激活条目'),
  })
    .partial()
    .optional(),
  额外字段: record(schemas_string(), any()).optional().describe('额外字段: 用于为预设提示词绑定额外数据'),
  内容: schemas_string().optional().describe('内嵌的提示词内容'),
  文件: schemas_string().optional().describe('外链的提示词文件路径'),
}).superRefine((data, context) => {
  if (data.内容 === undefined && data.文件 === undefined) {
    ['内容', '文件'].forEach(key =>
      context.addIssue({
        code: 'custom',
        path: [key],
        message: '必须填写`内容`或`文件`',
      }),
    );
  }
  if (data.内容 !== undefined && data.文件 !== undefined) {
    ['内容', '文件'].forEach(key =>
      context.addIssue({
        code: 'custom',
        path: [key],
        message: '不能同时填写`内容`和`文件`',
      }),
    );
  }
});
const worldbook_zh_Worldbook = strictObject({
  锚点: any().optional().describe('用于存放 YAML 锚点, 不会被实际使用'),
  条目: array(worldbook_zh_Worldbook_entry).min(1),
}); // ./src/server/syncer/worldbook.ts

class Worldbook_syncer extends Syncer_interface {
  constructor(config_name, name, file) {
    super(
      'worldbook',
      _.invert(zh_to_en_map)['worldbook'],
      config_name,
      name,
      file,
      worldbook_en_Worldbook,
      worldbook_zh_Worldbook,
      worldbook_zh_zh_to_en_map,
      worldbook_zh_is_zh,
      Worldbook,
    );
  }
  // TODO: 拆分 component
  do_check_safe(local_data, tavern_data) {
    const local_names = local_data.entries.map(entry => entry.name);
    const tavern_names = tavern_data.entries.map(entry => entry.name);
    return {
      local_only_data: _.difference(local_names, tavern_names),
      tavern_only_data: _.difference(tavern_names, local_names),
    };
  }
  // TODO: 拆分 component
  do_pull(local_data, tavern_data, { should_split }) {
    let files = [];
    const entries_state = local_data === null ? [] : local_data.entries;
    tavern_data.entries.forEach(entry => {
      const handle_file = (entry, file) => {
        let file_to_write = '';
        let file_to_set = '';
        const glob_files = glob_file(this.dir, file);
        if (glob_files.length === 0) {
          file_to_write = file.replace(/\.[^\\/]+$|$/, detect_extension(entry.content));
          file_to_set = file.replace(/\.[^\\/]+$/, '');
        } else if (glob_files.length === 1) {
          file_to_write = glob_files[0];
          file_to_set = (0, external_node_path_.relative)(this.dir, glob_files[0]).replace(/\.[^\\/]+$/, '');
        } else {
          file_to_write = file;
          file_to_set = file;
        }
        files.push({
          name: entry.name,
          path: file_to_write,
          content: entry.content,
        });
        _.unset(entry, 'content');
        _.set(entry, 'file', file_to_set);
      };
      const state = entries_state.find(state => state.name === entry.name);
      if (state === undefined && should_split) {
        handle_file(
          entry,
          (0, external_node_path_.join)(sanitize_filename(this.config_name), sanitize_filename(entry.name)),
        );
      } else if (state?.file !== undefined) {
        handle_file(entry, state.file);
      }
    });
    return { result_data: tavern_data, files };
  }
  // TODO: 拆分 component
  do_beautify_config(tavern_data, language) {
    const document = new dist.Document(
      language === 'zh' ? translate(tavern_data, _.invert(this.zh_to_en_map)) : tavern_data,
    );
    ['条目', 'entries'].forEach(key =>
      dist.visit(document.get(key), (key, node) => {
        if (key === null) {
          return;
        }
        if (key > 0) {
          node.spaceBefore = true;
        }
        return dist.visit.SKIP;
      }),
    );
    dist.visit(document, (key, node) => {
      if (key === null) {
        return;
      }
      if (dist.isPair(node) && key > 0) {
        node.key.spaceBefore = true;
      }
      return dist.visit.SKIP;
    });
    return document.toString({ blockQuote: 'literal' });
  }
  // TODO: 拆分 component
  do_push(local_data) {
    let error_data = {
      未能找到以下外链提示词文件: [],
      通过补全文件后缀找到了多个文件: [],
      未能从合集文件中找到以下条目: [],
    };
    local_data.entries.forEach((entry, index) => {
      if (entry.file === undefined) {
        return;
      }
      const paths = glob_file(this.dir, entry.file);
      if (paths.length === 0) {
        error_data.未能找到以下外链提示词文件.push(`第 '${index}' 条目 '${entry.name}': '${entry.file}'`);
        return;
      }
      if (paths.length > 1) {
        error_data.通过补全文件后缀找到了多个文件.push(`第 '${index}' 条目 '${entry.name}': '${entry.file}'`);
        return;
      }
      const content = extract_file_content(paths[0]);
      if (is_collection_file(entry.file)) {
        const collection_file = parse_collection_file(content);
        const collection_entry = collection_file.find(value => value.name === entry.name);
        if (collection_entry === undefined) {
          error_data.未能从合集文件中找到以下条目.push(`'${entry.file}': 第 '${index}' 条目 '${entry.name}'`);
          return;
        }
        _.set(entry, 'content', collection_entry.content);
        _.unset(entry, 'file');
        return;
      }
      _.set(entry, 'content', content);
      _.unset(entry, 'file');
    });
    local_data.entries.forEach(entry => {
      _.set(entry, 'content', replace_user_name(entry.content));
    });
    local_data.entries.forEach(entry => {
      _.set(entry, 'content', replace_raw_string(entry.content));
    });
    return {
      result_data: local_data,
      error_data: _.pickBy(error_data, value => value.length > 0),
    };
  }
  do_watch(local_data) {
    return _(
      _(local_data.entries)
        .filter(entry => entry.file !== undefined)
        .map(entry => (0, external_node_path_.resolve)(this.dir, entry.file))
        .value(),
    )
      .map(path => (0, external_node_path_.dirname)(path))
      .reduce((result, path) => {
        if (result.some(parent => is_parent(parent, path))) {
          return result;
        }
        result.push(path);
        return result;
      }, [])
      .concat(this.file);
  }
} // ./src/server/syncer/factory.ts

function create_syncer(config_name, config) {
  if (config.type === 'worldbook') {
    return new Worldbook_syncer(config_name, config.name, config.file);
  }
  return new Preset_syncer(config_name, config.name, config.file);
} // ./src/server/component/add_configs_to_command.ts

function add_configs_to_command(command) {
  const settings = get_settings();
  command.addArgument(
    new Argument('<config>', `配置名称, 填入 'all' 或 '所有' 则选择所有配置`)
      .choices(Object.keys(settings.configs))
      .argParser(value => {
        if (['all', '所有'].includes(value)) {
          return Object.keys(settings.configs).map(config => create_syncer(config, settings.configs[config]));
        }
        if (!(value in settings.configs)) {
          exit_on_error(`配置 '${value}' 不存在, ${beauingfy_configs()}`);
        }
        return [create_syncer(value, settings.configs[value])];
      }),
  );
  return command;
} // ./src/server/component/check_update.ts

var check_update_filename = __webpack_fileURLToPath__(import.meta.url);

async function download_latest() {
  const urls = [
    'https://raw.githubusercontent.com/StageDog/tavern_sync/refs/heads/main/dist/tavern_sync.js',
    'https://cdn.jsdelivr.net/gh/StageDog/tavern_sync/dist/tavern_sync.js',
    'https://fastly.jsdelivr.net/gh/StageDog/tavern_sync/dist/tavern_sync.js',
    'https://testingcf.jsdelivr.net/gh/StageDog/tavern_sync/dist/tavern_sync.js',
  ];
  const erorr_data = {};
  const fetches = urls.map(async url => {
    try {
      const response = await fetch(url, { signal: AbortSignal.timeout(5000) });
      if (response.ok) {
        return { url, content: await response.text(), error: null };
      } else {
        return { url, content: null, error: `HTTP ${response.status} ${response.statusText}` };
      }
    } catch (error) {
      return { url, content: null, error: error.message };
    }
  });
  const results = await Promise.all(fetches);
  const [success_results, failed_results] = lodash_default().partition(results, result => result.content !== null);
  for (const result of failed_results) {
    lodash_default().set(erorr_data, [result.url], result.error);
  }
  if (success_results.length > 0) {
    return lodash_default().sortBy(success_results, result => urls.indexOf(result.url))[0].content;
  }
  throw Error(dist.stringify({ 无法获取最新版脚本: erorr_data }));
}
async function check_update() {
  const current_content = (0, external_node_fs_.readFileSync)(check_update_filename, 'utf8');
  const remote_content = await download_latest();
  if (current_content === remote_content) {
    return null;
  }
  return remote_content;
}
async function check_update_silently() {
  return check_update().then(result => {
    if (result !== null) {
      console.info(
        dist_dedent(`
          ******************************************************
          发现新版本，请运行 \`node tavern_sync.js update\` 更新
          ******************************************************
        `),
      );
    }
  });
} // ./src/server/command/pull.ts

function add_pull_command() {
  const command = new Command('pull').description('将酒馆内容拉取到本地');
  add_configs_to_command(command);
  command.option('-l, --language <language>', '要使用的语言', 'zh');
  command.option(
    '-i, --inline',
    '内嵌提示词: 如果酒馆中有新增条目, 则该条目的提示词内容应该内嵌在配置文件中, 而不是拆成外链提示词文件',
    false,
  );
  command.option(
    '-f, --force',
    '强制拉取: 如果酒馆中的条目名称或数量与本地中的不一致, 将会覆盖本地文件中的内容',
    false,
  );
  command.action(async (syncers, options) => {
    check_update_silently();
    await Promise.all(
      syncers.map(syncer =>
        syncer.pull({ language: options.language, should_split: !options.inline, should_force: options.force }),
      ),
    );
    close_server();
  });
  return command;
} // ./src/server/command/push.ts

function add_push_command() {
  const command = new Command('push').description('将本地内容推送到酒馆');
  add_configs_to_command(command);
  command.option(
    '-f, --force',
    '强制推送: 如果本地文件中的条目名称或数量与酒馆中的不一致, 将会覆盖酒馆中的内容',
    false,
  );
  command.action(async (syncers, options) => {
    check_update_silently();
    await Promise.all(syncers.map(syncer => syncer.push({ should_force: options.force })));
    close_server();
  });
  return command;
} // ./src/server/command/update.ts

var update_filename = __webpack_fileURLToPath__(import.meta.url);

function add_update_command() {
  const command = new Command('update').description('检查并更新本同步脚本');
  command.action(async () => {
    console.info('正在检查更新...');
    try {
      const result = await check_update();
      if (result === null) {
        console.info('当前版本已是最新版本，无需更新');
        return;
      }
      const backup_path = `${update_filename}.backup`;
      try {
        const current_content = (0, external_node_fs_.readFileSync)(update_filename, 'utf8');
        (0, external_node_fs_.writeFileSync)(backup_path, current_content);
        console.info(`已备份当前版本到: ${backup_path}`);
      } catch (error) {
        console.warn('无法创建备份文件，继续更新过程');
      }
      (0, external_node_fs_.writeFileSync)(update_filename, result);
      console.info('更新成功! 请重新启动脚本以使用新版本');
    } catch (error) {
      exit_on_error(error);
    }
  });
  return command;
} // ./src/server/command/watch.ts

function add_watch_command() {
  const command = new Command('watch').description('监听本地内容的变化并实时推送到酒馆');
  add_configs_to_command(command);
  command.option(
    '-f, --force',
    '强制推送: 如果本地文件中的条目名称或数量与酒馆中的不一致, 将会覆盖酒馆中的内容',
    false,
  );
  command.action(async (syncers, options) => {
    check_update_silently();
    await Promise.all(syncers.map(syncer => syncer.watch({ should_force: options.force })));
  });
  return command;
} // ./node_modules/.pnpm/zod@4.1.5/node_modules/zod/v4/locales/zh-CN.js

const error = () => {
  const Sizable = {
    string: { unit: '字符', verb: '包含' },
    file: { unit: '字节', verb: '包含' },
    array: { unit: '项', verb: '包含' },
    set: { unit: '项', verb: '包含' },
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType = data => {
    const t = typeof data;
    switch (t) {
      case 'number': {
        return Number.isNaN(data) ? '非数字(NaN)' : '数字';
      }
      case 'object': {
        if (Array.isArray(data)) {
          return '数组';
        }
        if (data === null) {
          return '空值(null)';
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: '输入',
    email: '电子邮件',
    url: 'URL',
    emoji: '表情符号',
    uuid: 'UUID',
    uuidv4: 'UUIDv4',
    uuidv6: 'UUIDv6',
    nanoid: 'nanoid',
    guid: 'GUID',
    cuid: 'cuid',
    cuid2: 'cuid2',
    ulid: 'ULID',
    xid: 'XID',
    ksuid: 'KSUID',
    datetime: 'ISO日期时间',
    date: 'ISO日期',
    time: 'ISO时间',
    duration: 'ISO时长',
    ipv4: 'IPv4地址',
    ipv6: 'IPv6地址',
    cidrv4: 'IPv4网段',
    cidrv6: 'IPv6网段',
    base64: 'base64编码字符串',
    base64url: 'base64url编码字符串',
    json_string: 'JSON字符串',
    e164: 'E.164号码',
    jwt: 'JWT',
    template_literal: '输入',
  };
  return issue => {
    switch (issue.code) {
      case 'invalid_type':
        return `无效输入：期望 ${issue.expected}，实际接收 ${parsedType(issue.input)}`;
      case 'invalid_value':
        if (issue.values.length === 1) return `无效输入：期望 ${stringifyPrimitive(issue.values[0])}`;
        return `无效选项：期望以下之一 ${joinValues(issue.values, '|')}`;
      case 'too_big': {
        const adj = issue.inclusive ? '<=' : '<';
        const sizing = getSizing(issue.origin);
        if (sizing)
          return `数值过大：期望 ${issue.origin ?? '值'} ${adj}${issue.maximum.toString()} ${sizing.unit ?? '个元素'}`;
        return `数值过大：期望 ${issue.origin ?? '值'} ${adj}${issue.maximum.toString()}`;
      }
      case 'too_small': {
        const adj = issue.inclusive ? '>=' : '>';
        const sizing = getSizing(issue.origin);
        if (sizing) {
          return `数值过小：期望 ${issue.origin} ${adj}${issue.minimum.toString()} ${sizing.unit}`;
        }
        return `数值过小：期望 ${issue.origin} ${adj}${issue.minimum.toString()}`;
      }
      case 'invalid_format': {
        const _issue = issue;
        if (_issue.format === 'starts_with') return `无效字符串：必须以 "${_issue.prefix}" 开头`;
        if (_issue.format === 'ends_with') return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
        if (_issue.format === 'includes') return `无效字符串：必须包含 "${_issue.includes}"`;
        if (_issue.format === 'regex') return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
        return `无效${Nouns[_issue.format] ?? issue.format}`;
      }
      case 'not_multiple_of':
        return `无效数字：必须是 ${issue.divisor} 的倍数`;
      case 'unrecognized_keys':
        return `出现未知的键(key): ${joinValues(issue.keys, ', ')}`;
      case 'invalid_key':
        return `${issue.origin} 中的键(key)无效`;
      case 'invalid_union':
        return '无效输入';
      case 'invalid_element':
        return `${issue.origin} 中包含无效值(value)`;
      default:
        return `无效输入`;
    }
  };
};
/* harmony default export */ function zh_CN() {
  return {
    localeError: error(),
  };
} // ./src/server/index.ts

config(zh_CN());
program
  .name('世界书同步脚本')
  .addCommand(add_list_command())
  .addCommand(add_pull_command())
  .addCommand(add_push_command())
  .addCommand(add_update_command())
  .addCommand(add_watch_command())
  .showHelpAfterError(true)
  .showSuggestionAfterError(true)
  .parse();
